

;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2013 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B437-7294-77			    |
; |			   Chris Nott, Virtual Logic			    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	59D3C587DDC97074E36E88F23E677079
; Input	CRC32 :	66E0325A


; Processor	  : z80	[]
; Target assembler: ASxxxx by Alan R. Baldwin v1.5
       .area   idaseg (ABS)
       .hd64 ; this is needed only for HD64180

; ===========================================================================

; Segment type:	Regular
		.org 0x3C00
video:		.ds 0x400
; end of 'video_seg'

; File Name   :	E:\Projects\pace\pacedev.net\sw\re\platform\trs80\timetrek\timetrek.bin
; Format      :	Binary file
; Base Address:	0000h Range: 40B7h - 4FFFh Loaded length: 00000F48h
; ===========================================================================

; Segment type:	Regular
		.org 0x4000
quadrant_map:	.ds 0x40
rand_seed:	.ds 2
level:		.ds 1
cur_quadrant:	.ds 1
stardate:	.ds 3
klingons0:	.ds 1
klingons:	.ds 1
bases0:		.ds 1
bases:		.ds 1
klingon_damages:.ds 3
pos_enterprise:	.ds 1
pos_starbase:	.ds 1
pos_stars:	.ds 5
pos_klingons:	.ds 3
pos_blkhole:	.ds 1
imp_damage:	.ds 1
warp_damage:	.ds 1
lrs_damage:	.ds 1
shield_damage:	.ds 1
phaser_damage:	.ds 1
ship_nrg:	.ds 1
shields:	.ds 1
photons:	.ds 1
starbase_damage:.ds 1
word_4062:	.ds 2
sos_starbase_qpos:.ds 1
sos_starbase_ttl:.ds 1
		.ds 0x25
stack1:		.ds 1
		.ds 0x2B
stack2:		.dw klingon_thread
aTimeTrek:	.ascii ')))TIME TREK((('
		.db 0
aCopyright1978J:.ascii 'COPYRIGHT 1978 JOSHUA LAVINSKY'
		.db 0
aWhatLevelDoYou:.ascii 'WHAT LEVEL DO YOU WISH TO PLAY (1-10)? '
		.db 0
aYourMission:	.ascii 'YOUR MISSION:'
		.db 0
aDestroyTheFlee:.ascii 'DESTROY THE FLEET OF'
		.db 0
aBeforeTheyDest:.ascii ' BEFORE THEY DESTROY THE'
		.db 0
aFederationStar:.ascii ' FEDERATION STARBASES'
		.db 0
aGoodLuck:	.ascii 'GOOD LUCK!'
		.db 0
; ---------------------------------------------------------------------------

entry_point:
		ld	sp, #stack1
		ld	ix, #0x3FFB
		ld	iy, #stack2
		call	cls					; clear	screen
		ld	hl, #aTimeTrek				; ")))TIME TREK((("
		ld	bc, # video+0x19
		call	str_hl_at_bc
		ld	bc, # video+0x3E2
		call	str_hl_at_bc				; copyright
		xor	a					; clear	$4000-$407F

loc_418B:							; display on screen
		ld	(bc), a
		inc	c					; next location
		jp	P, loc_418B
; Initialize some globals; IX=3FFB at this point
		ld	0x65(ix), #3
		ld	0x63(ix), #100				; ship_nrg
		ld	0x64(ix), #100				; shields
		ld	d, b
		ld	bc, # video+0x80
		call	str_hl_at_bc				; display level	prompt
		call	getint_HL
; Level	in HL; start over if <=	0 or >=	11
		ld	a, l
		or	a					; level	= 0?
		jr	Z, entry_point				; yes, start over
		cp	#11					; level	>= 11?
		jr	NC, entry_point				; yes, start over
		ld	0x47(ix), l				; level

gen_galaxy:
		xor	a

loc_41B2:							; bases0
		ld	0x4E(ix), a
		ld	e, a					; current quadrant
		ld	c, a					; klingons

; E loops 0 to 63 as current quadrant.
; C counts Klingons.
; B holds quadrant parameters.
; Quadrant has a 3/130 chance of a black hole. 1.48 average per	galaxy.
; 4/131	chance of a magnetic storm. 1.95 average per galaxy.

gen_quad:
		ld	a, #130
		ld	b, #0
		call	rand
		rla
		rr	b
		ld	a, #131
		call	rand
		rla
		rr	b
		srl	b
; Stars.  Very nearly even chance of 2 to 5.
		ld	a, #31
		call	rand
		or	b
		and	#0x78 ;	'x'
		ld	b, a
; If current klingons *	10 / quad num <= level then no klingons	here.
; Given	LdivH, I think we'll never start with klingons in quadrant 0.
; And always have klingons in quadrant 1.
		ld	l, #0xA
		ld	h, c
		call	HxL
		ld	h, e
		call	LdivH
		sub	0x47(ix)				; level
		jr	NC, no_klingons
; Klingons chosen as rand(rand(3)).
; 11/18	for 1, 5/18 for	2 and 2/18 for 3.
		ld	a, #3
		call	rand
		call	rand
		ld	h, a
		rlca
		or	b
		ld	b, a
		ld	a, h
		add	a, c
		ld	c, a

; 19/146 chance	of a starbase; about 13%.  We'll average 8.3 in the galaxy.

no_klingons:
		ld	a, #146
		call	rand
		rla
		jr	NC, no_starbase
		inc	b
		inc	0x4E(ix)				; bases0

no_starbase:
		ld	a, b
		ld	(de), a
		inc	e
		ld	a, e
		cp	#64
		jr	NZ, gen_quad
		ld	e, #0x47 ; 'G'
		ld	a, c
		ld	(de), a
		inc	e
		ld	(de), a
		inc	e
		ld	a, (de)
		inc	e
		ld	(de), a
; Only 6 to 12 starbases are acceptable.  Start	over if	not.
		cp	#6
		jr	C, gen_galaxy
		cp	#13
		jr	NC, gen_galaxy
; Pick random starting quadrant	for Enterprise.
		ld	a, #63
		call	rand
		ld	e, a
		call	cls
		ld	b, #0x3C ; '<'
		ld	hl, #aYourMission			; "YOUR	MISSION:"
		call	str_hl_at_bc
		ld	c, #0x82 ; '‚'
		call	str_hl_at_bc				; "DESTROY THE FLEET OF"
		ld	a, 0x4C(ix)				; klingons0
		call	print_a
		ld	hl, #aKlingonShips			; " KLINGON SHIPS"
		call	str_hl_at_bc
		ld	hl, #aBeforeTheyDest			; " BEFORE THEY	DESTROY	THE"
		call	str_hl_at_bc
		ld	a, 0x4E(ix)				; bases0
		ld	c, #0xC2 ; 'Â'
		call	print_a
		call	str_hl_at_bc
		ld	bc, # video+0x16C
		call	str_hl_at_bc
		call	getchar
		ld	ix, #quadrant_map

; Initialize the position of everything	in the quadrant	(at DE,	of course)
; Also displays	the black hole warning as needed.

quad_init:
		push	de
		ld	0x43(ix), e				; cur_quadrant
		ld	e, #78

loc_425E:
		ld	a, #127
		call	rand
		rlca
		ld	(de), a
		and	#0x1F
		jr	Z, loc_425E
		ld	hl, #pos_enterprise

loc_426C:
		ld	a, l
		cp	e
		jr	Z, loc_4277
		ld	a, (de)
		cp	(hl)
		jr	Z, loc_425E
		inc	l
		jr	loc_426C
; ---------------------------------------------------------------------------

loc_4277:
		inc	e
		ld	a, e
		cp	#0x59 ;	'Y'
		jr	NZ, loc_425E
		pop	de
		call	cls
		ld	a, (de)
		and	#0x60 ;	'`'
		cp	#0x20 ;	' '
		jr	NZ, get_command
		ld	hl, #aSensorsDetectABlackHoleInThisQu	; "SENSORS DETECT A BLACK HOLE IN THIS QUA"...
		ld	b, #0x3C ; '<'
		call	str_hl_at_bc

get_command:
		call	draw_srs

nd_get_command:							; "COMMAND?"
		ld	hl, #aCommand
		ld	bc, # video+0x3F6
		call	str_hl_at_bc
		dec	c
		call	getchar
		sub	#0x31 ;	'1'
		jp	Z, cmd_status
		jr	C, nd_get_command
		cp	#7
		jr	NC, nd_get_command
		push	af
		ld	c, #0xC0 ; 'À'
		call	clreol
		ld	bc, # video+0x40
		call	clreol
		pop	af
		cp	#5
		jr	NC, loc_42E1
		ld	hl, #aWarpEngines			; "WARP	ENGINES"
		push	de
		ld	e, a
		ld	d, e

loc_42C2:
		ld	bc, #video
		call	str_hl_at_bc
		dec	d
		jr	NZ, loc_42C2
		ld	hl, #aInoperable			; " INOPERABLE"
		call	str_hl_at_bc
		call	clreol

s_noover:
		ld	b, #0x40 ; '@'
		ld	a, e
		add	a, #0x59 ; 'Y'
		ld	c, a
		ld	a, (bc)
		cp	#100
		ld	a, e
		pop	de
		jr	NC, nd_get_command

loc_42E1:
		dec	a
		jp	Z, cmd_warp
		dec	a
		jp	Z, cmd_lrs
		dec	a
		jp	Z, cmd_shield
		dec	a
		jp	Z, cmd_phaser
		dec	a
		jp	Z, cmd_photon
		jp	cmd_destruct

; =============== S U B	R O U T	I N E =======================================

; Draws	the short range	scanners plus checks a number of
; game ending conditions or something.	Not fully understood.
; First	we erase the area save for the frame.

draw_srs:
		ld	hl, # video+0x80
		ld	bc, #0xAA95

loc_42FE:
		ld	a, #0x2D ; '-'
		ld	(hl), a
		inc	l
		ld	a, l
		cp	#0xC0 ;	'À'
		jr	NZ, loc_42FE

loc_4307:
		ld	(hl), c

loc_4308:
		inc	hl
		ld	a, #0x80 ; '€'
		ld	(hl), a
		ld	a, l
		and	#0x3F ;	'?'
		jr	NZ, loc_4308
		dec	hl
		ld	(hl), b
		inc	hl
		ld	a, l
		cp	#0xC0 ;	'À'
		jr	NZ, loc_4307
		ld	a, h
		cp	#0x3E ;	'>'
		jr	NZ, loc_4307

loc_431E:
		ld	a, #0x2D ; '-'
		ld	(hl), a
		inc	l
		jr	NZ, loc_431E
; End of function draw_srs


; =============== S U B	R O U T	I N E =======================================

; Display the Enterprise herself.

disp_srs_ships:
		ld	a, 0x4E(ix)				; pos_enterprise
		call	pos2scrn
		ld	hl, #aV					; "\"V\""
		call	str_hl_at_bc
		ld	e, 0x43(ix)				; cur_quadrant
		ld	d, #0x40 ; '@'
		ld	a, (de)
		and	#1
		jr	Z, no_starbase_l
		ld	a, 0x4F(ix)				; pos_starbase
		call	pos2scrn
		call	str_hl_at_bc

; Draw stars

no_starbase_l:
		ld	a, (de)
		and	#0x18
		rrca
		rrca
		rrca
		push	de
		add	a, #0x51 ; 'Q'
		ld	e, a

loc_434D:
		ld	a, (de)
		call	pos2scrn
		ld	a, #0x2E ; '.'
		ld	(bc), a
		dec	e
		ld	a, e
		cp	#0x4F ;	'O'
		jr	NZ, loc_434D
; Draw Klingons
		pop	de
		ld	a, (de)
		and	#6
		rrca
		push	de
		add	a, #0x54 ; 'T'
		ld	e, a

loc_4363:
		ld	a, e
		cp	#0x54 ;	'T'
		jr	Z, loc_4375
		ld	a, (de)
		call	pos2scrn
		ld	hl, #klingon				; "<*>"
		call	str_hl_at_bc
		dec	e
		jr	loc_4363
; ---------------------------------------------------------------------------

loc_4375:
		pop	de
		jp	draw_stats
; End of function disp_srs_ships

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR ship_hit

no_more_starbases:
		ld	bc, # video+0x300
		ld	hl, #aTheLastStarbaseHasBeenDestroyed	; "THE LAST STARBASE HAS BEEN DESTROYED"
		call	str_hl_at_bc
		ld	d, #0
		ld	hl, #aWillBeConquered			; "WILL	BE CONQUERED"
		jr	game_done
; END OF FUNCTION CHUNK	FOR ship_hit
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR getchar

ent_dead:
		push	hl
		ld	bc, # video+0x300
		ld	hl, #aTheEnterpriseHasBeen		; "THE ENTERPRISE HAS BEEN "
		call	str_hl_at_bc
		pop	hl
		call	str_hl_at_bc
		ld	d, #0
		ld	hl, #aWillBeConquered			; "WILL	BE CONQUERED"
		jr	game_done
; END OF FUNCTION CHUNK	FOR getchar

; =============== S U B	R O U T	I N E =======================================


LdivB:
		push	bc
		xor	a
		jp	loc_4FDE
; End of function LdivB

; ---------------------------------------------------------------------------
; I'm guessing a bit on some of the variables, but here's the score calc:
; (((((B1 * 32)	% 256[maybe]) /	B0) * L) % 256)	* 24) %	256[maybe]) / S
;
; Where:
;    B0	- initial number of starbases
;    B1	- starbases left at end	of game
;    S	- stardates used
;    L	- level	selected (1 - 10, of course)
;
; Seems	rife with overlows
;
; START	OF FUNCTION CHUNK FOR ship_hit

victory:							; bases
		ld	l, 0x4A(ix)
		ld	h, #0
		add	hl, hl
		add	hl, hl
		add	hl, hl
		add	hl, hl
		add	hl, hl
		ld	b, 0x49(ix)				; bases0
		call	LdivB
		ld	h, 0x42(ix)				; level
		call	HxL
		ld	h, #0x18
		call	HxL
		ld	b, 0x44(ix)				; stardate
		call	LdivB
		ld	d, a
		ld	bc, # video+0x300
		ld	hl, #aYouHaveDestroyedAll		; "YOU HAVE DESTROYED ALL"
		call	str_hl_at_bc
		ld	a, 0x47(ix)				; klingons0
		call	print_a
		call	str_hl_at_bc
; END OF FUNCTION CHUNK	FOR ship_hit
; START	OF FUNCTION CHUNK FOR getchar

game_done:
		ld	e, #4

loc_43D9:
		call	clreol
		dec	e
		jr	NZ, loc_43D9
		ld	bc, # video+0x350
		call	str_hl_at_bc
		ld	hl, #aTheFederation			; "THE FEDERATION "
		ld	c, #0x40 ; '@'
		call	str_hl_at_bc
		ld	c, #0x65 ; 'e'
		call	str_hl_at_bc
		ld	a, d
		call	print_a
		ld	c, #0xEC ; 'ì'
		call	str_hl_at_bc

loc_43FB:							; keyboard row with 'Y'
		ld	a, (0x3808)
		or	a					; any key pressed?
		jr	Z, loc_43FB				; no, loop
		jp	entry_point
; END OF FUNCTION CHUNK	FOR getchar
; ---------------------------------------------------------------------------
aInoperable:	.ascii ' INOPERABLE'
		.db 0
aTheEnterpriseHasBeen:.ascii 'THE ENTERPRISE HAS BEEN '
		.db 0
aTheLastStarbaseHasBeenDestroyed:.ascii	'THE LAST STARBASE HAS BEEN DESTROYED'
		.db 0
aV:		.ascii '"V"'
		.db 0
aO:		.ascii '+O+'
		.db 0
klingon:	.ascii '<*>'
		.db 0
aSensorsDetectABlackHoleInThisQu:.ascii	'SENSORS DETECT A BLACK HOLE IN THIS QUADRANT!'
		.db 0
aCommand:	.ascii 'COMMAND?'
		.db 0
aYouHaveDestroyedAll:.ascii 'YOU HAVE DESTROYED ALL'
		.db 0
aKlingonShips:	.ascii ' KLINGON SHIPS'
		.db 0
aIsSaved:	.ascii 'IS SAVED'
		.db 0
aWillBeConquered:.ascii	'WILL BE CONQUERED'
		.db 0
aTheFederation:	.ascii 'THE FEDERATION '
		.db 0
aYourScoreIs:	.ascii 'YOUR SCORE IS'
		.db 0
aCareToPlayAgain:.ascii	'CARE TO PLAY AGAIN?'
; ---------------------------------------------------------------------------

cmd_status:
		nop
		call	cls
		ld	b, #0x3C ; '<'
		ld	a, 0x48(ix)				; klingons
		call	print_a
		ld	hl, #aKlingonsLeft			; " KLINGONS LEFT"
		call	str_hl_at_bc
		ld	c, #0x20 ; ' '
		ld	a, 0x4A(ix)				; bases
		call	print_a
		call	str_hl_at_bc
		ld	c, #0xC0 ; 'À'
		call	str_hl_at_bc
		ld	bc, # video+0x140
		push	de
		ld	e, #0x59 ; 'Y'

loc_452B:
		call	str_hl_at_bc
		ld	a, c
		and	#0xC0 ;	'À'
		add	a, #0x18
		ld	c, a
		ld	a, (de)
		call	print_a
		ld	a, #0x25 ; '%'
		ld	(bc), a
		inc	bc
		call	clreol
		inc	de
		ld	a, e
		cp	#0x5E ;	'^'
		jr	NZ, loc_452B
		pop	de
		call	getchar
		jr	loc_45B7
; ---------------------------------------------------------------------------
aKlingonsLeft:	.ascii ' KLINGONS LEFT'
		.db 0
aBasesLeft:	.ascii ' BASES LEFT'
		.db 0
aDamage:	.ascii 'DAMAGE'
		.db 0
aImpulseEngines:.ascii 'IMPULSE ENGINES'
		.db 0
aWarpEngines:	.ascii 'WARP ENGINES'
		.db 0
aScanners:	.ascii 'SCANNERS'
		.db 0
aShields:	.ascii 'SHIELDS'
		.db 0
aPhasers:	.ascii 'PHASERS'
		.db 0
; ---------------------------------------------------------------------------

cmd_shield:
		ld	bc, #video
		ld	hl, #aEnergyToShields			; "% ENERGY TO SHIELDS?	"
		call	str_hl_at_bc
		call	getint_HL
		ld	a, l
		cp	#101
		jr	NC, cmd_shield
		ld	0x5F(ix), a				; shields

loc_45B7:
		jp	get_command
; ---------------------------------------------------------------------------
aEnergyToShields:.ascii	'% ENERGY TO SHIELDS? '
		.db 0
; ---------------------------------------------------------------------------

cmd_warp:
		ld	bc, #video
		push	bc
		call	clreol
		pop	bc
		ld	hl, #aSetCourseFor			; "SET COURSE FOR? "
		call	str_hl_at_bc
		call	getchar
		jr	Z, loc_45FE
		cp	#0x38 ;	'8'
		jr	NC, cmd_warp
		sub	#0x30 ;	'0'
		jr	C, cmd_warp
		ld	h, a
		call	getchar
		jr	Z, loc_45FE
		cp	#0x38 ;	'8'
		jr	NC, cmd_warp
		sub	#0x30 ;	'0'
		jr	C, cmd_warp
		rlca
		rlca
		rlca
		or	h
		cp	e

loc_45FE:
		jp	Z, nd_get_command
		ld	e, a
		ld	iy, #stack2
		ld	0x61(ix), #0				; starbase_damage
		jp	quad_init
; ---------------------------------------------------------------------------
aSetCourseFor:	.ascii 'SET COURSE FOR? '
		.db 0
; ---------------------------------------------------------------------------

cmd_lrs:
		call	cls
		ld	hl, #aLongRangeScan			; "LONG	RANGE SCAN"
		ld	b, #0x3C ; '<'
		call	str_hl_at_bc
		push	de
		ld	e, #0x30 ; '0'
		ld	hl, # video+0x85
		ld	c, #0xC0 ; 'À'

loc_4631:
		ld	a, e
		ld	(bc), a
		ld	(hl), a
		ld	a, l
		add	a, #8
		ld	l, a
		inc	bc
		push	de
		push	hl
		ld	a, 0x43(ix)				; cur_quadrant
		ld	h, a
		and	#7
		ld	l, a
		ld	a, e
		sub	#0x30 ;	'0'
		rlca
		rlca
		rlca
		ld	e, a

loc_4649:
		ld	a, #0xAA ; 'ª'
		ld	(bc), a
		push	bc
		ld	a, (de)
		and	#1
		jr	NZ, loc_4668
		ld	a, e
		and	#7
		sub	l
		jr	NC, loc_465A
		neg

loc_465A:
		cp	#2
		jr	NC, loc_468E
		ld	a, e
		sub	h
		jr	NC, loc_4664
		neg

loc_4664:
		cp	#0xA
		jr	NC, loc_468E

loc_4668:
		inc	bc
		inc	bc
		ld	a, e
		cp	h
		jr	NZ, loc_4672
		ld	a, #0x45 ; 'E'
		ld	(bc), a
		inc	bc

loc_4672:
		ld	a, (de)
		and	#1
		jr	Z, loc_467C
		ld	a, #0x42 ; 'B'
		inc	bc
		ld	(bc), a
		inc	bc

loc_467C:
		ld	a, (de)
		bit	6, a
		jr	Z, loc_4687
		ld	a, #0x4D ; 'M'
		inc	bc
		ld	(bc), a
		jr	loc_468E
; ---------------------------------------------------------------------------

loc_4687:
		ld	a, (de)
		and	#6
		rrca
		call	print_a

loc_468E:
		pop	bc
		inc	e
		ld	a, c
		add	a, #8
		jr	NC, loc_4696
		inc	b

loc_4696:
		ld	c, a
		and	#0x3F ;	'?'
		dec	a
		jr	NZ, loc_4649
		pop	hl
		pop	de
		dec	bc
		inc	e
		ld	a, e
		cp	#0x38 ;	'8'
		jr	NZ, loc_4631
		pop	de
		call	getchar

loc_46A9:
		jp	get_command
; ---------------------------------------------------------------------------
aLongRangeScan:	.ascii 'LONG RANGE SCAN'
		.db 0
; ---------------------------------------------------------------------------

cmd_destruct:
		ld	bc, #video
		ld	hl, #aConfirm				; "CONFIRM? "
		call	str_hl_at_bc
		call	getint_HL
		ld	a, l
		cp	#0x7B ;	'{'
		jr	NZ, loc_46A9
		ld	c, 0x4E(ix)				; pos_enterprise
		ld	b, #0x40 ; '@'
		ld	a, #0xFF
		call	sub_487F
		ld	a, (de)
		and	#6
		rrca
		sub	0x48(ix)				; klingons
		jp	Z, victory
; START	OF FUNCTION CHUNK FOR ship_hit

enterprise_destroyed:
		ld	hl, # aTheLastStarbaseHasBeenDestroyed+0x1B
		jp	ent_dead
; END OF FUNCTION CHUNK	FOR ship_hit
; ---------------------------------------------------------------------------
aConfirm:	.ascii 'CONFIRM? '
		.db 0
; ---------------------------------------------------------------------------

cmd_phaser:
		ld	bc, # video+8
		ld	hl, #aAt				; "AT "
		call	str_hl_at_bc
		dec	bc
		call	phaser_pct
		call	print_a
		ld	a, #0x25 ; '%'
		ld	(bc), a
		inc	bc
		call	clreol
		ld	c, #0x20 ; ' '
		jr	loc_4756
; ---------------------------------------------------------------------------
aAt:		.ascii 'AT '
		.db 0

; =============== S U B	R O U T	I N E =======================================


phaser_pct:
		ld	l, 0x5F(ix)				; shields
		sla	l
		ld	h, #3
		call	LdivH
		ld	a, #100
		sub	l
		ld	h, a
		ret
; End of function phaser_pct

; ---------------------------------------------------------------------------
aPhotonTubesEmpty:.ascii 'PHOTON TUBES EMPTY'
		.db 0
aDegrees:	.ascii 'DEGREES? '
		.db 0
; ---------------------------------------------------------------------------

cmd_photon:
		ld	bc, #video
		ld	a, 0x60(ix)				; photons
		or	a
		jr	NZ, loc_4751
		ld	hl, #aPhotonTubesEmpty			; "PHOTON TUBES	EMPTY"
		call	str_hl_at_bc
		call	clreol
		jp	nd_get_command
; ---------------------------------------------------------------------------

loc_4751:							; photons
		dec	0x60(ix)
		ld	h, #0

loc_4756:
		push	hl
		ld	hl, #aDegrees				; "DEGREES? "
		call	str_hl_at_bc
; compute BC as	a vector in direction of input angle
		call	getint_HL
		srl	h
		rr	l
		ex	de, hl
		ld	a, e
		call	angle_cosine
		ld	b, a
		ld	a, e
		add	a, #0x2D ; '-'
		call	angle_cosine
		ld	c, a
		ld	a, 0x4E(ix)				; pos_enterprise
		pop	hl
		call	draw_shot
		call	C, ship_hit
		jp	nd_get_command

; =============== S U B	R O U T	I N E =======================================

; Returns cosine(A) in H
; This uses approximation that sin(X) ~	X
; Since	angle is in 2*degrees, the result is
; is not the actual cosine by cosine(X)*90/PI
; But this is good enough for producing	a vector
; which	points in the direction	of the angle

angle_cosine:
		ld	l, a
		ld	h, #0x5A ; 'Z'
		call	LdivH
		ld	a, h
		sub	#0x2D ;	'-'
		bit	0, l
		ret	NZ
		neg
		ret
; End of function angle_cosine


; =============== S U B	R O U T	I N E =======================================

; Normalizes B,C into HL,DE. (HL=delta x, DE=delta Y)
; look at the calling context to figure	out which is which.
; the 'ret po' is a clever way to detect the 'overflow' because it uses
; signed versions of HL,DE.

normalize_BC:
		ld	l, b
		xor	a
		bit	7, l
		jr	Z, dx_positive
		cpl

dx_positive:
		ld	h, a
		add	hl, hl
		ld	e, c
		xor	a
		bit	7, e
		jr	Z, dy_positive
		cpl

dy_positive:
		ld	d, a

keep_shifting:
		add	hl, hl
		ex	de, hl
		add	hl, hl
		ex	de, hl
		ld	a, d
		or	a
		ret	PO
		ld	a, h
		or	a
		ret	PO
		jr	keep_shifting
; End of function normalize_BC


; =============== S U B	R O U T	I N E =======================================

; Something in the quadrant has	been hit
; HL points to its qpos.
; (4062) contains the phaser/photon flag and the distance
; HL is	loaded so L is the flag	and H the distance
; Then (roughly) sqrt( 2 * (2*L/(H/4)) ) is computed.
; and put in C--this is	the force of the hit.
; if L/H == 0 then it becomes 255--this	makes a	photon torp
; have a strong	impact

ship_hit:

; FUNCTION CHUNK AT 4379 SIZE 00000010 BYTES
; FUNCTION CHUNK AT 43A3 SIZE 00000034 BYTES
; FUNCTION CHUNK AT 46E1 SIZE 00000006 BYTES

		push	hl
		ld	hl, (word_4062)				; starbase_damage+1
		srl	h
		srl	h
		sla	l
		call	LdivH
		or	a
		jr	NZ, loc_47BB
		cpl

loc_47BB:
		pop	hl
		ld	c, #0

; Simple sum_reduce loop finds C such that C(C-1)/2 > A
; By the quadractic formula C =	(1 +- sqrt( 1 +	8C ) ) / 2
; This is approximately	sqrt( 2*C )

sum_reduce:
		inc	c
		sub	c
		jr	NC, sum_reduce
		ld	a, l
		sub	#0x4E ;	'N'
		jr	NZ, not_bige_hit
		push	bc
		ld	bc, # video+0x64
		ld	hl, #aEnterpriseHit			; "ENTERPRISE HIT"
		call	str_hl_at_bc
		pop	bc
		ld	h, 0x42(ix)				; level
		inc	h
		srl	h
		ld	l, c
		call	HxL
		ld	c, a
		ld	hl, #pos_blkhole

; Enterprise is	hit!  Above we computed	(level+1)/2 * shot_power
; The loop below will randomly apply the calculated damaged C

damage_systems:
		inc	hl
		ld	a, c
		rlca
		call	rand
		add	a, (hl)
		ld	(hl), a
		ld	a, l
		cp	#0x5D ;	']'
		jr	NZ, damage_systems
; Gets L=ship_ngr, H=shields
		ld	hl, (ship_nrg)
		ld	a, l
		sub	c
		jr	C, loc_4815
		ld	l, a
		ld	a, h
		or	a
; If no	shields	power, you die
		jr	Z, loc_4815
; Load A with shield damage, if	>100% then set shield power to 0
		ld	a, 0x5C(ix)				; shield_damage
		cp	#100
; If hit C > ship_ngr, you die
		jr	C, loc_4802
		ld	h, #0

loc_4802:
		ld	(ship_nrg), hl
		ret
; ---------------------------------------------------------------------------
aEnterpriseHit:	.ascii 'ENTERPRISE HIT'
		.db 0
; ---------------------------------------------------------------------------

loc_4815:
		ld	a, (video+0xC0)
		rla
		ld	hl, #0x404E
		call	C, explosion_at_hl
		jp	enterprise_destroyed
; ---------------------------------------------------------------------------

; if position pointer is bige+1, then a	starbase is hit

not_bige_hit:
		dec	a
		jr	NZ, klingon_hit
; Add C	to (starbase_damage).  If > 12 starbase	is destroyed
		ld	a, 0x61(ix)				; starbase_damage
		add	a, c
		ld	0x61(ix), a				; starbase_damage
		cp	#0xC
		ret	C
		ld	a, (video+0xC0)
		rla
		jr	NC, destroy_base_at_DE
		call	explosion_at_hl
		ex	de, hl
		dec	(hl)
		call	draw_srs

; Reset	starbase bit in	this quadrant

destroy_base_at_DE:
		ld	a, (de)
		res	0, a
		ld	(de), a
		dec	0x4A(ix)				; bases
		jp	Z, no_more_starbases
		ret
; ---------------------------------------------------------------------------

; Klingon damage table is 10 bytes before klingon position table
; If Klingon damage > 10 the klingon is	killed
; This makes them slighly weaker than starbases

klingon_hit:
		ld	b, l
		ld	a, l
		sub	#10
		ld	l, a
		ld	a, (hl)
		add	a, c
		ld	(hl), a
		cp	#10
		ret	C
		ld	iy, #stack2
		ld	l, b
		push	hl
		call	explosion_at_hl
		pop	hl
		ld	b, l

dec_klingon:
		ld	a, (de)
		sub	#2
		ld	(de), a
; Move the last	klingon	in the position	list to	replace	the first one
; Note that the	damage table is	not altered.  This could benefit
; or hurt the player depending on the breaks
		rrca
		and	#3
		add	a, #0x55 ; 'U'
		ld	l, a
		ld	a, (hl)
		ld	l, b
		ld	(hl), a
; Decrement global klingon count, perhaps causing victory
		dec	0x48(ix)				; klingons
		jp	Z, victory
		jp	draw_srs
; End of function ship_hit


; =============== S U B	R O U T	I N E =======================================


explosion_at_hl:
		ld	c, (hl)
		ld	b, #0xA
		ld	a, #0x1C
		call	rand
		add	a, #8
		scf
; End of function explosion_at_hl


; =============== S U B	R O U T	I N E =======================================


sub_487F:
		push	de
		push	af
		ld	a, c
		call	coord_to_xy
		ld	hl, #0
		push	bc

loc_4889:
		ld	a, h
		call	rand
		ld	b, h
		srl	b
		sub	b
		add	a, d
		ld	b, a
		ld	a, l
		call	rand
		ld	c, l
		srl	c
		sub	c
		add	a, e
		ld	c, a
		call	check_xy_in_srs
		push	hl
		call	C, flipBC
		pop	hl
		xor	a
		out	(0xFF),	a

loc_48A8:
		dec	a
		jr	NZ, loc_48A8
		pop	af
		dec	a
		jr	NZ, loc_48CA
		inc	h
		pop	bc
		dec	b
		jr	Z, loc_48CD
		ld	a, #5
		bit	0, c
		jr	NZ, loc_48BF
		ld	a, #8
		call	rand

loc_48BF:
		out	(0xFF),	a
		push	bc
		ld	a, h
		and	#3
		jr	NZ, loc_48C8
		inc	l

loc_48C8:
		ld	a, #5

loc_48CA:
		push	af
		jr	loc_4889
; ---------------------------------------------------------------------------

loc_48CD:
		pop	de
		ret
; End of function sub_487F


; =============== S U B	R O U T	I N E =======================================

; Fire a phaser	or a photon shot
; if H=0 a photon else a phaser
; if H > 127 the shot is a tracer so draw no tail
; A is the start pos, and C the	angle.

draw_shot:
		push	af
		ld	0x62(ix), h
		call	coord_to_xy
		ld	h, e
		xor	a
		ld	e, a
		ld	l, a
		ld	(weapon_x), de
		ld	(weapon_y), hl
		ex	(sp), hl
		push	de
		push	hl
		ld	0x63(ix), a
		call	normalize_BC
		ld	(weapon_dx), hl
		ld	(weapon_dy), de
		pop	de

keep_drawing_shot:
		push	de
		call	extend_shot
		pop	de
; This branch means the	shot moved out of range
		jr	NC, shot_hit_something
		push	bc
		push	de
		call	xy2scrnbit
		call	doesHLhit
		pop	de
		pop	bc
		jr	Z, shot_hit_something
		ld	a, 0x62(ix)
		or	a
		call	Z, resetBC
		jr	keep_drawing_shot
; ---------------------------------------------------------------------------

shot_hit_something:
		pop	de
		ex	(sp), hl
		push	af
		ld	a, 0x62(ix)
; Avoid	doing erase_tail if the	weapon flag is 0 or ff
		inc	a
		jr	Z, loc_4938
		dec	a
		jr	Z, loc_4935
		ld	(weapon_x), de
		ld	(weapon_y), hl
		ld	d, 0x63(ix)

erase_tail:
		push	de
		call	extend_shot
		pop	de
		ld	a, (video+0xC0)
		rla
		jr	NC, loc_4938
		call	resetBC
		dec	d
		jr	NZ, erase_tail

loc_4935:
		call	disp_srs_ships

loc_4938:							; cur_quadrant
		ld	e, 0x43(ix)
		ld	d, #0x40 ; '@'
		pop	af
		pop	hl
		ret
; End of function draw_shot


; =============== S U B	R O U T	I N E =======================================

; extend_shot adds to the phaser/photon	line

extend_shot:
		ld	de, (weapon_dx)
		ld	hl, (weapon_x)
		add	hl, de
		push	de
		push	hl
		ld	b, h
		ld	de, (weapon_dy)
		ld	hl, (weapon_y)
		add	hl, de
		ld	c, h
		call	check_xy_in_srs
		jr	NC, shot_outside_srs
		push	hl
		ld	a, (video+0xC0)
		cpl
		or	0x62(ix)
		call	P, flipBC
		pop	hl
		push	bc
		ld	bc, (word_4062)				; starbasedamage+1
		inc	b
		call	periodic
		ld	(word_4062), bc				; starbase_damage+1
		scf
		pop	bc

shot_outside_srs:
		ld	(weapon_dy), de
		ld	(weapon_y), hl
		pop	hl
		pop	de
		ld	(weapon_dx), de
		ld	(weapon_x), hl
		ret
; End of function extend_shot


; =============== S U B	R O U T	I N E =======================================

; Clear	the pixel at (B,C).  Seems to expect that it is	a graphics char	already.

resetBC:
		call	xy2scrnbit
		set	7, (hl)
		cpl
		and	(hl)
		ld	(hl), a
		ret
; End of function resetBC

; ---------------------------------------------------------------------------
weapon_dx:	.dw 0
weapon_dy:	.dw 0
weapon_x:	.dw 0
weapon_y:	.dw 0
; ---------------------------------------------------------------------------

; This is the starting point for the klingon thread
; Until	we get to time $0f (about 7.5 seconds),	the klingons
; are inactive

klingon_thread:
		call	periodic
		ld	a, (stardate)
		or	a
		jr	NZ, klingon_AI
		ld	a, (stardate+2)
		cp	#0xF
		jr	C, klingon_thread

klingon_AI:
		dec	sp
		dec	sp
		ld	de, #klingon_damages
		xor	a
		ld	(de), a
		inc	e
		ld	(de), a
		inc	e
		ld	(de), a
		ld	e, 0x43(ix)				; cur_quadrant

; klingon loop.	 Delay about 256 ms before considering
; the next action of the klingons

klingon_loop:
		ld	b, #0x80 ; '€'

loc_49B6:
		call	periodic
		dec	b
		jr	NZ, loc_49B6
; This condition here is, essentially, to decide if a starbase
; should be attacked.  This is possible	if no base is under attack
; (ttl at (4065) is zero) or if	one of the low 4 bits of the time
; is set. That implies every 8 seconds a large series of attempts.
		ld	a, 0x46(ix)
		and	#0xF
		or	0x65(ix)
		jr	NZ, consider_phasers
; Attack starbase.  Choose a random quadrant HL.  If it	happens
; to be	the current quadrant or	does not contain a starbase,
; skip the attempted attack. Otherwise,	store qpos of the starbase
; at (ix+64h)
		push	de
; Cute;	ld a,d is 'ld a,40h' because DE is in the zero page
		ld	a, d
		call	rand
		dec	a
		ld	l, a
		cp	e
		jr	Z, consider_phasers_1
		ld	h, d
		ld	a, (hl)
		bit	0, a
		jr	Z, consider_phasers_1
		ld	0x64(ix), l				; sos_starbase_qpos

; Look for a klingon not in the	current	quadrant and warp him
; to the sos starbase.	Initialize the time to live counter
; to between 10	to 45.

find_attacker:
		ld	a, d
		call	rand
		dec	a
		cp	e
		jr	Z, find_attacker
		ld	e, a
		call	try_warp_DE_HL
		ld	a, (hl)
		and	#6
		jr	Z, find_attacker
		ld	a, #0x23 ; '#'
		call	rand
		add	a, #0x14
		ld	0x65(ix), a

consider_phasers_1:
		pop	de

; Consider a phaser attack if there are	klingons in the
; current quadrant.  If	there is only one klingon in the
; quadrant there is a 1/40 chance it will run away.

consider_phasers:
		ld	a, (de)
		and	#6
		jr	Z, klingon_loop
		sub	#2
		ld	a, #0x28 ; '('
		call	Z, rand
		dec	a
		jr	NZ, target_federation
; At this point	the klingon wants to leave the quadrant
		ld	a, (video+0xC0)
		rla
		jr	NC, leave_quadrant
; The SRS is up	so the klingon must navigate to	leave the quadrant.
		push	de
		ld	h, d
		ld	l, #0x55 ; 'U'

; Move klingon at (HL) by adding/subtracting 30, 31, 32

keep_moving:
		ld	a, #3
		call	rand
		add	a, #0x1E
		ld	e, a
		ld	a, 0x4E(ix)				; pos_enterprise
		sub	(hl)
		ld	a, (hl)
		jr	C, loc_4A20
		sub	e
		jr	loc_4A21
; ---------------------------------------------------------------------------

loc_4A20:
		add	a, e

loc_4A21:
		jr	C, klingon_escaped
		ld	e, a
		call	try_move_klingon
		jr	keep_moving
; ---------------------------------------------------------------------------

klingon_escaped:
		ld	d, (hl)
		ld	e, (hl)
		call	ship_d2e
		pop	de

leave_quadrant:
		ld	a, d
		call	rand
		ld	l, a
		call	try_warp_DE_HL
		jr	Z, leave_quadrant
		jp	klingon_loop
; ---------------------------------------------------------------------------

; Attempt to fire upon the big E then the starbase if any

target_federation:						; pos_enterprise
		ld	b, 0x4E(ix)
		call	attack_on_B
		ld	a, (de)
		and	#1
		jp	Z, klingon_loop
		ld	b, 0x4F(ix)				; pos_starbase
		call	attack_on_B
		ld	a, #0xC
		call	rand
		dec	a
		jr	NZ, to_klingon_loop
; This is where	we try to warp another klingon to the current quadrant
; 1 in 12 chance of getting here
; Another tricky ld a,40h
		ld	a, d
		call	rand
		dec	a
		cp	e
		jr	Z, to_klingon_loop
; A is a random	quadrant different from	the current
		ld	h, d
		ld	l, a
		ex	de, hl
		call	try_warp_DE_HL
		ex	de, hl
		jr	Z, to_klingon_loop
		ld	a, (de)
		and	#6
		rrca
		add	a, #0x54 ; 'T'
		ld	l, a
		push	de

find_warpin_space:
		ld	a, #0x41 ; 'A'
		call	rand
		add	a, #0xDE ; 'Þ'
		ld	e, a
		ld	d, #0x8C ; 'Œ'
		push	hl
		call	ship_d2e
		pop	hl
		jr	NZ, find_warpin_space
		ld	(hl), e
		pop	de
		call	draw_srs

to_klingon_loop:
		jp	klingon_loop

; =============== S U B	R O U T	I N E =======================================

; Try to move the klingon to at	current	pos (HL) to E.
; It looks like	a klingon can die if it	accidentally runs
; into a black hole! (4058 is black hole position)
; ship_d2e must	conditionally set E to the next	or prev	position.

try_move_klingon:
		ld	d, (hl)
		push	hl
		call	ship_d2e
		ld	a, l
		jr	Z, move_klingon
		ld	e, d
		cp	#0x58 ;	'X'
		jr	NZ, move_klingon
		ld	sp, #stack2
		jp	dec_klingon
; ---------------------------------------------------------------------------

; Move klingon at (HL) qpos to BC screen location
; E is the destination qpos and	(HL) is	updated
; There	is also	a 60-period (~120 ms) delay after the move

move_klingon:							; "<*>"
		ld	hl, #klingon
		call	str_hl_at_bc
		pop	hl
		ld	(hl), e
		ld	b, #0x3C ; '<'

loc_4AA5:
		call	periodic
		dec	b
		jr	NZ, loc_4AA5
		ret
; End of function try_move_klingon


; =============== S U B	R O U T	I N E =======================================

; If possible, warp a klingon from quad	(DE) to	(HL)
; On return, nz	means did warp,	z means	did not

try_warp_DE_HL:
		ld	a, (hl)
		and	#6
		cp	#6
		ret	Z
		ld	a, (de)
		and	#6
		ret	Z
		ld	a, (de)
		dec	a
		dec	a
		ld	(de), a
		inc	(hl)
		inc	(hl)
		ret
; End of function try_warp_DE_HL


; =============== S U B	R O U T	I N E =======================================

; Get a	klingon	to attack on location B
; First	compute	(10-level)/2 and put random value in C
; If random > klingons,	return.	 So klingons more aggressive
; at higher levels.
; The rhythm here is: take a shot.  If you're 'close', take
; another shot and return. Otherwise move closer.  If you
; can't move anymore, take another shot and return
; Otherwise go to the top of the loop

attack_on_B:
		ld	a, #0x10
		sub	0x42(ix)				; level
		rra
		call	rand
		ld	c, a
		ld	a, (de)
		and	#6
		rrca
		cp	c
		ret	C
; Get HL pointing to chosen klingon.
		ld	a, c
		add	a, #0x54 ; 'T'
		ld	l, a
		ld	h, d
		push	bc

fire_and_move:
		ld	a, (hl)
		pop	bc
		push	bc
		push	hl
		call	coord_to_xy
		ex	de, hl
		ld	a, b
		call	coord_to_xy
; DE is	X,Y of klingon,	HL is X,Y of target
		ld	a, e
		sub	l
		rlca
		ld	c, a
		ld	a, d
		sub	h
		ld	b, a
		pop	hl
; Now BC is a vector in	the target direction
		ld	a, (video+0xC0)
		rla
; This shot happens only if we're not on SRS.  Stay on SRS!
		jr	NC, find_and_take_shot
; This chunk computes D	= ABS(B) + ABS(C), a simple distance.
		ld	a, b
		bit	7, b
		jr	Z, loc_4AF3
		cpl

loc_4AF3:
		ld	d, a
		ld	a, c
		bit	7, c
		jr	Z, loc_4AFA
		cpl

loc_4AFA:
		add	a, d
		ld	d, a
		ld	a, #0x36 ; '6'
		call	rand
		add	a, #0xA
; if D < rand(11..64) take a shot
; in essense, shoot again if we're close enough and return
		cp	d
		jr	NC, find_and_take_shot
		push	bc
		ld	a, (hl)
; Now look at moving closer to the target
; Based	on looking at B/2 then C/2 create a new	position in A
		rlc	b
		jr	Z, loc_4B14
		jr	C, loc_4B12
		inc	a
		inc	a
		jr	loc_4B14
; ---------------------------------------------------------------------------

loc_4B12:
		dec	a
		dec	a

loc_4B14:
		rlc	c
		jr	Z, loc_4B20
		jr	C, loc_4B1E
		add	a, #0x20 ; ' '
		jr	loc_4B20
; ---------------------------------------------------------------------------

loc_4B1E:
		sub	#0x20 ;	' '

loc_4B20:
		ld	e, a
; E is the new position, try to	move there.
; If we	do move, go and	try again
; Otherwise, we	fall through to	take a shot which will be the
; return of attack_on_B.
		call	try_move_klingon
		pop	bc
		ld	a, d
		cp	e
		jr	NZ, fire_and_move

; By using tracer shots, see if	klingon	at (HL)	can hit	a fed target
; by shooting the the direction	of BC.
; The tracer is	a success if it	hits either a starbase or
; or the big e.	 The cp	50h is a location-based	check on this
; If the tracer	works a	real shot is fired.  Klingon phasers
; use the Enterprise's phaser %age; so low shields pose a risk
; to your starbases.

find_and_take_shot:
		ld	a, (hl)
		pop	de
		push	af
; Change this to ld h,01 or ld h,0 to get visible tracer shots
		ld	h, #0xFF
		push	bc
		call	draw_shot
		pop	bc
		ld	a, l
		pop	hl
		ret	NC
		cp	#0x50 ;	'P'
		ret	NC
		push	hl
		call	phaser_pct
		pop	af
		call	draw_shot
		ret	NC
		jp	ship_hit
; End of function attack_on_B

; ---------------------------------------------------------------------------
		.db    0
; ---------------------------------------------------------------------------

; A lot	gets done here.	 Looks like we context switch to another thread
; if the time is right.	 Otherwise we generally	update the display with
; things that change like stardates, energy to shield warnings,	quadrant,
; starbase destroyed and so on.
; 4045,46 seems	to track the time.
; Most of the time we simply delay 4ms and context switch.
; But once a second we do the processing here.
; Gotta	crunch the numbers, but	it works out to	95 seconds per stardate.
; I can	almost bet that	it'll really be 100 or 60 seconds per stardate.
; PNP: I read the timer	as 2 milliseconds so a stardate	is 48 seconds
; 4045 - counts	2 milliseconds (aprox)
; 4046 - counts	512 milliseconds (about	half second)
; 4044 - counts	stardates (95 *	512 ms = 48 seconds).
; (45,46) only count from 0 to $5eff

periodic:
		ex	af, af'
		exx
		ld	(loc_4B4E+2), sp
		ld	sp, iy

loc_4B4E:
		ld	iy, #0
		ld	a, #0xFF

; PNP: dec a = 4 tstates, jr nz	= 12 tstates if	taken
; so loop takes	16*256=4080 tstates or about 2ms at 2 MHz
; or 2.3 ms at 1.77 MHz

unit_delay:
		dec	a
		jr	NZ, unit_delay
		inc	0x45(ix)
		ret	NZ
		ld	a, 0x46(ix)
		inc	a
		cp	#0x5F ;	'_'
		jr	NZ, loc_4B67
		xor	a
		inc	0x44(ix)				; stardate

loc_4B67:
		ld	0x46(ix), a
		push	hl
		push	bc
		push	de
		and	#3
		ld	e, 0x43(ix)				; cur_quadrant
		ld	d, #0x40 ; '@'
		jr	NZ, loc_4B7D
		ld	a, (video+0xC0)
		or	a
		call	M, draw_stats

loc_4B7D:
		ld	bc, # video+0x384
		ld	a, (bc)
		cp	#0x45 ;	'E'
		call	Z, clreol
		jr	Z, loc_4B99
		ld	a, (shields)
		or	a
		jr	NZ, loc_4B99
		ld	hl, # aEnergyToShields+2
		call	str_hl_at_bc
		dec	bc
		dec	bc
		ld	a, #0x21 ; '!'
		ld	(bc), a

loc_4B99:
		call	repair
; Point	BC at 4	chars past middle of second from bottom	line.
; Now check for	a starbase SOS reports.	 This can disable the
; message, decrement the TTL and even destroy the starbase
		ld	c, #0xA4 ; '¤'
		ld	hl, (sos_starbase_qpos)
		ld	a, e
		ld	e, l
		sub	l
		jr	Z, cancel_sos
		ld	a, (de)
		and	#1
		jr	Z, cancel_sos
		ld	a, (de)
		and	#6
		jr	NZ, continue_alert

; A is zero here

cancel_sos:
		ld	(sos_starbase_ttl), a
		ld	h, a

; H is either zero (no alert) or contents of sos_starbase_ttl

continue_alert:
		ld	a, h
		or	a
		jr	Z, check_docked
; decrement starbase ttl counter
		dec	0x65(ix)
		jr	NZ, display_starbase_sos
		ld	hl, # aTheLastStarbaseHasBeenDestroyed+9
		call	str_hl_at_bc
		call	destroy_base_at_DE
		jr	check_docked
; ---------------------------------------------------------------------------

display_starbase_sos:
		ld	a, (bc)
		cp	#0x20 ;	' '
; Check	for space to alternate flashing	SOS display
		jr	NZ, loc_4BE2
		ld	hl, #aSosStarbase			; "SOS-STARBASE"
		call	str_hl_at_bc
		ld	a, e
		and	#7
		call	print_a
		ld	a, e
		and	#0x38 ;	'8'
		rrca
		rrca
		rrca
		call	print_a

loc_4BE2:
		call	clreol

; Check	if enterprise is currently docked--if so, display message

check_docked:
		ld	bc, # video+0x40
		ld	e, 0x43(ix)				; cur_quadrant
		ld	a, (de)
		and	#1
		jr	Z, loc_4C13
		ld	hl, (pos_enterprise)
		ld	a, h
		sub	l
		jr	C, loc_4BFB
		cp	#0x20 ;	' '
		jr	Z, loc_4C03

loc_4BFB:
		ld	a, l
		sub	h
		jr	C, loc_4C13
		cp	#0x20 ;	' '
		jr	NZ, loc_4C13

loc_4C03:
		ld	a, (bc)
		cp	#0x45 ;	'E'
		ld	hl, #aEnterpriseDocked			; "ENTERPRISE DOCKED"
		call	NZ, str_hl_at_bc
		call	repair
; load up docked enterprise with 3 photon torps
		ld	0x60(ix), #3				; photons

; finish_periodic

loc_4C13:
		pop	de
		pop	bc
		pop	hl
		ret
; ---------------------------------------------------------------------------
aEnterpriseDocked:.ascii 'ENTERPRISE DOCKED'
		.db 0
aSosStarbase:	.ascii 'SOS-STARBASE'
		.db 0

; =============== S U B	R O U T	I N E =======================================

; Repair damage.  Seems	rather random; but I'd guess that if bit 7 of C
; is set, it means we're docked and guarantee 4 times faster repair and
; ship's energy replenishment.  Thing is, C appears to result from message
; display by the caller!

repair:
		ld	hl, #imp_damage

loc_4C39:
		ld	a, #0x8B ; '‹'
		call	rand
		ld	a, (hl)
		jp	P, loc_4C46
		sub	#1
		jr	C, loc_4C4E

loc_4C46:
		bit	7, c
		jr	NZ, loc_4C4F
		sub	#4
		jr	NC, loc_4C4F

loc_4C4E:
		xor	a

loc_4C4F:
		ld	(hl), a
		inc	hl
		ld	a, l
		cp	#0x5E ;	'^'
		jr	NZ, loc_4C39
		ld	a, #0x8B ; '‹'
		call	rand
		jp	P, loc_4C5F
		inc	(hl)

loc_4C5F:
		bit	7, c
		jr	NZ, loc_4C67
		ld	a, (hl)
		add	a, #4
		ld	(hl), a

loc_4C67:
		ld	a, (hl)
		cp	#0x65 ;	'e'
		jr	C, loc_4C6E
		ld	a, #0x64 ; 'd'

loc_4C6E:
		ld	(hl), a
		ret
; End of function repair


; =============== S U B	R O U T	I N E =======================================

; HL points to the screen.  We map to a	position and check for collision
; with an object in the	quadrant.  Then	we figure out what, if anything,
; we hit and then return XXXX.....
; (The 3CC0 base of short range	scan goes to 1E60, hence the 60!)

doesHLhit:
		push	hl
		srl	h
		rr	l
		ld	a, l
		sub	#0x60 ;	'`'
		ld	e, a
		call	ship_fits
		ld	a, (hl)
		pop	de
		jr	Z, loc_4C9F
		call	pos2scrn
		ld	a, l
		cp	#0x50 ;	'P'
		jr	C, loc_4C95
		cp	#0x55 ;	'U'
		jr	C, loc_4C90
		cp	#0x58 ;	'X'
		jr	NZ, loc_4C95

loc_4C90:
		ld	a, e
		sub	c
		ret	Z
		jr	loc_4C9F
; ---------------------------------------------------------------------------

loc_4C95:
		ld	a, e
		sub	c
		ret	C
		cp	#3
		jr	NC, loc_4C9F
		xor	a
		scf
		ret
; ---------------------------------------------------------------------------

loc_4C9F:
		or	a
		ret
; End of function doesHLhit


; =============== S U B	R O U T	I N E =======================================

;
; Returns nc if	x,y outside of SRS, c otherwise

check_xy_in_srs:
		inc	b
		jp	M, loc_4CB0
		dec	b
		jr	Z, loc_4CB0
		ld	a, c
		cp	#9
		jr	C, loc_4CB0
		cp	#0x21 ;	'!'
		ret	C

loc_4CB0:
		xor	a
		ret
; End of function check_xy_in_srs


; =============== S U B	R O U T	I N E =======================================

; Takes	coordinate in A	and returns (pixel) coordinate X,Y in DE
; A = Ay | Ax (Ay is three bits, Ax is 5 bits)
; D = 4	* Ax + 2
; E = 3*Ay + 10
; The resulting	position is the	bottom left of the cell

coord_to_xy:
		ld	e, a
		and	#0x1F
		rlca
		inc	a
		rlca
		ld	d, a
		ld	a, e
		and	#0xE0 ;	'à'
		rlca
		rlca
		rlca
		ld	e, a
		rlca
		add	a, e
		add	a, #0xA
		ld	e, a
		ret
; End of function coord_to_xy


; =============== S U B	R O U T	I N E =======================================

; Like ship_fits, but E	is checked for position	validity (and if not, return
; as a collision with with L = 0).  Otherwise, clear screen position D and
; check	for collision at E as in ship_fits.

ship_d2e:
		ld	a, e
		ld	l, #0
		and	#0x1F
		jr	Z, s_overlap
		cp	#0x1F
		jr	Z, s_overlap
		ld	a, d
		call	pos2scrn
		ld	a, #0x80 ; '€'
		ld	(bc), a
		inc	bc
		ld	(bc), a
		inc	bc
		ld	(bc), a
; End of function ship_d2e


; =============== S U B	R O U T	I N E =======================================

; Check	quadrant to see	if a ship at position E	would collide with anything.
; Ships	at position D are ruled	out.  If there is a collision, Z is clear,
; BC is	screen location	of position D and $4000	+ L is what we hit.
; Otherwise, Z is set and BC is	the screen location of E.

ship_fits:
		ld	hl, # klingon_damages+2
		call	shpOVship
		jr	Z, s_overlap
		ld	b, h
		ld	c, 0x43(ix)				; cur_quadrant
		ld	a, (bc)
		and	#1
		jr	Z, loc_4CF2
		call	shpOVship
		jr	Z, s_overlap

loc_4CF2:
		ld	a, (bc)
		ld	l, #0x4F ; 'O'
		and	#0x18
		rrca
		rrca
		rrca
		inc	a
		inc	a
		ld	b, a

loc_4CFD:
		call	shpOVstar
		jr	Z, s_overlap
		dec	b
		jr	NZ, loc_4CFD
		ld	b, h
		ld	a, (bc)
		ld	l, #0x54 ; 'T'
		and	#6
		rrca
		ld	b, a
		jr	Z, loc_4D17

loc_4D0F:
		call	shpOVship
		jr	Z, s_overlap
		dec	b
		jr	NZ, loc_4D0F

loc_4D17:
		ld	b, h
		ld	l, #0x57 ; 'W'
		ld	a, (bc)
		and	#0x20 ;	' '
		jr	Z, loc_4D24
		call	shpOVstar
		jr	Z, s_overlap

loc_4D24:
		ld	a, e
		call	pos2scrn
		xor	a
		ret
; ---------------------------------------------------------------------------

s_overlap:
		ld	a, d
		call	pos2scrn
		inc	a
		ret
; End of function ship_fits


; =============== S U B	R O U T	I N E =======================================

; Return z flag	set if pos (hl+1) is ==	E or E + 1
; Essentially, does the	ship at	(hl+1) hit the star at E.

shpOVstar:
		inc	hl
		ld	a, (hl)
		cp	e
		ret	Z
		dec	a
		cp	e
		ret
; End of function shpOVstar


; =============== S U B	R O U T	I N E =======================================

; Return z flag	set if pos (hl+1) is ==	E - 1, E or E +	1 but not D
; In other words, does the ship	(hl+1) overlap with the	ship at	E.
; But D	is ruled out, perhaps to not compare the ship with itself?

shpOVship:
		inc	hl
		ld	a, (hl)
		cp	d
		jr	Z, loc_4D45
		cp	e
		ret	Z
		inc	a
		cp	e
		ret	Z
		sub	#2
		cp	e
		ret
; ---------------------------------------------------------------------------

loc_4D45:
		or	a
		ret
; End of function shpOVship

; ---------------------------------------------------------------------------
aStardate:	.ascii 'STARDATE'
		.db 0
aQuadrant:	.ascii 'QUADRANT'
		.db 0
aShieldEnergy:	.ascii 'SHIELD ENERGY'
		.db 0
aShipsEnergy:	.ascii 'SHIPS ENERGY'
		.db 0
aPhotonTorps:	.ascii 'PHOTON TORPS'
		.db 0
aCondition:	.ascii 'CONDITION '
		.db 0
aGreen:		.ascii 'GREEN '
		.db 0
aYellow:	.ascii 'YELLOW'
		.db 0
aRed:		.ascii 'RED!'
		.db 0

; =============== S U B	R O U T	I N E =======================================


draw_stats:
		ld	bc, # video+0x300
		ld	hl, #aStardate				; "STARDATE"
		call	str_hl_at_bc
		ld	a, 0x44(ix)				; stardate
		call	print_a
; Show current quadrant
		ld	c, #0x18
		call	str_hl_at_bc
		ld	a, e
		and	#7
		call	print_a
		ld	a, e
		rrca
		rrca
		rrca
		and	#7
		call	print_a
; Show shield energy
		ld	c, #0x2D ; '-'
		call	str_hl_at_bc
		ld	a, 0x5F(ix)				; shields
		call	print_a
		ld	a, #0x25 ; '%'
		ld	(bc), a
		inc	bc
		call	clreol
; Show ship energy
		call	str_hl_at_bc
		ld	a, 0x5E(ix)				; ship_nrg
		call	print_a
		ld	a, #0x25 ; '%'
		ld	(bc), a
		ld	a, #0x20 ; ' '
		inc	bc
		ld	(bc), a
; Show photon torpedos
		ld	c, #0x58 ; 'X'
		call	str_hl_at_bc
		ld	a, 0x60(ix)				; photons
		call	print_a
; Show condition (alert) status.
;   Red	if any klingons	in the quadrant
;   Yellow if ship's energy is <= 40%
;   Green, otherwise.
		ld	c, #0x6D ; 'm'
		call	str_hl_at_bc
		ld	hl, #aGreen				; "GREEN "
		ld	a, 0x5E(ix)				; ship_nrg
		cp	#0x29 ;	')'
		jr	NC, loc_4E01
		ld	hl, #aYellow				; "YELLOW"

loc_4E01:
		ld	a, (de)
		and	#6
		jr	Z, loc_4E09
		ld	hl, #aRed				; "RED!"

loc_4E09:
		jp	str_hl_at_bc
; End of function draw_stats


; =============== S U B	R O U T	I N E =======================================

; Clear	from BC	to end of display line with spaces.
; BC ends up pointing to last char on line; A munged.

clreol:
		ld	a, #0x20 ; ' '
		ld	(bc), a
		inc	bc
		ld	a, c
		and	#0x3F ;	'?'                             ; end of line?
		jr	NZ, clreol				; no, loop
		ret
; End of function clreol


; =============== S U B	R O U T	I N E =======================================

; Input	integer	to HL, display on screen at BC.	Preserves DE

getint_HL:
		push	de
		push	bc
		call	clreol
		pop	bc
		push	bc

loc_4E1D:
		call	getchar
		jr	NZ, loc_4E1D				; loop until <ENTER>
		pop	bc
		sbc	hl, hl					; bug? C is undetermined?

; Read (BC) as ASCII int into HL.  Note	how 'A' could mean 17.

atoibchl:							; get digit
		ld	a, (bc)
		sub	#0x30 ;	'0'                             ; convert ascii to decimal
		jr	NC, loc_4E2C				; valid	digit, continue
		pop	de
		ret
; ---------------------------------------------------------------------------

; HL = HL * 10 + A.

loc_4E2C:							; =HL*2
		add	hl, hl
		push	hl
		add	hl, hl					; =HL*4
		add	hl, hl					; =HL*8
		pop	de					; DE=HL*2
		add	hl, de					; =HL*10
		ld	d, #0
		ld	e, a					; digit
		add	hl, de					; add digit
		inc	bc					; next buffer location
		jr	atoibchl
; End of function getint_HL


; =============== S U B	R O U T	I N E =======================================

; Read a character from	keyboard, display at BC.  Return Z if 'enter'.
; Seems	like it	actually moves and displays the	enterprise as needed.
; Possibly only	gets numbers.

getchar:

; FUNCTION CHUNK AT 4389 SIZE 00000015 BYTES
; FUNCTION CHUNK AT 43D7 SIZE 0000002D BYTES

		push	hl
		push	de
		ld	d, #0xFF

loc_4E3D:
		call	periodic
		ld	a, 0x45(ix)
		and	#0x3F ;	'?'
		ld	a, (0x3840)				; keyboard (arrow key line)
		ld	l, a
		jp	NZ, loc_4F06
		and	#0x78 ;	'x'                             ; mask off <SPACE>
		jr	Z, loc_4E54
		ld	a, (video+0xC0)
		or	a

loc_4E54:
		jp	P, loc_4F06
		push	de
		push	hl
		push	bc
		ld	a, 0x59(ix)				; imp_damage
		cp	#100
		jr	C, loc_4EA3
		ld	hl, #aImpulseEngines			; "IMPULSE ENGINES"
		ld	bc, # video+0x40
		call	str_hl_at_bc
		ld	hl, #aInoperable			; " INOPERABLE"
		call	str_hl_at_bc
		call	clreol
		jp	loc_4F03
; ---------------------------------------------------------------------------
aSwollowedByABlackHole:.ascii 'SWOLLOWED BY A BLACK HOLE!'
		.db 0
aBurntToACrisp:	.ascii 'BURNT TO A CRISP!'
		.db 0
; ---------------------------------------------------------------------------

loc_4EA3:							; pos_enterprise
		ld	e, 0x4E(ix)
		ld	d, e
		bit	6, l
		jr	Z, loc_4EAC
		inc	e

loc_4EAC:
		bit	5, l
		jr	Z, loc_4EB1
		dec	e

loc_4EB1:
		bit	4, l
		jr	Z, loc_4EBB
		ld	a, e
		add	a, #0x20 ; ' '
		jr	C, loc_4EBB
		ld	e, a

loc_4EBB:
		bit	3, l
		jr	Z, loc_4EC5
		ld	a, e
		sub	#0x20 ;	' '
		jr	C, loc_4EC5
		ld	e, a

loc_4EC5:
		call	ship_d2e
		jr	Z, loc_4EFA
		ld	a, l
		cp	#0x58 ;	'X'
		jr	NZ, loc_4ED5
		ld	hl, #aSwollowedByABlackHole		; "SWOLLOWED BY	A BLACK	HOLE!"
		jp	ent_dead
; ---------------------------------------------------------------------------

loc_4ED5:
		cp	#0x55 ;	'U'
		jr	NC, loc_4EFD
		cp	#0x50 ;	'P'
		jr	C, loc_4EFD
		ld	a, (hl)
		call	pos2scrn
		ld	a, #0x2A ; '*'
		ld	(bc), a

loc_4EE4:
		ld	a, #0xB
		call	rand
		out	(0xFF),	a
		xor	a

loc_4EEC:
		dec	a
		jr	NZ, loc_4EEC
		dec	d
		jr	NZ, loc_4EE4
		ld	hl, #aBurntToACrisp			; "BURNT TO A CRISP!"
		out	(0xFF),	a
		jp	ent_dead
; ---------------------------------------------------------------------------

loc_4EFA:							; pos_enterprise
		ld	0x4E(ix), e

loc_4EFD:							; "\"V\""
		ld	hl, #aV
		call	str_hl_at_bc

loc_4F03:
		pop	bc
		pop	hl
		pop	de

loc_4F06:
		ld	a, l
		or	d
		xor	d
		ld	d, l
		dec	a
		jr	Z, loc_4F4A
		dec	a
		jr	NZ, loc_4F1E
		dec	bc
		ld	a, (bc)
		cp	#0x20 ;	' '
		inc	bc
		jp	Z, loc_4E3D
		dec	bc
		ld	a, #0x20 ; ' '
		ld	(bc), a
		jr	loc_4F4A
; ---------------------------------------------------------------------------

loc_4F1E:
		ld	hl, (word_4F4D)
		ld	a, (0x3810)				; read keyboard
		ld	(word_4F4D), a
		or	l
		xor	l
		ld	e, #0

loc_4F2B:
		rrc	a
		jr	C, loc_4F45
		inc	de
		jr	NZ, loc_4F2B
		ld	e, #8
		ld	a, (0x3820)				; read keyboard
		ld	(word_4F4D+1), a
		or	h
		xor	h
		and	#3
		jp	Z, loc_4E3D
		rrca
		jr	C, loc_4F45
		inc	e

loc_4F45:
		ld	a, e
		add	a, #0x30 ; '0'
		ld	(bc), a
		inc	bc

loc_4F4A:
		pop	de
		pop	hl
		ret
; End of function getchar

; ---------------------------------------------------------------------------
word_4F4D:	.dw 0

; =============== S U B	R O U T	I N E =======================================


str_hl_at_bc:
		ld	a, (hl)
		inc	hl
		or	a
		ret	Z
		ld	(bc), a
		inc	bc
		jr	str_hl_at_bc
; End of function str_hl_at_bc


; =============== S U B	R O U T	I N E =======================================

;
; ; Display A in decimal at (BC)

print_a:
		push	de
		push	hl
		inc	bc
		ld	e, #0x30 ; '0'
		ld	l, a
		ld	h, #100
		call	LdivH
		or	a
		jr	Z, loc_4F68
		add	a, e
		ld	(bc), a
		inc	bc

loc_4F68:
		ld	d, l
		ld	l, h
		ld	h, #10
		call	LdivH
		or	a
		jr	NZ, loc_4F76
		add	a, d
		jr	Z, loc_4F79
		xor	a

loc_4F76:
		add	a, e
		ld	(bc), a
		inc	bc

loc_4F79:
		ld	a, h
		add	a, e
		ld	(bc), a
		inc	bc
		pop	hl
		pop	de
		ret
; End of function print_a


; =============== S U B	R O U T	I N E =======================================

;
; ; BC = 3CC0h + A * 2;	Basicially translates a	coordinate to the screen position.

pos2scrn:
		push	hl
		ld	bc, # video+0xC0
		ld	h, #0
		ld	l, a
		add	hl, hl
		add	hl, bc
		ld	b, h
		ld	c, l
		pop	hl
		ret
; End of function pos2scrn


; =============== S U B	R O U T	I N E =======================================


cls:
		ld	bc, #video				; start	of screen

clc:								; space
		ld	a, #0x20 ; ' '
		ld	(bc), a					; set character
		inc	bc					; next location
		ld	a, b
		cp	#0x40 ;	'@'                             ; end of screen?
		jr	NZ, clc					; no, loop
		ret
; End of function cls


; =============== S U B	R O U T	I N E =======================================

;
; Get pseudo-random number from	1 to A.	 Uses seed * 257 + 101 which
; does have a period of	65536.	That is, will generate all values.  Decent.

rand:
		push	hl
		push	bc
		ld	hl, (rand_seed)
		ld	b, l
		ld	c, #0x65 ; 'e'
		add	hl, bc
		ld	(rand_seed), hl
		ld	l, a
		call	HxL
		ld	a, h
		inc	a
		pop	bc
		pop	hl
		ret
; End of function rand


; =============== S U B	R O U T	I N E =======================================

; Take X,Y from	B,C.  Computes bit to set in char in A and HL
; pointing to the screen location to mask.  I haven't absolutely
; verified this, but it	must be	close.

xy2scrnbit:
		push	bc
		ld	l, c
		ld	h, #3
		call	LdivH
		ld	l, b
		sla	l
		rra
		rr	l
		rra
		rr	l
		rl	h
		ld	c, h
		add	a, #0x3C ; '<'
		ld	h, a
		ld	a, #0x80 ; '€'
		inc	c

loc_4FC8:
		rlca
		dec	c
		jr	NZ, loc_4FC8
		pop	bc
		ret
; End of function xy2scrnbit


; =============== S U B	R O U T	I N E =======================================

; compliment pixel (B,C).  Note	how it wipes out a non-graphics	character but
; otherwise flips the state of the pixel.

flipBC:
		call	xy2scrnbit
		bit	7, (hl)
		jr	Z, loc_4FD6
		xor	(hl)

loc_4FD6:
		set	7, a
		ld	(hl), a
		ret
; End of function flipBC


; =============== S U B	R O U T	I N E =======================================

; A = L	= L / H; H = L % H
; If H == 0 returns A =	L = 255, H = L

LdivH:
		push	bc
		ld	b, h
		xor	a
		ld	h, a

loc_4FDE:
		ld	c, a
		ld	a, #8

loc_4FE1:
		add	hl, hl
		sbc	hl, bc
		inc	hl
		jr	NC, loc_4FE9
		add	hl, bc
		dec	hl

loc_4FE9:
		dec	a
		jr	NZ, loc_4FE1
		pop	bc
		ld	a, l
		ret
; End of function LdivH

; ---------------------------------------------------------------------------

; Compute A = H	* L (and also HL = H * L).

HxL:
		push	bc
		ld	c, l
		xor	a
		ld	b, a
		ld	l, a
		ld	a, #8

loc_4FF6:
		add	hl, hl
		jr	NC, loc_4FFA
		add	hl, bc

loc_4FFA:
		dec	a
		jr	NZ, loc_4FF6
		ld	a, l
		pop	bc
		ret
; end of 'RAM'

; end of file
