ca65 V2.13.9 - (C) Copyright 1998-2011 Ullrich von Bassewitz
Main file   : bb1r2.s
Current file: bb1r2.s

000000r 1               	.INCLUDE	"camac.inc"
000000r 2               .FEATURE	loose_string_term, labels_without_colons
000000r 2               
000000r 2               .MACRO	TITLE	arg
000000r 2               .ENDMACRO
000000r 2               .MACRO	SUBTTL	arg
000000r 2               .ENDMACRO
000000r 2               .MACRO	LIST	arg1, arg2, arg3
000000r 2               .ENDMACRO
000000r 2               .MACRO	EJECT
000000r 2               .ENDMACRO
000000r 2               .define	EQU	=
000000r 2               .define	not	<~
000000r 2               .define	ASSERT(arg)	.ASSERT arg, error
000000r 2               .define	low	<
000000r 2               .define	LOW	<
000000r 2               .define high	>
000000r 2               .define	HIGH	>
000000r 2               .define	IF	.IF
000000r 2               .define	ELSE	.ELSE
000000r 2               .define	ENDIF	.ENDIF
000000r 2               .define	ORG	.ORG
000000r 2               .define LOC	.ORG
000000r 2               .define DW	.WORD
000000r 2               .define	DB	.BYTE
000000r 2               
000000r 1               	TITLE	'OS - Operating System'
000000r 1               	SUBTTL	' '
000000r 1               	LIST	-F,-M
000000r 1               
000000r 1               ;	SPACE	4,10
000000r 1               ;***	Copyright 1984 ATARI.  Unauthorized reproduction, adaptation,
000000r 1               ;*	distribution, performance or display of this computer program
000000r 1               ;*	or the associated audiovisual work is strictly prohibited.
000000r 1               ;	SPACE	4,10
000000r 1               ;***	OS - Operating System
000000r 1               ;*
000000r 1               ;*	NOTES
000000r 1               ;*		This represents an attempt to bring the OS :
000000r 1               ;*		into conformance with the Atari Internal So:
000000r 1               ;*		Standards as defined in the Software Develo:
000000r 1               ;*		Committee Report on Procedures And Standard:
000000r 1               ;*		(10/27/81).  Due to time constraints, the e:
000000r 1               ;*		source could not be brought up to the stand:
000000r 1               ;*		particularly in the area of subroutine head:
000000r 1               ;*		documentation (ENTRY, EXIT, CHANGES and CAL:
000000r 1               ;*		More complete and consistent conformance to:
000000r 1               ;*		standard is planned for the next revision o:
000000r 1               ;*		Operating System (Revision 3).
000000r 1               ;*
000000r 1               ;*	MODS
000000r 1               ;*		Revision A (400/800)
000000r 1               ;*		D. Crane/A. Miller/L. Kaplan/R. Whitehead
000000r 1               ;*
000000r 1               ;*		Revision B (400/800)
000000r 1               ;*		Fix several problems.
000000r 1               ;*		M. Mahar/R. S. Scheiman
000000r 1               ;*
000000r 1               ;*		Revision 10 (1200XL)
000000r 1               ;*		Support 1200XL, add new features.
000000r 1               ;*		H. Stewart/L. Winner/R. S. Scheiman/
000000r 1               ;*		Y. M. Chen/M. W. Colburn	10/26/82
000000r 1               ;*
000000r 1               ;*		Revision 11 (1200XL)
000000r 1               ;*		Fix several problems.
000000r 1               ;*		R. S. Scheiman	12/23/82
000000r 1               ;*
000000r 1               ;*		Revision 1 (600XL/800XL)
000000r 1               ;*		Support PBI and on-board BASIC.
000000r 1               ;*		R. S. Scheiman/R. K. Nordin/Y. M. Chen	03/11/83
000000r 1               ;*
000000r 1               ;*		Revision 2 (600XL/800XL)
000000r 1               ;*		Fix several problems.
000000r 1               ;*		R. S. Scheiman	05/10/83
000000r 1               ;*		Bring closer to Coding Standard (object unchanged).
000000r 1               ;*		R. K. Nordin	11/01/83
000000r 1               
000000r 1               
000000r 1               ;	SPACE	4,10
000000r 1               ;**	Program Structure
000000r 1               ;*
000000r 1               ;*	The sections of the OS appear in the following order with
000000r 1               ;*	corresponding subtitles:
000000r 1               ;*
000000r 1               ;*	Equates and Definitions
000000r 1               ;*
000000r 1               ;*		System Symbol Equates
000000r 1               ;*		System Address Equates
000000r 1               ;*		Miscellaneous Address Equates
000000r 1               ;*		Macro Definitions
000000r 1               ;*
000000r 1               ;*	Code and Data
000000r 1               ;*
000000r 1               ;*		First 8K ROM Identification and Checksum
000000r 1               ;*
000000r 1               ;*		Interrupt Handler
000000r 1               ;*		Initialization
000000r 1               ;*		Disk Input/Ouput
000000r 1               ;*		Relocating Loader
000000r 1               ;*		Self-test, Part 1
000000r 1               ;*		Parallel Input/Output
000000r 1               ;*		Peripheral Handler Loading Facility, Part 1
000000r 1               ;*		Self-test, Part 2
000000r 1               ;*		Peripheral Handler Loading Facility, Part 2
000000r 1               ;*
000000r 1               ;*		International Character Set
000000r 1               ;*
000000r 1               ;*		Self-test, Part 3
000000r 1               ;*		Floating Point Package
000000r 1               ;*
000000r 1               ;*		Domestic Character Set
000000r 1               ;*
000000r 1               ;*		Device Handler Vector Tables
000000r 1               ;*		Jump Vectors
000000r 1               ;*		Generic Parallel Device Handler Vector Table
000000r 1               ;*
000000r 1               ;*		$E4C0 Patch
000000r 1               ;*		Central Input/Output
000000r 1               ;*		Peripheral Handler Loading Facility, Part 3
000000r 1               ;*		$E912 Patch
000000r 1               ;*		Peripheral Handler Loading Facility, Part 4
000000r 1               ;*		$E959 Patch
000000r 1               ;*		Serial Input/Output
000000r 1               ;*		Keyboard, Editor and Screen Handler, Part 1
000000r 1               ;*		Peripheral Handler Loading Facility, Part 5
000000r 1               ;*		$EF6B Patch
000000r 1               ;*		Keyboard, Editor and Screen Handler, Part 2
000000r 1               ;*		$F223 Patch
000000r 1               ;*		Keyboard, Editor and Screen Handler, Part 3
000000r 1               ;*		$FCD8 Patch
000000r 1               ;*		Cassette Handler
000000r 1               ;*		Printer Handler
000000r 1               ;*		Self-test, Part 4
000000r 1               ;*
000000r 1               ;*		Second 8K ROM Identification and Checksum
000000r 1               ;*		6502 Machine Vectors
000000r 1               ;	SUBTTL	'System Symbol Equates'
000000r 1               ;	SPACE	4,10
000000r 1               ;**	Assembly Option Equates
000000r 1               
000000r 1               
000000r 1               FALSE	EQU	0
000000r 1               TRUE	EQU	not FALSE
000000r 1               
000000r 1               .define	VGC	TRUE	;virtual game controllers
000000r 1               .define	RAMSYS	FALSE	;not RAM based system
000000r 1               .define	LNBUG	FALSE	;no LNBUG interface
000000r 1               .define	ACMI	FALSE	;no asynchronous communications mod:
000000r 1               ;	SPACE	4,10
000000r 1               ;**	Identification Equates
000000r 1               
000000r 1               
000000r 1               IDREV	EQU	$02	;identification revision number
000000r 1               IDDAY	EQU	$10	;identification day
000000r 1               IDMON	EQU	$05	;identification month
000000r 1               IDYEAR	EQU	$83	;identification year
000000r 1               IDCPU	EQU	$02	;identification CPU series
000000r 1               IDPN1	EQU	'B'	;identification part number field 1
000000r 1               IDPN2	EQU	'B'	;identification part number field 2
000000r 1               IDPN3	EQU	$00	;identification part number field 3
000000r 1               IDPN4	EQU	$00	;identification part number field 4
000000r 1               IDPN5	EQU	$01	;identification part number field 5
000000r 1               ;	SPACE	4,10
000000r 1               ;**	Configuration Equates
000000r 1               ;*
000000r 1               ;*	NOTES
000000r 1               ;*		Problem: last byte of HATABS (as defined by:
000000r 1               ;*		overlaps first power-up validation byte.
000000r 1               
000000r 1               
000000r 1               MAXDEV	EQU	33	;offset to last possible entry of HATABS
000000r 1               IOCBSZ	EQU	16	;length of IOCB
000000r 1               
000000r 1               SEIOCB	EQU	0*IOCBSZ	;screen editor IOCB index
000000r 1               MAXIOC	EQU	8*IOCBSZ	;first invalid IOCB index
000000r 1               
000000r 1               DSCTSZ	EQU	128	;disk sector size
000000r 1               
000000r 1               LEDGE	EQU	2	;left edge
000000r 1               REDGE	EQU	39	;right edge
000000r 1               
000000r 1               INIML	EQU	$0700	;initial MEMLO
000000r 1               
000000r 1               ICSORG	EQU	$CC00	;international character set origin
000000r 1               DCSORG	EQU	$E000	;domestic character set origin
000000r 1               ;	SPACE	4,10
000000r 1               ;**	IOCB Command Code Equates
000000r 1               
000000r 1               
000000r 1               OPEN	EQU	$03	;open
000000r 1               GETREC	EQU	$05	;get record
000000r 1               GETCHR	EQU	$07	;get character(s)
000000r 1               PUTREC	EQU	$09	;put record
000000r 1               PUTCHR	EQU	$0B	;put character(s)
000000r 1               CLOSE	EQU	$0C	;close
000000r 1               STATIS	EQU	$0D	;status
000000r 1               SPECIL	EQU	$0E	;special
000000r 1               ;	SPACE	4,10
000000r 1               ;**	Special Entry Command Equates
000000r 1               
000000r 1               
000000r 1               ;	Screen Commands
000000r 1               
000000r 1               DRAWLN	EQU	$11	;draw line
000000r 1               FILLIN	EQU	$12	;draw line with right fill
000000r 1               ;	SPACE	4,10
000000r 1               ;**	ICAX1 Auxiliary Byte 1 Equates
000000r 1               
000000r 1               
000000r 1               APPEND	EQU	$01	;open write append (D:) or screen read (E:)
000000r 1               DIRECT	EQU	$02	;open for directory access (D:)
000000r 1               OPNIN	EQU	$04	;open for input (all devices)
000000r 1               OPNOT	EQU	$08	;open for output (all devices)
000000r 1               MXDMOD	EQU	$10	;open for mixed mode (E:, S:)
000000r 1               INSCLR	EQU	$20	;open for input without clearing screen (E:, S:)
000000r 1               ;	SPACE	4,10
000000r 1               ;**	Device Code Equates
000000r 1               
000000r 1               
000000r 1               CASSET	EQU	'C'	;cassette
000000r 1               DISK	EQU	'D'	;disk
000000r 1               SCREDT	EQU	'E'	;screen editor
000000r 1               KBD	EQU	'K'	;keyboard
000000r 1               PRINTR	EQU	'P'	;printer
000000r 1               DISPLY	EQU	'S'	;screen display
000000r 1               ;	SPACE	4,10
000000r 1               ;**	Character and Key Code Equates
000000r 1               
000000r 1               
000000r 1               CLS	EQU	$7D	;clear screen
000000r 1               EOL	EQU	$9B	;end of line (RETURN)
000000r 1               
000000r 1               HELP	EQU	$11	;key code for HELP
000000r 1               CNTLF1	EQU	$83	;key code for CTRL-F1
000000r 1               CNTLF2	EQU	$84	;key code for CTRL-F2
000000r 1               CNTLF3	EQU	$93	;key code for CTRL-F3
000000r 1               CNTLF4	EQU	$94	;key code for CTRL-F4
000000r 1               CNTL1	EQU	$9F	;key code for CTRL-1
000000r 1               ;	SPACE	4,10
000000r 1               ;**	Status Code Equates
000000r 1               
000000r 1               
000000r 1               SUCCES	EQU	1	;successful operation
000000r 1               
000000r 1               BRKABT	EQU	128	;BREAK key abort
000000r 1               PRVOPN	EQU	129	;IOCB already open error
000000r 1               NONDEV	EQU	130	;nonexistent device error
000000r 1               WRONLY	EQU	131	;IOCB opened for write only error
000000r 1               NVALID	EQU	132	;invalid command error
000000r 1               NOTOPN	EQU	133	;device/file not open error
000000r 1               BADIOC	EQU	134	;invalid IOCB index error
000000r 1               RDONLY	EQU	135	;IOCB opened for read only error
000000r 1               EOFERR	EQU	136	;end of file error
000000r 1               TRNRCD	EQU	137	;truncated record error
000000r 1               TIMOUT	EQU	138	;peripheral device timeout error
000000r 1               DNACK	EQU	139	;device does not acknowledge command error
000000r 1               FRMERR	EQU	140	;serial bus framing error
000000r 1               CRSROR	EQU	141	;cursor overrange error
000000r 1               OVRRUN	EQU	142	;serial bus data overrun error
000000r 1               CHKERR	EQU	143	;serial bus checksum error
000000r 1               DERROR	EQU	144	;device done (operation incomplete) error
000000r 1               BADMOD	EQU	145	;bad screen mode number error
000000r 1               FNCNOT	EQU	146	;function not implemented in handler error
000000r 1               SCRMEM	EQU	147	;insufficient memory for screen mode error
000000r 1               
000000r 1               ;**	DCB Device Bus ID Equates
000000r 1               
000000r 1               
000000r 1               DISKID	EQU	$31	;disk bus ID
000000r 1               PDEVN	EQU	$40	;printer bus ID
000000r 1               CASET	EQU	$60	;cassette bus ID
000000r 1               ;	SPACE	4,10
000000r 1               ;**	Bus Command Equates
000000r 1               
000000r 1               
000000r 1               FOMAT	EQU	'!'	;format command
000000r 1               PUTSEC	EQU	'P'	;put sector command
000000r 1               READ	EQU	'R'	;read command
000000r 1               STATC	EQU	'S'	;status command
000000r 1               WRITE	EQU	'W'	;write command
000000r 1               ;	SPACE	4,10
000000r 1               ;**	Command Auxiliary Byte Equates
000000r 1               
000000r 1               
000000r 1               DOUBLE	EQU	'D'	;print 20 characters double width
000000r 1               NORMAL	EQU	'N'	;print 40 characters normally
000000r 1               PLOT	EQU	'P'	;plot
000000r 1               SIDWAY	EQU	'S'	;print 16 characters sideways
000000r 1               ;	SPACE	4,10
000000r 1               ;**	Bus Response Equates
000000r 1               
000000r 1               
000000r 1               ACK	EQU	'A'	;device acknowledged
000000r 1               COMPLT	EQU	'C'	;device successfully completed operation
000000r 1               ERROR	EQU	'E'	;device incurred error in attempted operation
000000r 1               NACK	EQU	'N'	;device did not understand
000000r 1               ;	SPACE	4,10
000000r 1               ;**	Floating Point Package Miscellaneous Equates
000000r 1               
000000r 1               
000000r 1               FPREC	EQU	6	;precision
000000r 1               
000000r 1               FMPREC	EQU	FPREC-1	;length of mantissa
000000r 1               ;	SPACE	4,10
000000r 1               ;**	Cassette Record Type Equates
000000r 1               
000000r 1               
000000r 1               HDR	EQU	$FB	;header
000000r 1               DTA	EQU	$FC	;data record
000000r 1               DT1	EQU	$FA	;last data record
000000r 1               EOT	EQU	$FE	;end of tape (file)
000000r 1               
000000r 1               TONE1	EQU	2	;record
000000r 1               TONE2	EQU	1	;playback
000000r 1               ;	SPACE	4,10
000000r 1               ;**	Cassette Timing Equates
000000r 1               
000000r 1               
000000r 1               WLEADN	EQU	1152	;NTSC 19.2 second WRITE file leader
000000r 1               RLEADN	EQU	576	;NTSC 9.6 second READ file leader
000000r 1               WIRGLN	EQU	180	;NTSC 3.0 second WRITE IRG
000000r 1               RIRGLN	EQU	120	;NTSC 2.0 second READ IRG
000000r 1               WSIRGN	EQU	15	;NTSC 0.25 second WRITE short IRG
000000r 1               RSIRGN	EQU	10	;NTSC 0.16 second READ short IRG
000000r 1               BEEPNN	EQU	30	;NTSC 0.5 second beep duration
000000r 1               BEEPFN	EQU	10	;NTSC 0.16 second beep separation
000000r 1               
000000r 1               WLEADP	EQU	960	;PAL 19.2 second WRITE file leader
000000r 1               RLEADP	EQU	480	;PAL 9.6 second READ file leader
000000r 1               WIRGLP	EQU	150	;PAL 3.0 second WRITE IRG
000000r 1               RIRGLP	EQU	100	;PAL 2.0 second READ IRG
000000r 1               WSIRGP	EQU	13	;PAL 0.25 second WRITE short IRG
000000r 1               RSIRGP	EQU	8	;PAL 0.16 second READ short IRG
000000r 1               BEEPNP	EQU	25	;PAL 0.5 second beep duration
000000r 1               BEEPFP	EQU	8	;PAL 0.16 second beep separation
000000r 1               
000000r 1               WIRGHI	EQU	0	;high WRITE IRG
000000r 1               RIRGHI	EQU	0	;high READ IRG
000000r 1               ;	SPACE	4,10
000000r 1               ;**	Power-up Validation Byte Value Equates
000000r 1               
000000r 1               
000000r 1               PUPVL1	EQU	$5C	;power-up validation value 1
000000r 1               PUPVL2	EQU	$93	;power-up validation value 2
000000r 1               PUPVL3	EQU	$25	;power-up validation value 3
000000r 1               ;	SPACE	4,10
000000r 1               ;**	Relocating Loader Miscellaneous Equates
000000r 1               
000000r 1               
000000r 1               DATAER	EQU	156	;end of record appears before END r:
000000r 1               MEMERR	EQU	157	;memory insufficient for load error
000000r 1               ;	SPACE	4,10
000000r 1               ;**	Miscellaneous Equates
000000r 1               
000000r 1               
000000r 1               IOCFRE	EQU	$FF	;IOCB free indicator
000000r 1               
000000r 1               B19200	EQU	$0028	;19200 baud POKEY counter value
000000r 1               B00600	EQU	$05CC	;600 baud POKEY counter value
000000r 1               
000000r 1               HITONE	EQU	$05	;FSK high freq. POKEY counter value (5326 Hz)
000000r 1               LOTONE	EQU	$07	;FSK low freq. POKEY counter value (3995 Hz)
000000r 1               
000000r 1               NCOMLO	EQU	$34	;PIA lower NOT COMMAND line command
000000r 1               NCOMHI	EQU	$3C	;PIA raise NOT COMMAND line command
000000r 1               
000000r 1               MOTRGO	EQU	$34	;PIA cassette motor ON command
000000r 1               MOTRST	EQU	$3C	;PIA cassette motor OFF command
000000r 1               
000000r 1               NODAT	EQU	$00	;SIO immediate operation
000000r 1               GETDAT	EQU	$40	;SIO read data frame
000000r 1               PUTDAT	EQU	$80	;SIO write data frame
000000r 1               
000000r 1               CRETRI	EQU	13	;number of command frame retries
000000r 1               DRETRI	EQU	1	;number of device retries
000000r 1               CTIM	EQU	2	;command frame ACK timeout
000000r 1               
000000r 1               NBUFSZ	EQU	40	;print normal buffer size
000000r 1               DBUFSZ	EQU	20	;print double buffer size
000000r 1               SBUFSZ	EQU	29	;print sideways buffer size
000000r 1               ;	SUBTTL	'System Address Equates'
000000r 1               ;	SPACE	4,10
000000r 1               ;**	Page Zero Address Equates
000000r 1               
000000r 1               
000000r 1               LNFLG	EQU	$0000	;1-byte LNBUG flag (0 = not LNBUG)
000000r 1               NGFLAG	EQU	$0001	;1-byte memory status (0 = failure)
000000r 1               
000000r 1               ;	Not Cleared
000000r 1               
000000r 1               CASINI	EQU	$0002	;2-byte cassette program initialization address
000000r 1               RAMLO	EQU	$0004	;2-byte RAM address for memory test
000000r 1               TRAMSZ	EQU	$0006	;1-byte RAM size temporary
000000r 1               CMCMD	EQU	$0007	;1-byte command communications
000000r 1               
000000r 1               ;	Cleared upon Coldstart Only
000000r 1               
000000r 1               WARMST	EQU	$0008	;1-byte warmstart flag (0 = coldstart)
000000r 1               BOOTq	EQU	$0009	;1-byte successful boot flags
000000r 1               DOSVEC	EQU	$000A	;2-byte disk program start vector
000000r 1               DOSINI	EQU	$000C	;2-byte disk program initialization address
000000r 1               APPMHI	EQU	$000E	;2-byte applications memory high limit
000000r 1               
000000r 1               ;	Cleared upon Coldstart or Warmstart
000000r 1               
000000r 1               INTZBS	EQU	$0010	;first page zero location to clear
000000r 1               
000000r 1               POKMSK	EQU	$0010	;1-byte IRQEN shadow
000000r 1               BRKKEY	EQU	$0011	;1-byte BREAK key flag (0 = no BREAK)
000000r 1               RTCLOK	EQU	$0012	;3-byte real time clock (16 millisecond units)
000000r 1               BUFADR	EQU	$0015	;2-byte disk interface buffer address
000000r 1               ICCOMT	EQU	$0017	;1-byte CIO command table index
000000r 1               DSKFMS	EQU	$0018	;2-byte DOS File Management System pointer
000000r 1               DSKUTL	EQU	$001A	;2-byte DOS utility pointer
000000r 1               ABUFPT	EQU	$001C	;4-byte ACMI buffer pointer area
000000r 1               
000000r 1               ZIOCB	EQU	$0020	;address of page zero IOCB
000000r 1               IOCBAS	EQU	$0020	;16-byte page zero IOCB
000000r 1               ICHIDZ	EQU	$0020	;1-byte handler ID ($FF = IOCB free)
000000r 1               ICDNOZ	EQU	$0021	;1-byte device number
000000r 1               ICCOMZ	EQU	$0022	;1-byte command code
000000r 1               ICSTAZ	EQU	$0023	;1-byte status of last action
000000r 1               ICBALZ	EQU	$0024	;1-byte low buffer address
000000r 1               ICBAHZ	EQU	$0025	;1-byte high buffer address
000000r 1               ICPTLZ	EQU	$0026	;1-byte low PUT-BYTE routine address-1
000000r 1               ICPTHZ	EQU	$0027	;1-byte high PUT-BYTE routine address-1
000000r 1               ICBLLZ	EQU	$0028	;1-byte low buffer length
000000r 1               ICBLHZ	EQU	$0029	;1-byte high buffer length
000000r 1               ICAX1Z	EQU	$002A	;1-byte first auxiliary information
000000r 1               ICAX2Z	EQU	$002B	;1-byte second auxiliary information
000000r 1               ICSPRZ	EQU	$002C	;4-byte spares
000000r 1               
000000r 1               ENTVEC	EQU	$002C	;2-byte (not used)
000000r 1               ICIDNO	EQU	$002E	;1-byte IOCB index (IOCB number times IOCBSZ)
000000r 1               CIOCHR	EQU	$002F	;1-byte character for current CIO operation
000000r 1               
000000r 1               STATUS	EQU	$0030	;1-byte SIO operation status
000000r 1               CHKSUM	EQU	$0031	;1-byte checksum (single byte sum with carry)
000000r 1               BUFRLO	EQU	$0032	;1-byte low data buffer address
000000r 1               BUFRHI	EQU	$0033	;1-byte high data buffer address
000000r 1               BFENLO	EQU	$0034	;1-byte low data buffer end address
000000r 1               BFENHI	EQU	$0035	;1-byte high data buffer end address
000000r 1               LTEMP	EQU	$0036	;2-byte relocating loader temporary
000000r 1               BUFRFL	EQU	$0038	;1-byte data buffer full flag (0 = not full)
000000r 1               RECVDN	EQU	$0039	;1-byte receive-frame done flag (0 = not done)
000000r 1               XMTDON	EQU	$003A	;1-byte transmit-frame done flag (0 = not done)
000000r 1               CHKSNT	EQU	$003B	;1-byte checksum sent flag (0 = not sent)
000000r 1               NOCKSM	EQU	$003C	;1-byte no checksum follows data flag (0 = does)
000000r 1               BPTR	EQU	$003D	;1-byte cassette buffer pointer
000000r 1               FTYPE	EQU	$003E	;1-byte cassette IRG type (neg. = continuous)
000000r 1               FEOF	EQU	$003F	;1-byte cassette EOF flag (0 = no EOF)
000000r 1               FREQ	EQU	$0040	;1-byte cassette beep counter
000000r 1               SOUNDR	EQU	$0041	;1-byte noisy I/O flag (0 = quiet)
000000r 1               
000000r 1               CRITIC	EQU	$0042	;1-byte critical section flag (0 = not critical)
000000r 1               
000000r 1               FMSZPG	EQU	$0043	;7-byte reserved for DOS File Management System
000000r 1               
000000r 1               ZCHAIN	EQU	$004A	;2-byte handler linkage chain point:
000000r 1               DSTAT	EQU	$004C	;1-byte display status
000000r 1               ATRACT	EQU	$004D	;1-byte attract-mode timer and flag
000000r 1               DRKMSK	EQU	$004E	;1-byte attract-mode dark (luminance) mask
000000r 1               COLRSH	EQU	$004F	;1-byte attract-mode color shift
000000r 1               TMPCHR	EQU	$0050	;1-byte	temporary character
000000r 1               HOLD1	EQU	$0051	;1-byte	temporary
000000r 1               LMARGN	EQU	$0052	;1-byte text column left margin
000000r 1               RMARGN	EQU	$0053	;1-byte text column right margin
000000r 1               ROWCRS	EQU	$0054	;1-byte cursor row
000000r 1               COLCRS	EQU	$0055	;2-byte cursor column
000000r 1               DINDEX	EQU	$0057	;1-byte display mode
000000r 1               SAVMSC	EQU	$0058	;2-byte saved memory scan counter
000000r 1               OLDROW	EQU	$005A	;1-byte prior row
000000r 1               OLDCOL	EQU	$005B	;2-byte prior column
000000r 1               OLDCHR	EQU	$005D	;1-byte saved character under cursor
000000r 1               OLDADR	EQU	$005E	;2-byte saved cursor memory address
000000r 1               FKDEF	EQU	$0060	;2-byte function key definition tab:
000000r 1               PALNTS	EQU	$0062	;1-byte PAL/NTSC indicator (0 = NTS:
000000r 1               LOGCOL	EQU	$0063	;1-byte logical line cursor column
000000r 1               ADRESS	EQU	$0064	;2-byte temporary address
000000r 1               
000000r 1               MLTTMP	EQU	$0066	;1-byte temporary
000000r 1               OPNTMP	EQU	$0066	;1-byte open temporary
000000r 1               TOADR	EQU	$0066	;2-byte destination address
000000r 1               
000000r 1               SAVADR	EQU	$0068	;2-byte saved address
000000r 1               FRMADR	EQU	$0068	;2-byte source address
000000r 1               
000000r 1               RAMTOP	EQU	$006A	;1-byte RAM size
000000r 1               BUFCNT	EQU	$006B	;1-byte buffer count (logical line size)
000000r 1               BUFSTR	EQU	$006C	;2-byte buffer start pointer
000000r 1               BITMSK	EQU	$006E	;1-byte bit mask for bit map operation
000000r 1               SHFAMT	EQU	$006F	;1-byte shift amount for pixel justification
000000r 1               ROWAC	EQU	$0070	;2-byte draw working row
000000r 1               COLAC	EQU	$0072	;2-byte draw working column
000000r 1               ENDPT	EQU	$0074	;2-byte end point
000000r 1               DELTAR	EQU	$0076	;1-byte row difference
000000r 1               DELTAC	EQU	$0077	;2-byte column difference
000000r 1               KEYDEF	EQU	$0079	;2-byte key definition table addres:
000000r 1               SWPFLG	EQU	$007B	;1-byte split screen swap flag (0 = not swapped)
000000r 1               HOLDCH	EQU	$007C	;1-byte temporary character
000000r 1               INSDAT	EQU	$007D	;1-byte temporary
000000r 1               COUNTR	EQU	$007E	;2-byte draw iteration count
000000r 1               
000000r 1               ;	Reserved for Application and Floating Point Package
000000r 1               
000000r 1               ;	EQU	$0080	;128 bytes reserved for application and FPP
000000r 1               ;	SPACE	4,10
000000r 1               ;**	Floating Point Package Page Zero Address Equates
000000r 1               
000000r 1               
000000r 1               FR0	EQU	$00D4	;6-byte register 0
000000r 1               FR0M	EQU	$00D5	;5-byte register 0 mantissa
000000r 1               QTEMP	EQU	$00D9	;1-byte temporary
000000r 1               
000000r 1               FRE	EQU	$00DA	;6-byte (internal) register E
000000r 1               
000000r 1               FR1	EQU	$00E0	;6-byte register 1
000000r 1               FR1M	EQU	$00E1	;5-byte register 1 mantissa
000000r 1               
000000r 1               FR2	EQU	$00E6	;6-byte (internal) register 2
000000r 1               
000000r 1               FRX	EQU	$00EC	;1-byte temporary
000000r 1               
000000r 1               EEXP	EQU	$00ED	;1-byte value of exponent
000000r 1               
000000r 1               FRSIGN	EQU	$00EE	;1-byte floating point sign
000000r 1               NSIGN	EQU	$00EE	;1-byte sign of number
000000r 1               
000000r 1               PLYCNT	EQU	$00EF	;1-byte polynomial degree
000000r 1               ESIGN	EQU	$00EF	;1-byte sign of exponent
000000r 1               
000000r 1               SGNFLG	EQU	$00F0	;1-byte sign flag
000000r 1               FCHFLG	EQU	$00F0	;1-byte first character flag
000000r 1               
000000r 1               XFMFLG	EQU	$00F1	;1-byte transform flag
000000r 1               DIGRT	EQU	$00F1	;1-byte number of digits after decimal point
000000r 1               
000000r 1               CIX	EQU	$00F2	;1-byte current input index
000000r 1               INBUFF	EQU	$00F3	;2-byte line input buffer
000000r 1               
000000r 1               ZTEMP1	EQU	$00F5	;2-byte temporary
000000r 1               ZTEMP4	EQU	$00F7	;2-byte temporary
000000r 1               ZTEMP3	EQU	$00F9	;2-byte temporary
000000r 1               
000000r 1               FLPTR	EQU	$00FC	;2-byte floating point number pointer
000000r 1               FPTR2	EQU	$00FE	;2-byte floating point number pointer
000000r 1               ;	SPACE	4,10
000000r 1               ;**	Page One (Stack) Address Equates
000000r 1               
000000r 1               
000000r 1               ;	EQU	$0100	;256-byte stack
000000r 1               ;	SPACE	4,10
000000r 1               ;**	Page Two Address Equates
000000r 1               
000000r 1               
000000r 1               INTABS	EQU	$0200	;42-byte interrupt handler table
000000r 1               
000000r 1               VDSLST	EQU	$0200	;2-byte display list NMI vector
000000r 1               VPRCED	EQU	$0202	;2-byte serial I/O proceed line IRQ vector
000000r 1               VINTER	EQU	$0204	;2-byte serial I/O interrupt line IRQ vector
000000r 1               VBREAK	EQU	$0206	;2-byte BRK instruction IRQ vector
000000r 1               VKEYBD	EQU	$0208	;2-byte keyboard IRQ vector
000000r 1               VSERIN	EQU	$020A	;2-byte serial input ready IRQ vector
000000r 1               VSEROR	EQU	$020C	;2-byte serial output ready IRQ vector
000000r 1               VSEROC	EQU	$020E	;2-byte serial output complete IRQ vector
000000r 1               VTIMR1	EQU	$0210	;2-byte POKEY timer 1 IRQ vector
000000r 1               VTIMR2	EQU	$0212	;2-byte POKEY timer 2 IRQ vector
000000r 1               VTIMR4	EQU	$0214	;2-byte POKEY timer 4 IRQ vector
000000r 1               VIMIRQ	EQU	$0216	;2-byte immediate IRQ vector
000000r 1               CDTMV1	EQU	$0218	;2-byte countdown timer 1 value
000000r 1               CDTMV2	EQU	$021A	;2-byte countdown timer 2 value
000000r 1               CDTMV3	EQU	$021C	;2-byte countdown timer 3 value
000000r 1               CDTMV4	EQU	$021E	;2-byte countdown timer 4 value
000000r 1               CDTMV5	EQU	$0220	;2-byte countdown timer 5 value
000000r 1               VVBLKI	EQU	$0222	;2-byte immediate VBLANK NMI vector
000000r 1               VVBLKD	EQU	$0224	;2-byte deferred VBLANK NMI vector
000000r 1               CDTMA1	EQU	$0226	;2-byte countdown timer 1 vector
000000r 1               CDTMA2	EQU	$0228	;2-byte countdown timer 2 vector
000000r 1               
000000r 1               CDTMF3	EQU	$022A	;1-byte countdown timer 3 flag (0 = expired)
000000r 1               SRTIMR	EQU	$022B	;1-byte software key repeat timer
000000r 1               CDTMF4	EQU	$022C	;1-byte countdown timer 4 flag (0 = expired)
000000r 1               INTEMP	EQU	$022D	;1-byte temporary
000000r 1               CDTMF5	EQU	$022E	;1-byte countdown timer 5 flag (0 = expired)
000000r 1               SDMCTL	EQU	$022F	;1-byte DMACTL shadow
000000r 1               SDLSTL	EQU	$0230	;1-byte DLISTL shadow
000000r 1               SDLSTH	EQU	$0231	;1-byte DLISTH shadow
000000r 1               SSKCTL	EQU	$0232	;1-byte SKCTL shadow
000000r 1               LCOUNT	EQU	$0233	;1-byte relocating loader record le:
000000r 1               LPENH	EQU	$0234	;1-byte light pen horizontal value
000000r 1               LPENV	EQU	$0235	;1-byte light pen vertical value
000000r 1               BRKKY	EQU	$0236	;2-byte BREAK key vector
000000r 1               VPIRQ	EQU	$0238	;2-byte parallel device IRQ vector
000000r 1               CDEVIC	EQU	$023A	;1-byte command frame device ID
000000r 1               CCOMND	EQU	$023B	;1-byte command frame command
000000r 1               CAUX1	EQU	$023C	;1-byte command auxiliary 1
000000r 1               CAUX2	EQU	$023D	;1-byte command auxiliary 2
000000r 1               
000000r 1               TEMP	EQU	$023E	;1-byte temporary
000000r 1               
000000r 1               	ASSERT	low TEMP<>$FF	;may not be the last word on a page
000000r 1               
000000r 1               ERRFLG	EQU	$023F	;1-byte I/O error flag (0 = no error)
000000r 1               
000000r 1               	ASSERT	low ERRFLG<>$FF ;may not be the last word on a page
000000r 1               
000000r 1               DFLAGS	EQU	$0240	;1-byte disk flags from sector 1
000000r 1               DBSECT	EQU	$0241	;1-byte disk boot sector count
000000r 1               BOOTAD	EQU	$0242	;2-byte disk boot memory address
000000r 1               COLDST	EQU	$0244	;1-byte coldstart flag (0 = complete)
000000r 1               RECLEN	EQU	$0245	;1-byte relocating loader record le:
000000r 1               DSKTIM	EQU	$0246	;1-byte disk format timeout
000000r 1               PDVMSK	EQU	$0247	;1-byte parallel device selection mask
000000r 1               SHPDVS	EQU	$0248	;1-byte PDVS (parallel device selec:
000000r 1               PDIMSK	EQU	$0249	;1-byte parallel device IRQ selection mask
000000r 1               RELADR	EQU	$024A	;2-byte relocating loader relative :
000000r 1               PPTMPA	EQU	$024C	;1-byte parallel device handler tem:
000000r 1               PPTMPX	EQU	$024D	;1-byte parallel device handler tem:
000000r 1               
000000r 1               ;	EQU	$024E	;6 bytes reserved for Atari
000000r 1               
000000r 1               ;	EQU	$0254	;23 bytes reserved for Atari
000000r 1               
000000r 1               CHSALT	EQU	$026B	;1-byte character set alternate
000000r 1               VSFLAG	EQU	$026C	;1-byte fine vertical scroll count
000000r 1               KEYDIS	EQU	$026D	;1-byte keyboard disable
000000r 1               FINE	EQU	$026E	;1-byte fine scrolling mode
000000r 1               GPRIOR	EQU	$026F	;1-byte PRIOR shadow
000000r 1               
000000r 1               PADDL0	EQU	$0270	;1-byte potentiometer 0
000000r 1               PADDL1	EQU	$0271	;1-byte potentiometer 1
000000r 1               PADDL2	EQU	$0272	;1-byte potentiometer 2
000000r 1               PADDL3	EQU	$0273	;1-byte potentiometer 3
000000r 1               PADDL4	EQU	$0274	;1-byte potentiometer 4
000000r 1               PADDL5	EQU	$0275	;1-byte potentiometer 5
000000r 1               PADDL6	EQU	$0276	;1-byte potentiometer 6
000000r 1               PADDL7	EQU	$0277	;1-byte potentiometer 7
000000r 1               
000000r 1               STICK0	EQU	$0278	;1-byte joystick 0
000000r 1               STICK1	EQU	$0279	;1-byte joystick 1
000000r 1               STICK2	EQU	$027A	;1-byte joystick 2
000000r 1               STICK3	EQU	$027B	;1-byte joystick 3
000000r 1               
000000r 1               PTRIG0	EQU	$027C	;1-byte paddle trigger 0
000000r 1               PTRIG1	EQU	$027D	;1-byte paddle trigger 1
000000r 1               PTRIG2	EQU	$027E	;1-byte paddle trigger 2
000000r 1               PTRIG3	EQU	$027F	;1-byte paddle trigger 3
000000r 1               PTRIG4	EQU	$0280	;1-byte paddle trigger 4
000000r 1               PTRIG5	EQU	$0281	;1-byte paddle trigger 5
000000r 1               PTRIG6	EQU	$0282	;1-byte paddle trigger 6
000000r 1               PTRIG7	EQU	$0283	;1-byte paddle trigger 7
000000r 1               
000000r 1               STRIG0	EQU	$0284	;1-byte joystick trigger 0
000000r 1               STRIG1	EQU	$0285	;1-byte joystick trigger 1
000000r 1               STRIG2	EQU	$0286	;1-byte joystick trigger 2
000000r 1               STRIG3	EQU	$0287	;1-byte joystick trigger 3
000000r 1               
000000r 1               HIBYTE	EQU	$0288	;1-byte relocating loader high byte:
000000r 1               WMODE	EQU	$0289	;1-byte cassette WRITE mode ($80 = writing)
000000r 1               BLIM	EQU	$028A	;1-byte cassette buffer limit
000000r 1               IMASK	EQU	$028B	;1-byte (not used)
000000r 1               JVECK	EQU	$028C	;2-byte jump vector or temporary
000000r 1               NEWADR	EQU	$028E	;2-byte relocating address
000000r 1               TXTROW	EQU	$0290	;1-byte split screen text cursor row
000000r 1               TXTCOL	EQU	$0291	;2-byte split screen text cursor column
000000r 1               TINDEX	EQU	$0293	;1-byte split scree text mode
000000r 1               TXTMSC	EQU	$0294	;2-byte split screen memory scan counter
000000r 1               TXTOLD	EQU	$0296	;6-byte OLDROW, OLDCOL, OLDCHR, OLDADR for text
000000r 1               CRETRY	EQU	$029C	;1-byte number of command frame ret:
000000r 1               HOLD3	EQU	$029D	;1-byte temporary
000000r 1               SUBTMP	EQU	$029E	;1-byte temporary
000000r 1               HOLD2	EQU	$029F	;1-byte (not used)
000000r 1               DMASK	EQU	$02A0	;1-byte display (pixel location) mask
000000r 1               TMPLBT	EQU	$02A1	;1-byte (not used)
000000r 1               ESCFLG	EQU	$02A2	;1-byte escape flag ($80 = ESC detected)
000000r 1               TABMAP	EQU	$02A3	;15-byte (120-bit) tab stop bit map
000000r 1               LOGMAP	EQU	$02B2	;8-byte (32-bit) logical line bit map
000000r 1               INVFLG	EQU	$02B6	;1-byte inverse video flag ($80 = inverse)
000000r 1               FILFLG	EQU	$02B7	;1-byte right fill flag (0 = no fill)
000000r 1               TMPROW	EQU	$02B8	;1-byte temporary row
000000r 1               TMPCOL	EQU	$02B9	;2-byte temporary column
000000r 1               SCRFLG	EQU	$02BB	;1-byte scroll occurence flag (0 = not occurred)
000000r 1               HOLD4	EQU	$02BC	;1-byte temporary
000000r 1               DRETRY	EQU	$02BD	;1-byte number of device retries
000000r 1               SHFLOK	EQU	$02BE	;1-byte shift/control lock flags
000000r 1               BOTSCR	EQU	$02BF	;1-byte screen bottom (24 = normal, 4 = split)
000000r 1               
000000r 1               PCOLR0	EQU	$02C0	;1-byte player-missle 0 color/luminance
000000r 1               PCOLR1	EQU	$02C1	;1-byte player-missle 1 color/luminance
000000r 1               PCOLR2	EQU	$02C2	;1-byte player-missle 2 color/luminance
000000r 1               PCOLR3	EQU	$02C3	;1-byte player-missle 3 color/luminance
000000r 1               
000000r 1               COLOR0	EQU	$02C4	;1-byte playfield 0 color/luminance
000000r 1               COLOR1	EQU	$02C5	;1-byte playfield 1 color/luminance
000000r 1               COLOR2	EQU	$02C6	;1-byte playfield 2 color/luminance
000000r 1               COLOR3	EQU	$02C7	;1-byte playfield 3 color/luminance
000000r 1               
000000r 1               COLOR4	EQU	$02C8	;1-byte background color/luminance
000000r 1               
000000r 1               PARMBL	EQU	$02C9	;6-byte relocating loader parameter:
000000r 1               RUNADR	EQU	$02C9	;2-byte run address
000000r 1               HIUSED	EQU	$02CB	;2-byte highest non-zero page addre:
000000r 1               ZHIUSE	EQU	$02CD	;2-byte highest zero page address
000000r 1               
000000r 1               OLDPAR	EQU	$02CF	;6-byte relocating loader parameter:
000000r 1               GBYTEA	EQU	$02CF	;2-byte GET-BYTE routine address
000000r 1               LOADAD	EQU	$02D1	;2-byte non-zero page load address
000000r 1               ZLOADA	EQU	$02D3	;2-byte zero page load address
000000r 1               
000000r 1               DSCTLN	EQU	$02D5	;2-byte disk sector length
000000r 1               ACMISR	EQU	$02D7	;2-byte ACMI interrupt service rout:
000000r 1               KRPDEL	EQU	$02D9	;1-byte auto-repeat delay
000000r 1               KEYREP	EQU	$02DA	;1-byte auto-repeat rate
000000r 1               NOCLIK	EQU	$02DB	;1-byte key click disable
000000r 1               HELPFG	EQU	$02DC	;1-byte HELP key flag (0 = no HELP)
000000r 1               DMASAV	EQU	$02DD	;1-byte SDMCTL save/restore
000000r 1               PBPNT	EQU	$02DE	;1-byte printer buffer pointer
000000r 1               PBUFSZ	EQU	$02DF	;1-byte printer buffer size
000000r 1               
000000r 1               ;	EQU	$02E0	;4 bytes reserved for DOS
000000r 1               
000000r 1               RAMSIZ	EQU	$02E4	;1-byte high RAM size
000000r 1               MEMTOP	EQU	$02E5	;2-byte top of available user memory
000000r 1               MEMLO	EQU	$02E7	;2-byte bottom of available user memory
000000r 1               HNDLOD	EQU	$02E9	;1-byte user load flag (0 = no hand:
000000r 1               DVSTAT	EQU	$02EA	;4-byte device status buffer
000000r 1               CBAUDL	EQU	$02EE	;1-byte low cassette baud rate
000000r 1               CBAUDH	EQU	$02EF	;1-byte high cassette baud rate
000000r 1               CRSINH	EQU	$02F0	;1-byte cursor inhibit (0 = cursor on)
000000r 1               KEYDEL	EQU	$02F1	;1-byte key debounce delay timer
000000r 1               CH1	EQU	$02F2	;1-byte prior keyboard character
000000r 1               CHACT	EQU	$02F3	;1-byte CHACTL shadow
000000r 1               CHBAS	EQU	$02F4	;1-byte CHBASE shadow
000000r 1               
000000r 1               NEWROW	EQU	$02F5	;1-byte draw destination row
000000r 1               NEWCOL	EQU	$02F6	;2-byte draw destination column
000000r 1               ROWINC	EQU	$02F8	;1-byte draw row increment
000000r 1               COLINC	EQU	$02F9	;1-byte	draw column increment
000000r 1               
000000r 1               CHAR	EQU	$02FA	;1-byte internal character
000000r 1               ATACHR	EQU	$02FB	;1-byte ATASCII character or plot point
000000r 1               CH	EQU	$02FC	;1-byte keyboard code (buffer)
000000r 1               FILDAT	EQU	$02FD	;1-byte right fill data
000000r 1               DSPFLG	EQU	$02FE	;1-byte control character display flag (0 = no)
000000r 1               SSFLAG	EQU	$02FF	;1-byte start/stop flag (0 = not stopped)
000000r 1               ;	SPACE	4,10
000000r 1               ;**	Page Three Address Equates
000000r 1               
000000r 1               
000000r 1               DCB	EQU	$0300	;12-byte device control block
000000r 1               DDEVIC	EQU	$0300	;1-byte unit 1 bus ID
000000r 1               DUNIT	EQU	$0301	;1-byte unit number
000000r 1               DCOMND	EQU	$0302	;1-byte bus command
000000r 1               DSTATS	EQU	$0303	;1-byte command type/status return
000000r 1               DBUFLO	EQU	$0304	;1-byte low data buffer address
000000r 1               DBUFHI	EQU	$0305	;1-byte high data buffer address
000000r 1               DTIMLO	EQU	$0306	;1-byte timeout (seconds)
000000r 1               DUNUSE	EQU	$0307	;1-byte (not used)
000000r 1               DBYTLO	EQU	$0308	;1-byte low number of bytes to transfer
000000r 1               DBYTHI	EQU	$0309	;1-byte high number of bytes to transfer
000000r 1               DAUX1	EQU	$030A	;1-byte first command auxiliary
000000r 1               DAUX2	EQU	$030B	;1-byte second command auxiliary
000000r 1               
000000r 1               TIMER1	EQU	$030C	;2-byte initial baud rate timer value
000000r 1               JMPERS	EQU	$030E	;1-byte jumper options
000000r 1               CASFLG	EQU	$030F	;1-byte cassette I/O flag (0 = not cassette I/O)
000000r 1               TIMER2	EQU	$0310	;2-byte final baud rate timer value
000000r 1               TEMP1	EQU	$0312	;2-byte temporary
000000r 1               TEMP2	EQU	$0313	;1-byte temporary
000000r 1               PTIMOT	EQU	$0314	;1-byte printer timeout
000000r 1               TEMP3	EQU	$0315	;1-byte temporary
000000r 1               SAVIO	EQU	$0316	;1-byte saved serial data input indicator
000000r 1               TIMFLG	EQU	$0317	;1-byte timeout flag (0 = timeout)
000000r 1               STACKP	EQU	$0318	;1-byte SIO saved stack pointer
000000r 1               TSTAT	EQU	$0319	;1-byte temporary status
000000r 1               
000000r 1               HATABS	EQU	$031A	;35-byte handler address table
000000r 1               
000000r 1               PUPBT1	EQU	$033D	;1-byte power-up validation byte 1
000000r 1               PUPBT2	EQU	$033E	;1-byte power-up validation byte 2
000000r 1               PUPBT3	EQU	$033F	;1-byte power-up validation byte 3
000000r 1               
000000r 1               IOCB	EQU	$0340	;128-byte I/O control blocks area
000000r 1               ICHID	EQU	$0340	;1-byte handler ID ($FF = free)
000000r 1               ICDNO	EQU	$0341	;1-byte device number
000000r 1               ICCOM	EQU	$0342	;1-byte command code
000000r 1               ICSTA	EQU	$0343	;1-byte status of last action
000000r 1               ICBAL	EQU	$0344	;1-byte low buffer address
000000r 1               ICBAH	EQU	$0345	;1-byte high buffer address
000000r 1               ICPTL	EQU	$0346	;1-byte low PUT-BYTE routine address-1
000000r 1               ICPTH	EQU	$0347	;1-byte high PUT-BYTE routine address-1
000000r 1               ICBLL	EQU	$0348	;1-byte low buffer length
000000r 1               ICBLH	EQU	$0349	;1-byte high buffer length
000000r 1               ICAX1	EQU	$034A	;1-byte first auxiliary information
000000r 1               ICAX2	EQU	$034B	;1-byte second auxiliary information
000000r 1               ICSPR	EQU	$034C	;4-byte work area
000000r 1               
000000r 1               PRNBUF	EQU	$03C0	;40-byte printer buffer
000000r 1               SUPERF	EQU	$03E8	;1-byte editor super function flag :
000000r 1               CKEY	EQU	$03E9	;1-byte cassette boot request flag :
000000r 1               CASSBT	EQU	$03EA	;1-byte cassette boot flag (0 = not:
000000r 1               CARTCK	EQU	$03EB	;1-byte cartridge equivalence checksum
000000r 1               DERRF	EQU	$03EC	;1-byte screen OPEN error flag (0 = not)
000000r 1               
000000r 1               ;	Remainder of Page Three Not Cleared upon Reset
000000r 1               
000000r 1               ACMVAR	EQU	$03ED	;11 bytes reserved for ACMI
000000r 1               BASICF	EQU	$03F8	;1-byte BASIC switch flag (0 = BASIC enabled)
000000r 1               MINTLK	EQU	$03F9	;1-byte ACMI module interlock
000000r 1               GINTLK	EQU	$03FA	;1-byte cartridge interlock
000000r 1               CHLINK	EQU	$03FB	;2-byte loaded handler chain link
000000r 1               CASBUF	EQU	$03FD	;3-byte first 3 bytes of cassette buffer
000000r 1               ;	SPACE	4,10
000000r 1               ;**	Page Four Address Equates
000000r 1               
000000r 1               
000000r 1               ;	EQU	$0400	;128-byte remainder of cassette buffer
000000r 1               
000000r 1               ;	Reserved for Application
000000r 1               
000000r 1               USAREA	EQU	$0480	;128 bytes reserved for application
000000r 1               ;	SPACE	4,10
000000r 1               ;**	Page Five Address Equates
000000r 1               
000000r 1               
000000r 1               ;	Reserved for Application and Floating Point Package
000000r 1               
000000r 1               ;	EQU	$0500	;256 bytes reserved for application and FPP
000000r 1               ;	SPACE	4,10
000000r 1               ;**	Floating Point Package Address Equates
000000r 1               
000000r 1               
000000r 1               LBPR1	EQU	$057E	;1-byte LBUFF preamble
000000r 1               LBPR2	EQU	$057F	;1-byte LBUFF preamble
000000r 1               LBUFF	EQU	$0580	;128-byte line buffer
000000r 1               
000000r 1               PLYARG	EQU	$05E0	;6-byte floating point polynomial argument
000000r 1               FPSCR	EQU	$05E6	;6-byte floating point temporary
000000r 1               FPSCR1	EQU	$05EC	;6-byte floating point temporary
000000r 1               ;	SPACE	4,10
000000r 1               ;**	Page Six Address Equates
000000r 1               
000000r 1               
000000r 1               ;	Reserved for Application
000000r 1               
000000r 1               ;	EQU	$0600	;256 bytes reserved for application
000000r 1               ;	SPACE	4,10
000000r 1               ;**	LNBUG Address Equates
000000r 1               
000000r 1               
000000r 1               	IF	LNBUG
000000r 1               LNORG	EQU	$6000	;LNBUG origin
000000r 1               LNIRQ	EQU	$6033	;LNBUG IRQ entry
000000r 1               LNNMI	EQU	$8351	;LNBUG NMI vector
000000r 1               	ENDIF	;LNBUG
000000r 1               ;	SPACE	4,10
000000r 1               ;**	Cartridge Address Equates
000000r 1               
000000r 1               
000000r 1               CARTCS	EQU	$BFFA	;2-byte cartridge coldstart address
000000r 1               CART	EQU	$BFFC	;1-byte cartridge present indicator
000000r 1               CARTFG	EQU	$BFFD	;1-byte cartridge flags
000000r 1               CARTAD	EQU	$BFFE	;2-byte cartridge start vector
000000r 1               ;	SPACE	4,10
000000r 1               ;**	CTIA/GTIA Address Equates
000000r 1               
000000r 1               
000000r 1               CTIA	EQU	$D000	;CTIA/GTIA area
000000r 1               
000000r 1               ;	Read/Write Addresses
000000r 1               
000000r 1               CONSOL	EQU	$D01F	;console switches and speaker control
000000r 1               
000000r 1               ;	Read Addresses
000000r 1               
000000r 1               M0PF	EQU	$D000	;missle 0 and playfield collision
000000r 1               M1PF	EQU	$D001	;missle 1 and playfield collision
000000r 1               M2PF	EQU	$D002	;missle 2 and playfield collision
000000r 1               M3PF	EQU	$D003	;missle 3 and playfield collision
000000r 1               
000000r 1               P0PF	EQU	$D004	;player 0 and playfield collision
000000r 1               P1PF	EQU	$D005	;player 1 and playfield collision
000000r 1               P2PF	EQU	$D006	;player 2 and playfield collision
000000r 1               P3PF	EQU	$D007	;player 3 and playfield collision
000000r 1               
000000r 1               M0PL	EQU	$D008	;missle 0 and player collision
000000r 1               M1PL	EQU	$D009	;missle 1 and player collision
000000r 1               M2PL	EQU	$D00A	;missle 2 and player collision
000000r 1               M3PL	EQU	$D00B	;missle 3 and player collision
000000r 1               
000000r 1               P0PL	EQU	$D00C	;player 0 and player collision
000000r 1               P1PL	EQU	$D00D	;player 1 and player collision
000000r 1               P2PL	EQU	$D00E	;player 2 and player collision
000000r 1               P3PL	EQU	$D00F	;player 3 and player collision
000000r 1               
000000r 1               TRIG0	EQU	$D010	;joystick trigger 0
000000r 1               TRIG1	EQU	$D011	;joystick trigger 1
000000r 1               
000000r 1               TRIG2	EQU	$D012	;cartridge interlock
000000r 1               TRIG3	EQU	$D013	;ACMI module interlock
000000r 1               
000000r 1               PAL	EQU	$D014	;PAL/NTSC indicator
000000r 1               
000000r 1               ;	Write Addresses
000000r 1               
000000r 1               HPOSP0	EQU	$D000	;player 0 horizontal position
000000r 1               HPOSP1	EQU	$D001	;player 1 horizontal position
000000r 1               HPOSP2	EQU	$D002	;player 2 horizontal position
000000r 1               HPOSP3	EQU	$D003	;player 3 horizontal position
000000r 1               
000000r 1               HPOSM0	EQU	$D004	;missle 0 horizontal position
000000r 1               HPOSM1	EQU	$D005	;missle 1 horizontal position
000000r 1               HPOSM2	EQU	$D006	;missle 2 horizontal position
000000r 1               HPOSM3	EQU	$D007	;missle 3 horizontal position
000000r 1               
000000r 1               SIZEP0	EQU	$D008	;player 0 size
000000r 1               SIZEP1	EQU	$D009	;player 1 size
000000r 1               SIZEP2	EQU	$D00A	;player 2 size
000000r 1               SIZEP3	EQU	$D00B	;player 3 size
000000r 1               
000000r 1               SIZEM	EQU	$D00C	;missle sizes
000000r 1               
000000r 1               GRAFP0	EQU	$D00D	;player 0 graphics
000000r 1               GRAFP1	EQU	$D00E	;player 1 graphics
000000r 1               GRAFP2	EQU	$D00F	;player 2 graphics
000000r 1               GRAFP3	EQU	$D010	;player 3 graphics
000000r 1               
000000r 1               GRAFM	EQU	$D011	;missle graphics
000000r 1               
000000r 1               COLPM0	EQU	$D012	;player-missle 0 color/luminance
000000r 1               COLPM1	EQU	$D013	;player-missle 1 color/luminance
000000r 1               COLPM2	EQU	$D014	;player-missle 2 color/luminance
000000r 1               COLPM3	EQU	$D015	;player-missle 3 color/luminance
000000r 1               
000000r 1               COLPF0	EQU	$D016	;playfield 0 color/luminance
000000r 1               COLPF1	EQU	$D017	;playfield 1 color/luminance
000000r 1               COLPF2	EQU	$D018	;playfield 2 color/luminance
000000r 1               COLPF3	EQU	$D019	;playfield 3 color/luminance
000000r 1               
000000r 1               COLBK	EQU	$D01A	;background color/luminance
000000r 1               
000000r 1               PRIOR	EQU	$D01B	;priority select
000000r 1               VDELAY	EQU	$D01C	;vertical delay
000000r 1               GRACTL	EQU	$D01D	;graphic control
000000r 1               HITCLR	EQU	$D01E	;collision clear
000000r 1               ;	SPACE	4,10
000000r 1               ;**	PBI Address Equates
000000r 1               
000000r 1               
000000r 1               PBI	EQU	$D100	;parallel bus interface area
000000r 1               
000000r 1               ;	Read Addresses
000000r 1               
000000r 1               PDVI	EQU	$D1FF	;parallel device IRQ status
000000r 1               
000000r 1               ;	Write Addresses
000000r 1               
000000r 1               PDVS	EQU	$D1FF	;parallel device select
000000r 1               ;	SPACE	4,10
000000r 1               ;**	POKEY Address Equates
000000r 1               
000000r 1               
000000r 1               POKEY	EQU	$D200	;POKEY area
000000r 1               
000000r 1               ;	Read Addresses
000000r 1               
000000r 1               POT0	EQU	$D200	;potentiometer 0
000000r 1               POT1	EQU	$D201	;potentiometer 1
000000r 1               POT2	EQU	$D202	;potentiometer 2
000000r 1               POT3	EQU	$D203	;potentiometer 3
000000r 1               POT4	EQU	$D204	;potentiometer 4
000000r 1               POT5	EQU	$D205	;potentiometer 5
000000r 1               POT6	EQU	$D206	;potentiometer 6
000000r 1               POT7	EQU	$D207	;potentiometer 7
000000r 1               
000000r 1               ALLPOT	EQU	$D208	;potentiometer port state
000000r 1               KBCODE	EQU	$D209	;keyboard code
000000r 1               RANDOM	EQU	$D20A	;random number generator
000000r 1               SERIN	EQU	$D20D	;serial port input
000000r 1               IRQST	EQU	$D20E	;IRQ interrupt status
000000r 1               SKSTAT	EQU	$D20F	;serial port and keyboard status
000000r 1               
000000r 1               ;	Write Addresses
000000r 1               
000000r 1               AUDF1	EQU	$D200	;channel 1 audio frequency
000000r 1               AUDC1	EQU	$D201	;channel 1 audio control
000000r 1               
000000r 1               AUDF2	EQU	$D202	;channel 2 audio frequency
000000r 1               AUDC2	EQU	$D203	;channel 2 audio control
000000r 1               
000000r 1               AUDF3	EQU	$D204	;channel 3 audio frequency
000000r 1               AUDC3	EQU	$D205	;channel 3 audio control
000000r 1               
000000r 1               AUDF4	EQU	$D206	;channel 4 audio frequency
000000r 1               AUDC4	EQU	$D207	;channel 4 audio control
000000r 1               
000000r 1               AUDCTL	EQU	$D208	;audio control
000000r 1               STIMER	EQU	$D209	;start timers
000000r 1               SKRES	EQU	$D20A	;reset SKSTAT status
000000r 1               POTGO	EQU	$D20B	;start potentiometer scan sequence
000000r 1               SEROUT	EQU	$D20D	;serial port output
000000r 1               IRQEN	EQU	$D20E	;IRQ interrupt enable
000000r 1               SKCTL	EQU	$D20F	;serial port and keyboard control
000000r 1               ;	SPACE	4,10
000000r 1               ;**	PIA Address Equates
000000r 1               
000000r 1               
000000r 1               PIA	EQU	$D300	;PIA area
000000r 1               
000000r 1               ;	Read/Write Addresses
000000r 1               
000000r 1               PORTA	EQU	$D300	;port A direction register or jacks 0 and 1
000000r 1               PORTB	EQU	$D301	;port B direction register or memory control
000000r 1               
000000r 1               PACTL	EQU	$D302	;port A control
000000r 1               PBCTL	EQU	$D303	;port B control
000000r 1               ;	SPACE	4,10
000000r 1               ;**	ANTIC Address Equates
000000r 1               
000000r 1               
000000r 1               ANTIC	EQU	$D400	;ANTIC area
000000r 1               
000000r 1               ;	Read Addresses
000000r 1               
000000r 1               VCOUNT	EQU	$D40B	;vertical line counter
000000r 1               PENH	EQU	$D40C	;light pen horizontal position
000000r 1               PENV	EQU	$D40D	;light pen vertical position
000000r 1               NMIST	EQU	$D40F	;NMI interrupt status
000000r 1               
000000r 1               ;	Write Addresses
000000r 1               
000000r 1               DMACTL	EQU	$D400	;DMA control
000000r 1               CHACTL	EQU	$D401	;character control
000000r 1               DLISTL	EQU	$D402	;low display list address
000000r 1               DLISTH	EQU	$D403	;high disply list address
000000r 1               HSCROL	EQU	$D404	;horizontal scroll
000000r 1               VSCROL	EQU	$D405	;vertical scroll
000000r 1               PMBASE	EQU	$D407	;player-missle base address
000000r 1               CHBASE	EQU	$D409	;character base address
000000r 1               WSYNC	EQU	$D40A	;wait for HBLANK synchronization
000000r 1               NMIEN	EQU	$D40E	;NMI enable
000000r 1               NMIRES	EQU	$D40F	;NMI interrupt status reset
000000r 1               ;	SPACE	4,10
000000r 1               ;**	PBI RAM Address Equates
000000r 1               
000000r 1               
000000r 1               PBIRAM	EQU	$D600	;parallel bus interface RAM area
000000r 1               ;	SPACE	4,10
000000r 1               ;**	ACMI Address Equates
000000r 1               
000000r 1               
000000r 1               	IF	ACMI
000000r 1               	ENDIF	;ACMI
000000r 1               ;	SPACE	4,10
000000r 1               ;**	Floating Point Package Address Equates
000000r 1               
000000r 1               
000000r 1               AFP	EQU	$D800	;convert ASCII to floating point
000000r 1               FASC	EQU	$D8E6	;convert floating point to ASCII
000000r 1               IFP	EQU	$D9AA	;convert integer to floating point
000000r 1               FPI	EQU	$D9D2	;convert floating point to integer
000000r 1               ZFR0	EQU	$DA44	;zero FR0
000000r 1               ZF1	EQU	$DA46	;zero floating point number
000000r 1               FSUB	EQU	$DA60	;subtract floating point numbers
000000r 1               FADD	EQU	$DA66	;add floating point numbers
000000r 1               FMUL	EQU	$DADB	;multiply floating point numbers
000000r 1               FDIV	EQU	$DB28	;divide floating point numbers
000000r 1               PLYEVL	EQU	$DD40	;evaluate floating point polynomial
000000r 1               FLD0R	EQU	$DD89	;load floating point number
000000r 1               FLD0P	EQU	$DD8D	;load floating point number
000000r 1               FLD1R	EQU	$DD98	;load floating point number
000000r 1               FLD1P	EQU	$DD9C	;load floating point number
000000r 1               FST0R	EQU	$DDA7	;store floating point number
000000r 1               FST0P	EQU	$DDAB	;store floating point number
000000r 1               FMOVE	EQU	$DDB6	;move floating point number
000000r 1               LOG	EQU	$DECD	;calculate floating point logarithm
000000r 1               LOG10	EQU	$DED1	;calculate floating point base 10 logarithm
000000r 1               EXP	EQU	$DDC0	;calculate floating point exponentiation
000000r 1               EXP10	EQU	$DDCC	;calculate floating point base 10 exponentiation
000000r 1               ;	SPACE	4,10
000000r 1               ;**	Parallel Device Address Equates
000000r 1               
000000r 1               
000000r 1               PDID1	EQU	$D803	;parallel device ID 1
000000r 1               PDIOV	EQU	$D805	;parallel device I/O vector
000000r 1               PDIRQV	EQU	$D808	;parallel device IRQ vector
000000r 1               PDID2	EQU	$D80B	;parallel device ID 2
000000r 1               PDVV	EQU	$D80D	;parallel device vector table
000000r 1               ;	SPACE	4,10
000000r 1               ;**	Device Handler Vector Table Address Equates
000000r 1               
000000r 1               
000000r 1               EDITRV	EQU	$E400	;editor handler vector table
000000r 1               SCRENV	EQU	$E410	;screen handler vector table
000000r 1               KEYBDV	EQU	$E420	;keyboard handler vector table
000000r 1               PRINTV	EQU	$E430	;printer handler vector table
000000r 1               CASETV	EQU	$E440	;cassette handler vector table
000000r 1               ;	SPACE	4,10
000000r 1               ;**	Jump Vector Address Equates
000000r 1               
000000r 1               
000000r 1               DINITV	EQU	$E450	;vector to initialize DIO
000000r 1               DSKINV	EQU	$E453	;vector to DIO
000000r 1               CIOV	EQU	$E456	;vector to CIO
000000r 1               SIOV	EQU	$E459	;vector to SIO
000000r 1               SETVBV	EQU	$E45C	;vector to set VBLANK parameters
000000r 1               SYSVBV	EQU	$E45F	;vector to process immediate VBLANK NMI
000000r 1               XITVBV	EQU	$E462	;vector to process deferred VBLANK NMI
000000r 1               SIOINV	EQU	$E465	;vector to initialize SIO
000000r 1               SENDEV	EQU	$E468	;vector to enable SEND
000000r 1               INTINV	EQU	$E46B	;vector to initialize interrupt handler
000000r 1               CIOINV	EQU	$E46E	;vector to initialize CIO
000000r 1               BLKBDV	EQU	$E471	;vector to power-up display (formerly memo pad)
000000r 1               WARMSV	EQU	$E474	;vector to warmstart
000000r 1               COLDSV	EQU	$E477	;vector to coldstart
000000r 1               RBLOKV	EQU	$E47A	;vector to read cassette block
000000r 1               CSOPIV	EQU	$E47D	;vector to open cassette for input
000000r 1               PUPDIV	EQU	$E480	;vector to power-up display
000000r 1               SLFTSV	EQU	$E483	;vector to self-test
000000r 1               PHENTV	EQU	$E486	;vector to enter peripheral handler
000000r 1               PHUNLV	EQU	$E489	;vector to unlink peripheral handler
000000r 1               PHINIV	EQU	$E48C	;vector to initialize peripheral handler
000000r 1               ;	SPACE	4,10
000000r 1               ;**	Generic Parallel Device Handler Vector Table Address Equates
000000r 1               
000000r 1               
000000r 1               GPDVV	EQU	$E48F	;generic parallel device handler vector table
000000r 1               ;	SUBTTL	'Miscellaneous Address Equates'
000000r 1               ;	SPACE	4,10
000000r 1               ;**	Self-test Page Zero Address Equates
000000r 1               
000000r 1               
000000r 1               STTIME	EQU	$0080	;2-byte main screen timeout timer
000000r 1               STAUT	EQU	$0082	;1-byte auto-mode flag
000000r 1               STJMP	EQU	$0083	;3-byte ANTIC jump instruction
000000r 1               STSEL	EQU	$0086	;1-byte selection
000000r 1               STPASS	EQU	$0087	;1-byte pass
000000r 1               STSPP	EQU	$0088	;1-byte SELECT previously pressed flag
000000r 1               ;	EQU	$0089	;1-byte (not used)
000000r 1               STKST	EQU	$008A	;1-byte keyboard self-test flag (0 = not)
000000r 1               STCHK	EQU	$008B	;2-byte checksum
000000r 1               STSMM	EQU	$008D	;1-byte screen memory mask
000000r 1               STSMP	EQU	$008E	;1-byte screen memory pointer
000000r 1               ST1K	EQU	$008F	;1-byte current 1K of memory to test
000000r 1               STPAG	EQU	$0090	;2-byte current page to test
000000r 1               STPC	EQU	$0092	;1-byte page count
000000r 1               STMVAL	EQU	$0093	;1-byte correct value for memory test
000000r 1               STSKP	EQU	$0094	;1-byte simulated keypress index
000000r 1               STTMP1	EQU	$0095	;2-byte temporary
000000r 1               STVOC	EQU	$0097	;1-byte current voice indicator
000000r 1               STNOT	EQU	$0098	;1-byte current note counter
000000r 1               STCDI	EQU	$0099	;1-byte cleft display pointer
000000r 1               STCDA	EQU	$009A	;1-byte cleft data pointer
000000r 1               STTMP2	EQU	$009B	;2-byte temporary
000000r 1               STTMP3	EQU	$009D	;1-byte temporary
000000r 1               STADR1	EQU	$009E	;2-byte temporary address
000000r 1               STADR2	EQU	$00A0	;2-byte temporary address
000000r 1               STBL	EQU	$00A2	;1-byte blink counter
000000r 1               STTMP4	EQU	$00A3	;1-byte temporary
000000r 1               STLM	EQU	$00A4	;1-byte LED mask
000000r 1               STTMP5	EQU	$00A5	;1-byte temporary
000000r 1               ;	SPACE	4,10
000000r 1               ;**	Self-test Address Equates
000000r 1               
000000r 1               
000000r 1               ST3000	EQU	$3000	;screen memory
000000r 1               ST3002	EQU	$3002	;cleft display
000000r 1               ST3004	EQU	$3004	;"VOICE #" text display
000000r 1               ST300B	EQU	$300B	;voice number display
000000r 1               ST301C	EQU	$301C	;START key display
000000r 1               ST301E	EQU	$301E	;SELECT key display
000000r 1               ST3020	EQU	$3020	;OPTION key display, first 8K ROM display
000000r 1               ST3021	EQU	$3021	;keyboard character display
000000r 1               ST3022	EQU	$3022	;keyboard text display
000000r 1               ST3024	EQU	$3024	;second 8K ROM display
000000r 1               ST3028	EQU	$3028	;"RAM" text display
000000r 1               ST3038	EQU	$3038	;RAM display
000000r 1               ST303C	EQU	$303C	;fifth note display
000000r 1               ST304C	EQU	$304C	;"B S" text display
000000r 1               ST3052	EQU	$3052	;tab key display
000000r 1               ST3062	EQU	$3062	;cleft display
000000r 1               ST306D	EQU	$306D	;return key display
000000r 1               ST3072	EQU	$3072	;control key display
000000r 1               ST3092	EQU	$3092	;"SH" text display
000000r 1               ST309E	EQU	$309E	;sixth note display
000000r 1               ST30AB	EQU	$30AB	;"SH" text display
000000r 1               ST30B7	EQU	$30B7	;"S P A C E   B A R" text display
000000r 1               ST30C1	EQU	$30C1	;cleft display
000000r 1               ST30C2	EQU	$30C2	;cleft display
000000r 1               ST30C7	EQU	$30C7	;third note display
000000r 1               ST30CA	EQU	$30CA	;fourth note display
000000r 1               ST30F8	EQU	$30F8	;third note display
000000r 1               ST3100	EQU	$3100	;screen memory
000000r 1               ST3121	EQU	$3121	;cleft display
000000r 1               ST3122	EQU	$3122	;cleft display
000000r 1               ST313C	EQU	$313C	;fifth note display
000000r 1               ST3150	EQU	$3150	;first line of staff display
000000r 1               ST3154	EQU	$3154	;first note display
000000r 1               ST3181	EQU	$3181	;cleft display
000000r 1               ST3182	EQU	$3182	;cleft display
000000r 1               ST3186	EQU	$3186	;second note display
000000r 1               ST318C	EQU	$318C	;fifth note display
000000r 1               ST31B0	EQU	$31B0	;second line of staff display
000000r 1               ST31C2	EQU	$31C2	;cleft display
000000r 1               ST31CA	EQU	$31CA	;fourth note display
000000r 1               ST31EE	EQU	$31EE	;sixth note display
000000r 1               ST31F1	EQU	$31F1	;cleft display
000000r 1               ST3210	EQU	$3210	;third line of staff display
000000r 1               ST321A	EQU	$321A	;fourth note display
000000r 1               ST3248	EQU	$3248	;third note display
000000r 1               ST3270	EQU	$3270	;fourth line of staff display
000000r 1               ST32D0	EQU	$32D0	;fifth line of staff display
000000r 1               ;	SUBTTL	'Macro Definitions'
000000r 1               ;	SPACE	4,10
000000r 1               ;**	FIX - Fix Address
000000r 1               ;*
000000r 1               ;*	FIX sets the origin counter to the value specified as an
000000r 1               ;*	argument.  If the current origin counter is less than the
000000r 1               ;*	argument, FIX fills the intervening bytes with zero and
000000r 1               ;*	issues a message to document the location and number of
000000r 1               ;*	bytes that are zero filled.
000000r 1               ;*
000000r 1               ;*	ENTRY	FIX	address
000000r 1               ;*
000000r 1               ;*
000000r 1               ;*	EXIT
000000r 1               ;*		Origin counter set to specified address.
000000r 1               ;*		Message issued if zero fill required.
000000r 1               ;*
000000r 1               ;*	CHANGES
000000r 1               ;*		-none-
000000r 1               ;*
000000r 1               ;*	CALLS
000000r 1               ;*		-none-
000000r 1               ;*
000000r 1               ;*	NOTES
000000r 1               ;*		Due to ECHO limitiation of 255 iterations, FIX is
000000r 1               ;*		recursive.
000000r 1               ;*		If the current origin counter value is beyond the
000000r 1               ;*		argument, FIX generates an error.
000000r 1               ;*
000000r 1               ;*	MODS
000000r 1               ;*		R. K. Nordin	11/01/83
000000r 1               
000000r 1               
000000r 1               .macro	FIX	address
000000r 1               	.if	* > address
000000r 1               	.error	.sprintf("$%04x precedes current origin counter of $%04x", address, *)
000000r 1               	.elseif * < address
000000r 1               	.out	.sprintf("$%04x free bytes from $%04x to $%04x", address-*, *, address-1)
000000r 1               	.res	address-*, $00
000000r 1               	.endif
000000r 1               .endmacro
000000r 1               ;	SUBTTL	'First 8K ROM Identification and Checksum'
000000r 1               ;	SPACE	4,10
000000r 1               	ORG	$C000
00C000  1               ;	SPACE	4,10
00C000  1               ;**	First 8K ROM Identification and Checksum
00C000  1               
00C000  1               
00C000  1  00 00 10 05  	DW	$0000				;reserved for checksum
00C004  1  83 00 42 42  
00C008  1  00 00 01 02  
00C00C  1               	DB	IDDAY,IDMON,IDYEAR		;date (day, month, year)
00C00C  1               	DB	$00				;not used
00C00C  1               	DB	IDPN1,IDPN2,IDPN3,IDPN4,IDPN5	;part number
00C00C  1               	DB	IDREV				;revision number
00C00C  1               ;	SUBTTL	'Interrupt Handler'
00C00C  1               ;	SPACE	4,10
00C00C  1               ;**	IIH - Initialize Interrupt Handler
00C00C  1               ;*
00C00C  1               ;*	ENTRY	JSR	IIH
00C00C  1               ;*		TRIG3 = ACMI module interlock
00C00C  1               ;*		TRIG2 = cartridge interlock
00C00C  1               ;*
00C00C  1               ;*	MODS
00C00C  1               ;*		Original Author Unknown
00C00C  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C00C  1               ;*		   R. K. Nordin	11/01/83
00C00C  1               
00C00C  1               
00C00C  1               IIH	=	*	;entry
00C00C  1               
00C00C  1  A9 40        	LDA	#$40
00C00E  1  8D 0E D4     	STA	NMIEN	;disable DLI and enable VBLANK NMI
00C011  1               
00C011  1  AD 13 D0     	LDA	TRIG3	;cartridge interlock
00C014  1  8D FA 03     	STA	GINTLK	;cartridge interlock status
00C017  1               
00C017  1               	IF	ACMI
00C017  1               	ENDIF	;ACMI
00C017  1               
00C017  1  60           	RTS		;return
00C018  1               ;	SPACE	4,10
00C018  1               ;**	NMI - Process NMI
00C018  1               ;*
00C018  1               ;*	ENTRY	JMP	NMI
00C018  1               ;*
00C018  1               ;*	EXIT
00C018  1               ;*		Exits via appropriate vector to process NMI
00C018  1               ;*
00C018  1               ;*	MODS
00C018  1               ;*		Original Author Unknown
00C018  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C018  1               ;*		   R. K. Nordin	11/01/83
00C018  1               
00C018  1               
00C018  1               NMI	=	*	;entry
00C018  1               
00C018  1               	ASSERT	$C0=high NMI	;for compatibility with LNBUG
00C018  1               
00C018  1               ;	Check for display list NMI.
00C018  1               
00C018  1  2C 0F D4     	BIT	NMIST
00C01B  1  10 03        	BPL	NMI1		;if not display list NMI
00C01D  1               
00C01D  1  6C 00 02     	JMP	(VDSLST)	;process display list NMI, return
00C020  1               
00C020  1               ;	Initialize.
00C020  1               
00C020  1  D8           NMI1	CLD
00C021  1               
00C021  1               ;	Save registers.
00C021  1               
00C021  1  48           	PHA		;save A
00C022  1  8A           	TXA
00C023  1  48           	PHA		;save X
00C024  1  98           	TYA
00C025  1  48           	PHA		;save Y
00C026  1               
00C026  1               ;	Reset NMI status.
00C026  1               
00C026  1  8D 0F D4     	STA	NMIRES		;reset NMI status
00C029  1               
00C029  1               ;	Process NMI.
00C029  1               
00C029  1               	IF	LNBUG
00C029  1               	LDA	LNFLG		;LNBUG flag
00C029  1               	BNE	NMI2		;if LNBUG
00C029  1               
00C029  1               	JMP	(VVBLKI)	;process immediate VBLANK NMI, return
00C029  1               
00C029  1               NMI2	JMP	(LNNMI)		;invoke LNBUG NMI routine, return
00C029  1               	ELSE	;LNBUG
00C029  1  6C 22 02     	JMP	(VVBLKI)	;process immediate VBLANK NMI, return
00C02C  1               	ENDIF	;LNBUG
00C02C  1               ;	SPACE	4,10
00C02C  1               ;**	IRQ - Process IRQ
00C02C  1               ;*
00C02C  1               ;*	ENTRY	JMP	IRQ
00C02C  1               ;*
00C02C  1               ;*	EXIT
00C02C  1               ;*		Exits via VIMIRQ vector
00C02C  1               ;*
00C02C  1               ;*	MODS
00C02C  1               ;*		Original Author Unknown
00C02C  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C02C  1               ;*		   R. K. Nordin	11/01/83
00C02C  1               
00C02C  1               
00C02C  1               IRQ	=	*		;entry
00C02C  1               
00C02C  1               ;	Initialize.
00C02C  1               
00C02C  1  D8           	CLD
00C02D  1               
00C02D  1               ;	Process IRQ.
00C02D  1               
00C02D  1               	IF	LNBUG
00C02D  1               	BIT	LNFLG
00C02D  1               	BMI	IRQ1		;if LNBUG on
00C02D  1               
00C02D  1               	JMP	(VIMIRQ)	;process immediate IRQ, return
00C02D  1               
00C02D  1               IRQ1	JMP	LNIRQ		;invoke LNBUG IRQ routine, return
00C02D  1               	ELSE	;LNBUG
00C02D  1  6C 16 02     	JMP	(VIMIRQ)	;process immediate IRQ, return
00C030  1               	ENDIF	;LNBUG
00C030  1               ;	SPACE	4,10
00C030  1               ;**	IIR - Process Immediate IRQ
00C030  1               ;*
00C030  1               ;*	ENTRY	JMP	IIR
00C030  1               ;*
00C030  1               ;*	EXIT
00C030  1               ;*		Exits via appropriate vector to process IRQ
00C030  1               ;*
00C030  1               ;*	MODS
00C030  1               ;*		Original Author Unknown
00C030  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C030  1               ;*		   R. K. Nordin	11/01/83
00C030  1               
00C030  1               
00C030  1               IIR	=	*	;entry
00C030  1               
00C030  1               ;	Initialize.
00C030  1               
00C030  1  48           	PHA		;save A
00C031  1               
00C031  1               ;	Check for serial input ready IRQ.
00C031  1               
00C031  1  AD 0E D2     	LDA	IRQST	;IRQ status
00C034  1  29 20        	AND	#$20	;serial input ready
00C036  1  D0 0D        	BNE	IIR1	;if not serial input ready
00C038  1               
00C038  1               ;	Process serial input IRQ.
00C038  1               
00C038  1  A9 DF        	LDA	#not $20	;all other interrupts
00C03A  1  8D 0E D2     	STA	IRQEN		;enable all other interrupts
00C03D  1  A5 10        	LDA	POKMSK
00C03F  1  8D 0E D2     	STA	IRQEN
00C042  1  6C 0A 02     	JMP	(VSERIN)	;process serial input ready IRQ, return
00C045  1               
00C045  1               ;	Process possible ACMI IRQ.
00C045  1               
00C045  1               IIR1
00C045  1               	IF	ACMI
00C045  1               	ENDIF	;ACMI
00C045  1               
00C045  1               ;	Initialize further.
00C045  1               
00C045  1  8A           	TXA
00C046  1  48           	PHA		;save X
00C047  1               
00C047  1               ;	Check for parallel device IRQ.
00C047  1               
00C047  1  AD FF D1     	LDA	PDVI		;parallel device IRQ statuses
00C04A  1  2D 49 02     	AND	PDIMSK		;select desired IRQ statuses
00C04D  1  F0 03        	BEQ	IIR2		;if no desired IRQ
00C04F  1               
00C04F  1               ;	Process parallel device IRQ.
00C04F  1               
00C04F  1  6C 38 02     	JMP	(VPIRQ)		;process parallel device IR:
00C052  1               
00C052  1               ;	Check other types of IRQ.
00C052  1               
00C052  1  A2 06        IIR2	LDX	#TIRQL-1-1	;offset to next to last entry
00C054  1               
00C054  1  BD CF C0     IIR3	LDA	TIRQ,X		;IRQ type
00C057  1  E0 05        	CPX	#5		;offset to serial out complete
00C059  1  D0 04        	BNE	IIR4		;if not serial out complete
00C05B  1               
00C05B  1  25 10        	AND	POKMSK		;and with POKEY IRQ enable
00C05D  1  F0 05        	BEQ	IIR5		;if serial out complete not enabled
00C05F  1               
00C05F  1  2C 0E D2     IIR4	BIT	IRQST		;IRQ interrupt status
00C062  1  F0 06        	BEQ	IIR6		;if interrupt found
00C064  1               
00C064  1  CA           IIR5	DEX
00C065  1  10 ED        	BPL	IIR3		;if not done
00C067  1               
00C067  1               ;	Coninue IRQ processing.
00C067  1               
00C067  1  4C A0 C0     	JMP	CIR		;continue IRQ processing, return
00C06A  1               
00C06A  1               ;	Enable other interrupts.
00C06A  1               
00C06A  1  49 FF        IIR6	EOR	#$FF		;complement mask
00C06C  1  8D 0E D2     	STA	IRQEN		;enable all others
00C06F  1  A5 10        	LDA	POKMSK		;POKEY IRQ mask
00C071  1  8D 0E D2     	STA	IRQEN		;enable indicated IRQ's
00C074  1               
00C074  1               ;	Check for BREAK key IRQ.
00C074  1               
00C074  1  E0 00        	CPX	#0
00C076  1  D0 05        	BNE	IIR7		;if not BREAK key IRQ
00C078  1               
00C078  1               ;	Check for keyboard disabled.
00C078  1               
00C078  1  AD 6D 02     	LDA	KEYDIS
00C07B  1  D0 23        	BNE	CIR		;if keyboard disabled, cont:
00C07D  1               
00C07D  1               ;	Process IRQ.
00C07D  1               
00C07D  1  BD D7 C0     IIR7	LDA	TOIH,X		;offset to interrupt handler
00C080  1  AA           	TAX
00C081  1  BD 00 02     	LDA	INTABS,X	;interrupt handler address
00C084  1  8D 8C 02     	STA	JVECK
00C087  1  BD 01 02     	LDA	INTABS+1,X
00C08A  1  8D 8D 02     	STA	JVECK+1
00C08D  1  68           	PLA
00C08E  1  AA           	TAX			;restore X
00C08F  1  6C 8C 02     	JMP	(JVECK)		;process interrupt, return
00C092  1               ;	SPACE	4,10
00C092  1               ;**	BIR - Process BREAK Key IRQ
00C092  1               ;*
00C092  1               ;*	ENTRY	JMP	BIR
00C092  1               ;*
00C092  1               ;*	EXIT
00C092  1               ;*		Exits via RTI
00C092  1               ;*
00C092  1               ;*	MODS
00C092  1               ;*		Original Author Unknown
00C092  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C092  1               ;*		   R. K. Nordin	11/01/83
00C092  1               
00C092  1               
00C092  1               BIR	=	*	;entry
00C092  1               
00C092  1               ;	Process BREAK.
00C092  1               
00C092  1  A9 00        	LDA	#0
00C094  1  85 11        	STA	BRKKEY	;clear BREAK key flag
00C096  1  8D FF 02     	STA	SSFLAG	;clear start/stop flag
00C099  1  8D F0 02     	STA	CRSINH	;enable cursor
00C09C  1  85 4D        	STA	ATRACT	;turn off attract-mode
00C09E  1               
00C09E  1               ;	Exit.
00C09E  1               
00C09E  1  68           BIR1	PLA		;restore A
00C09F  1  40           	RTI		;return
00C0A0  1               ;	SPACE	4,10
00C0A0  1               ;**	CIR - Continue IRQ Processing
00C0A0  1               ;*
00C0A0  1               ;*	ENTRY	JMP	CIR
00C0A0  1               ;*
00C0A0  1               ;*	EXIT
00C0A0  1               ;*		Exits via appropriate vector to process IRQ or to XIR
00C0A0  1               ;*
00C0A0  1               ;*	MODS
00C0A0  1               ;*		Original Author Unknown
00C0A0  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C0A0  1               ;*		   R. K. Nordin	11/01/83
00C0A0  1               
00C0A0  1               
00C0A0  1               CIR	=	*		;entry
00C0A0  1               
00C0A0  1               ;	Initialize.
00C0A0  1               
00C0A0  1  68           	PLA			;saved ???
00C0A1  1  AA           	TAX
00C0A2  1               
00C0A2  1               ;	Check for port A interrupt.
00C0A2  1               
00C0A2  1  2C 02 D3     	BIT	PACTL		;port A control
00C0A5  1  10 06        	BPL	CIR1		;if not port A interrupt
00C0A7  1               
00C0A7  1               ;	Process proceed line IRQ.
00C0A7  1               
00C0A7  1  AD 00 D3     	LDA	PORTA		;clear interrupt status bit
00C0AA  1  6C 02 02     	JMP	(VPRCED)	;process proceed line IRQ, return
00C0AD  1               
00C0AD  1               ;	Check for port B interrupt.
00C0AD  1               
00C0AD  1  2C 03 D3     CIR1	BIT	PBCTL		;port B control
00C0B0  1  10 06        	BPL	CIR2		;if not port B interrupt
00C0B2  1               
00C0B2  1               ;	Process interrupt line IRQ.
00C0B2  1               
00C0B2  1  AD 01 D3     	LDA	PORTB		;clear interrupt status bit
00C0B5  1  6C 04 02     	JMP	(VINTER)	;process interrupt line IRQ, return
00C0B8  1               
00C0B8  1               ;	Check for BRK instruction IRQ.
00C0B8  1               
00C0B8  1  68           CIR2	PLA
00C0B9  1  8D 8C 02     	STA	JVECK
00C0BC  1               
00C0BC  1  68           	PLA			;saved P
00C0BD  1  48           	PHA			;resave P
00C0BE  1  29 10        	AND	#$10		;B bit of P register
00C0C0  1  F0 07        	BEQ	CIR3		;if not BRK instruction IRQ
00C0C2  1               
00C0C2  1               ;	Process BRK instruction IRQ.
00C0C2  1               
00C0C2  1  AD 8C 02     	LDA	JVECK
00C0C5  1  48           	PHA
00C0C6  1  6C 06 02     	JMP	(VBREAK)	;process BRK instruction IRQ, return
00C0C9  1               
00C0C9  1               ;	Exit IRQ processing.
00C0C9  1               
00C0C9  1  AD 8C 02     CIR3	LDA	JVECK
00C0CC  1  48           	PHA
00C0CD  1               ;	JMP	XIR		;exit IRQ processing, return
00C0CD  1               ;	SPACE	4,10
00C0CD  1               ;**	XIR - Exit IRQ Processing
00C0CD  1               ;*
00C0CD  1               ;*	ENTRY	JMP	XIR
00C0CD  1               ;*
00C0CD  1               ;*	EXIT
00C0CD  1               ;*		Exits to RIR
00C0CD  1               ;*
00C0CD  1               ;*	MODS
00C0CD  1               ;*		Original Author Unknown
00C0CD  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C0CD  1               ;*		   R. K. Nordin	11/01/83
00C0CD  1               
00C0CD  1               
00C0CD  1               XIR	=	*	;entry
00C0CD  1  68           	PLA		;restore A
00C0CE  1               ;	JMP	RIR	;return from interrupt
00C0CE  1               ;	SPACE	4,10
00C0CE  1               ;**	RIR - Return from Interrupt
00C0CE  1               ;*
00C0CE  1               ;*	ENTRY	JMP	RIR
00C0CE  1               ;*
00C0CE  1               ;*	EXIT
00C0CE  1               ;*		Exits via RTI
00C0CE  1               ;*
00C0CE  1               ;*	MODS
00C0CE  1               ;*		Original Author Unknown
00C0CE  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C0CE  1               ;*		   R. K. Nordin	11/01/83
00C0CE  1               
00C0CE  1               
00C0CE  1               RIR	=	*	;entry
00C0CE  1  40           	RTI		;return
00C0CF  1               ;	SPACE	4,10
00C0CF  1               ;**	AIR - Process ACMI IRQ
00C0CF  1               ;*
00C0CF  1               ;*	ENTRY	JMP	AIR
00C0CF  1               ;*
00C0CF  1               ;*	EXIT	Exits via ASMISR vector
00C0CF  1               ;*
00C0CF  1               ;*	MODS
00C0CF  1               ;*		Original Author Unknown
00C0CF  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C0CF  1               ;*		   R. K. Nordin	11/01/83
00C0CF  1               
00C0CF  1               
00C0CF  1               	IF	ACMI
00C0CF  1               	ENDIF	;ACMI
00C0CF  1               ;	SPACE	4,10
00C0CF  1               ;**	TIRQ - Table of IRQ Types
00C0CF  1               ;*
00C0CF  1               ;*	Entry n is the interrupt indicator of priority n (0 is lowest).
00C0CF  1               ;*
00C0CF  1               ;*	NOTES
00C0CF  1               ;*		Problem: entry 7 (serial input ready) not used.
00C0CF  1               
00C0CF  1               
00C0CF  1  80 40 04 02  TIRQ	DB	$80	;0 - BREAK key IRQ
00C0D3  1  01 08 10 20  
00C0D7  1               	DB	$40	;1 - keyboard IRQ
00C0D7  1               	DB	$04	;2 - timer 4 IRQ
00C0D7  1               	DB	$02	;3 - timer 2 IRQ
00C0D7  1               	DB	$01	;4 - timer 1 IRQ
00C0D7  1               	DB	$08	;5 - serial output complete IRQ
00C0D7  1               	DB	$10	;6 - serial output ready IRQ
00C0D7  1               	DB	$20	;7 - serial input ready IRQ
00C0D7  1               
00C0D7  1               TIRQL	=	*-TIRQ	;length
00C0D7  1               ;	SPACE	4,10
00C0D7  1               ;**	TOIH - Table of Offsets to Interrupt Handlers
00C0D7  1               ;*
00C0D7  1               ;*	Entry n is the offset to the interrupt handler vector
00C0D7  1               ;*	corresponding to entry n of TIRQ.
00C0D7  1               ;*
00C0D7  1               ;*	NOTES
00C0D7  1               ;*		Problem: entry 7 (serial input ready) not used.
00C0D7  1               
00C0D7  1               
00C0D7  1  36 08 14 12  TOIH	DB	BRKKY-INTABS	;0 - BREAK key IRQ
00C0DB  1  10 0E 0C 0A  
00C0DF  1               	DB	VKEYBD-INTABS	;1 - keyboard IRQ
00C0DF  1               	DB	VTIMR4-INTABS	;2 - timer 4 IRQ
00C0DF  1               	DB	VTIMR2-INTABS	;3 - timer 2 IRQ
00C0DF  1               	DB	VTIMR1-INTABS	;4 - timer 1 IRQ
00C0DF  1               	DB	VSEROC-INTABS	;5 - serial output complete IRQ
00C0DF  1               	DB	VSEROR-INTABS	;6 - serial output ready IRQ
00C0DF  1               	DB	VSERIN-INTABS	;7 - serial input ready IRQ
00C0DF  1               ;	SPACE	4,10
00C0DF  1               ;**	WFR - Wait for RESET
00C0DF  1               ;*
00C0DF  1               ;*	WFR loops forever.
00C0DF  1               ;*
00C0DF  1               ;*	ENTRY	JMP	WFR
00C0DF  1               ;*
00C0DF  1               ;*	EXIT
00C0DF  1               ;*		Does not exit
00C0DF  1               ;*
00C0DF  1               ;*	MODS
00C0DF  1               ;*		Original Author Unknown
00C0DF  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C0DF  1               ;*		   R. K. Nordin	11/01/83
00C0DF  1               
00C0DF  1               
00C0DF  1               WFR	=	*	;entry
00C0DF  1               
00C0DF  1               ;	Loop forever, waiting for RESET.
00C0DF  1               
00C0DF  1  4C DF C0     WFR1	JMP	WFR1	;loop
00C0E2  1               ;	SPACE	4,10
00C0E2  1               ;**	IVNM - Process Immediate VBLANK NMI
00C0E2  1               ;*
00C0E2  1               ;*	ENTRY	JMP	IVNM
00C0E2  1               ;*
00C0E2  1               ;*	EXIT
00C0E2  1               ;*		Exits to DVNM or via VVBLKD vector
00C0E2  1               ;*
00C0E2  1               ;*	MODS
00C0E2  1               ;*		Original Author Unknown
00C0E2  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C0E2  1               ;*		   R. K. Nordin	11/01/83
00C0E2  1               
00C0E2  1               
00C0E2  1               IVNM	=	*		;entry
00C0E2  1               
00C0E2  1               ;	Increment frame counter and attract-mode counter.
00C0E2  1               
00C0E2  1  E6 14        	INC	RTCLOK+2	;increment low frame counter
00C0E4  1  D0 08        	BNE	IVN1		;if low counter not zero
00C0E6  1               
00C0E6  1  E6 4D        	INC	ATRACT		;increment attract-mode counter/flag
00C0E8  1  E6 13        	INC	RTCLOK+1	;increment middle frame counter
00C0EA  1  D0 02        	BNE	IVN1		;if middle counter not zero
00C0EC  1               
00C0EC  1  E6 12        	INC	RTCLOK		;increment high frame counter
00C0EE  1               
00C0EE  1               ;	Set attract-mode effects.
00C0EE  1               
00C0EE  1  A9 FE        IVN1	LDA	#$FE		;select no luminance change
00C0F0  1  A2 00        	LDX	#0		;select no color shift
00C0F2  1  A4 4D        	LDY	ATRACT		;attract-mode timer/flag
00C0F4  1  10 06        	BPL	IVN2		;if not attract-mode
00C0F6  1               
00C0F6  1  85 4D        	STA	ATRACT		;ensure continued attract-mode
00C0F8  1  A6 13        	LDX	RTCLOK+1	;select color shift
00C0FA  1  A9 F6        	LDA	#$F6		;select lower luminance
00C0FC  1               
00C0FC  1  85 4E        IVN2	STA	DRKMSK		;attract-mode luminance
00C0FE  1  86 4F        	STX	COLRSH		;attract-mode color shift
00C100  1               
00C100  1               ;	Update COLPF1 (in case fine scrolling and critical :
00C100  1               
00C100  1  AD C5 02     	LDA	COLOR1		;playfield 1 color
00C103  1  45 4F        	EOR	COLRSH		;modify color with attract-:
00C105  1  25 4E        	AND	DRKMSK		;modify with attract-mode l:
00C107  1  8D 17 D0     	STA	COLPF1		;set playfield 1 color/lumi:
00C10A  1               
00C10A  1               ;	Process countdown timer 1.
00C10A  1               
00C10A  1  A2 00        	LDX	#0		;indicate countdown timer 1
00C10C  1  20 55 C2     	JSR	DCT		;decrement countdown timer
00C10F  1  D0 03        	BNE	IVN3		;if timer not expired
00C111  1               
00C111  1  20 4F C2     	JSR	PTO		;process countdown timer 1 expiration
00C114  1               
00C114  1               ;	Check for critical sction.
00C114  1               
00C114  1  A5 42        IVN3	LDA	CRITIC
00C116  1  D0 08        	BNE	IVN4		;if critical section
00C118  1               
00C118  1               ;	Check for IRQ enabled.
00C118  1               
00C118  1  BA           	TSX			;stack pointer
00C119  1  BD 04 01     	LDA	$0104,X		;stacked P
00C11C  1  29 04        	AND	#$04		;I (IRQ disable) bit
00C11E  1  F0 03        	BEQ	IVN5		;if IRQ enabled
00C120  1               
00C120  1               ;	Exit.
00C120  1               
00C120  1  4C 8A C2     IVN4	JMP	DVNM		;process deferred VBLANK NMI, return
00C123  1               
00C123  1               ;	Process IRQ enabled non-critical section.
00C123  1               
00C123  1               IVN5
00C123  1               
00C123  1               ;	Check for ACMI module change.
00C123  1               
00C123  1               	IF	ACMI
00C123  1               	ENDIF	;ACMI
00C123  1               
00C123  1               ;	Check for cartridge change.
00C123  1               
00C123  1  AD 13 D0     	LDA	TRIG3		;cartridge interlock
00C126  1  CD FA 03     	CMP	GINTLK		;previous cartridge interlock status
00C129  1  D0 B4        	BNE	WFR		;if cartridge change, wait for RESET
00C12B  1               
00C12B  1               ;	Set hardware registers from shadows.
00C12B  1               
00C12B  1  AD 0D D4     	LDA	PENV
00C12E  1  8D 35 02     	STA	LPENV		;light pen vertical position
00C131  1  AD 0C D4     	LDA	PENH
00C134  1  8D 34 02     	STA	LPENH		;light pen vertical position
00C137  1  AD 31 02     	LDA	SDLSTH
00C13A  1  8D 03 D4     	STA	DLISTH		;high display list address
00C13D  1  AD 30 02     	LDA	SDLSTL
00C140  1  8D 02 D4     	STA	DLISTL		;low display list address
00C143  1  AD 2F 02     	LDA	SDMCTL
00C146  1  8D 00 D4     	STA	DMACTL		;DMA control
00C149  1  AD 6F 02     	LDA	GPRIOR
00C14C  1  8D 1B D0     	STA	PRIOR		;prioritty select
00C14F  1               
00C14F  1               ;	Check for vertical scroll enabled.
00C14F  1               
00C14F  1  AD 6C 02     	LDA	VSFLAG		;vertical scroll count
00C152  1  F0 0E        	BEQ	IVN6		;if vertical scroll not ena:
00C154  1               
00C154  1               ;	Scroll one line.
00C154  1               
00C154  1  CE 6C 02     	DEC	VSFLAG		;decrement vertical scroll :
00C157  1  A9 08        	LDA	#8		;scroll one line
00C159  1  38           	SEC
00C15A  1  ED 6C 02     	SBC	VSFLAG		;subtract vertical scroll c:
00C15D  1  29 07        	AND	#07
00C15F  1  8D 05 D4     	STA	VSCROL		;set vertical scroll
00C162  1               
00C162  1               ;	Turn off speaker.
00C162  1               
00C162  1  A2 08        IVN6	LDX	#$08		;speaker off
00C164  1  8E 1F D0     	STX	CONSOL		;set speaker control
00C167  1               
00C167  1               ;	Set color registers from shadows.
00C167  1               
00C167  1               ;	LDX	#8		;offset to background color
00C167  1               
00C167  1  58           IVN7	CLI
00C168  1  BD C0 02     	LDA	PCOLR0,X	;color register shadow
00C16B  1  45 4F        	EOR	COLRSH		;modify with attract-mode color shift
00C16D  1  25 4E        	AND	DRKMSK		;modify with attract-mode luminance
00C16F  1  9D 12 D0     	STA	COLPM0,X	;set color register
00C172  1  CA           	DEX
00C173  1  10 F2        	BPL	IVN7		;if not done
00C175  1               
00C175  1               ;	Set character set control.
00C175  1               
00C175  1  AD F4 02     	LDA	CHBAS
00C178  1  8D 09 D4     	STA	CHBASE
00C17B  1  AD F3 02     	LDA	CHACT
00C17E  1  8D 01 D4     	STA	CHACTL
00C181  1               
00C181  1               ;	Process countdown timer 2.
00C181  1               
00C181  1  A2 02        	LDX	#2		;indicate countdown timer 2
00C183  1  20 55 C2     	JSR	DCT		;decrement countdown timer
00C186  1  D0 03        	BNE	IVN8		;if timer not expired
00C188  1               
00C188  1  20 52 C2     	JSR	PTT		;process countdown timer 2 expiration
00C18B  1               
00C18B  1               ;	Process timers 3, 4 and 5.
00C18B  1               
00C18B  1  A2 02        IVN8	LDX	#2		;preset offset to timer 2
00C18D  1               
00C18D  1  E8           IVN9	INX
00C18E  1  E8           	INX			;offset to countdown timer
00C18F  1  BD 18 02     	LDA	CDTMV3-4,X	;countdown timer
00C192  1  1D 19 02     	ORA	CDTMV3+1-4,X
00C195  1  F0 06        	BEQ	IVN10		;if countdown timer already expired
00C197  1               
00C197  1  20 55 C2     	JSR	DCT		;decrement countdown timer
00C19A  1  9D 26 02     	STA	CDTMF3-4,X	;indicate timer expiration status
00C19D  1               
00C19D  1  E0 08        IVN10	CPX	#8		;offset to timer 5
00C19F  1  D0 EC        	BNE	IVN9		;if all timers not done
00C1A1  1               
00C1A1  1               ;	Check debounce counter.
00C1A1  1               
00C1A1  1  AD 0F D2     	LDA	SKSTAT		;keyboard status
00C1A4  1  29 04        	AND	#$04		;key down indicator
00C1A6  1  F0 08        	BEQ	IVN11		;if key down
00C1A8  1               
00C1A8  1               ;	Process key up.
00C1A8  1               
00C1A8  1  AD F1 02     	LDA	KEYDEL		;key delay counter
00C1AB  1  F0 03        	BEQ	IVN11		;if counted down already
00C1AD  1               
00C1AD  1  CE F1 02     	DEC	KEYDEL		;decrement key delay counter
00C1B0  1               
00C1B0  1               ;	Check software key repeat timer.
00C1B0  1               
00C1B0  1  AD 2B 02     IVN11	LDA	SRTIMR		;key repeat timer
00C1B3  1  F0 3E        	BEQ	IVN13		;if key repeat timer expired
00C1B5  1               
00C1B5  1  AD 0F D2     	LDA	SKSTAT		;keyboard status
00C1B8  1  29 04        	AND	#$04		;key down indicator
00C1BA  1  D0 32        	BNE	IVN12		;if key no longer down
00C1BC  1               
00C1BC  1  CE 2B 02     	DEC	SRTIMR		;decrement key repeat timer
00C1BF  1  D0 32        	BNE	IVN13		;if key repeat timer not expired
00C1C1  1               
00C1C1  1               ;	Process key repeat timer expiration.
00C1C1  1               
00C1C1  1  AD 6D 02     	LDA	KEYDIS		;keyboard disable flag
00C1C4  1  D0 2D        	BNE	IVN13		;if keyboard disabled, no r:
00C1C6  1               
00C1C6  1  AD DA 02     	LDA	KEYREP		;initial timer value
00C1C9  1  8D 2B 02     	STA	SRTIMR		;reset key repeat timer
00C1CC  1  AD 09 D2     	LDA	KBCODE		;key code
00C1CF  1               
00C1CF  1               ;	Check for hidden codes.
00C1CF  1               
00C1CF  1  C9 9F        	CMP	#CNTL1
00C1D1  1  F0 20        	BEQ	IVN13		;if CTRL-1
00C1D3  1               
00C1D3  1  C9 83        	CMP	#CNTLF1
00C1D5  1  F0 1C        	BEQ	IVN13		;if CTRL-F1
00C1D7  1               
00C1D7  1  C9 84        	CMP	#CNTLF2
00C1D9  1  F0 18        	BEQ	IVN13		;if CTRL-F2
00C1DB  1               
00C1DB  1  C9 94        	CMP	#CNTLF4
00C1DD  1  F0 14        	BEQ	IVN13		;if CTRL-F4
00C1DF  1               
00C1DF  1  29 3F        	AND	#$3F
00C1E1  1  C9 11        	CMP	#HELP
00C1E3  1  F0 0E        	BEQ	IVN13		;if HELP
00C1E5  1               
00C1E5  1               ;	Set key code.
00C1E5  1               
00C1E5  1  AD 09 D2     	LDA	KBCODE		;key code
00C1E8  1  8D FC 02     	STA	CH		;set key code
00C1EB  1  4C F3 C1     	JMP	IVN13		;continue
00C1EE  1               
00C1EE  1               ;	Zero key repeat timer.
00C1EE  1               
00C1EE  1  A9 00        IVN12	LDA	#0
00C1F0  1  8D 2B 02     	STA	SRTIMR		;zero key repeat timer
00C1F3  1               
00C1F3  1               ;	Read joysticks.
00C1F3  1               
00C1F3  1  AD 00 D3     IVN13	LDA	PORTA		;joystick readings
00C1F6  1  4A           	LSR	A
00C1F7  1  4A           	LSR	A
00C1F8  1  4A           	LSR	A
00C1F9  1  4A           	LSR	A		;joystick 1 reading
00C1FA  1  8D 79 02     	STA	STICK1		;set joystick 1 reading
00C1FD  1               	IF	VGC
00C1FD  1  8D 7B 02     	STA	STICK3		;simulate joystick 3 reading
00C200  1               	ENDIF	;VGC
00C200  1  AD 00 D3     	LDA	PORTA		;joystick readings
00C203  1  29 0F        	AND	#$0F		;joystick 0 reading
00C205  1  8D 78 02     	STA	STICK0		;set joystick 0 reading
00C208  1               	IF	VGC
00C208  1  8D 7A 02     	STA	STICK2		;simulate joystick 2 reading
00C20B  1               	ENDIF	;VGC
00C20B  1               
00C20B  1               ;	Read joystick triggers.
00C20B  1               
00C20B  1  AD 10 D0     	LDA	TRIG0		;trigger 0 indicator
00C20E  1  8D 84 02     	STA	STRIG0		;set trigger 0 indicator
00C211  1               	IF	VGC
00C211  1  8D 86 02     	STA	STRIG2		;simulate trigger 2 indicator
00C214  1               	ENDIF	;VGC
00C214  1  AD 11 D0     	LDA	TRIG1		;trigger 1 indicator
00C217  1  8D 85 02     	STA	STRIG1		;set trigger 1 indicator
00C21A  1               	IF	VGC
00C21A  1  8D 87 02     	STA	STRIG3		;simulate trigger 3 indicator
00C21D  1               	ENDIF	;VGC
00C21D  1               
00C21D  1               ;	Read potentiometers.
00C21D  1               
00C21D  1  A2 03        	LDX	#3		;offset to last potentiometer
00C21F  1               
00C21F  1  BD 00 D2     IVN14	LDA	POT0,X		;potentiometer reading
00C222  1  9D 70 02     	STA	PADDL0,X	;set potentiometer reading
00C225  1               	IF	VGC
00C225  1  9D 74 02     	STA	PADDL4,X	;simulate potentiometer reading
00C228  1               	ENDIF	;VGC
00C228  1  CA           	DEX
00C229  1  10 F4        	BPL	IVN14		;if not done
00C22B  1               
00C22B  1               ;	Start potentiometers for next time.
00C22B  1               
00C22B  1  8D 0B D2     	STA	POTGO		;start potentiometers
00C22E  1               
00C22E  1               ;	Read paddle triggers.
00C22E  1               
00C22E  1  A2 02        	LDX	#2		;offset to paddle trigger reading
00C230  1  A0 01        	LDY	#1		;offset to joystick reading
00C232  1               
00C232  1  B9 78 02     IVN15	LDA	STICK0,Y	;joystick reading
00C235  1  4A           	LSR	A
00C236  1  4A           	LSR	A
00C237  1  4A           	LSR	A		;paddle trigger reading
00C238  1  9D 7D 02     	STA	PTRIG1,X	;set paddle trigger reading
00C23B  1               	IF	VGC
00C23B  1  9D 81 02     	STA	PTRIG5,X	;simulate paddle trigger reading
00C23E  1               	ENDIF	;VGC
00C23E  1               
00C23E  1  A9 00        	LDA	#0
00C240  1  2A           	ROL	A		;paddle trigger reading
00C241  1  9D 7C 02     	STA	PTRIG0,X	;set paddle trigger reading
00C244  1               	IF	VGC
00C244  1  9D 80 02     	STA	PTRIG4,X	;simulate paddle trigger reading
00C247  1               	ENDIF	;VGC
00C247  1  CA           	DEX
00C248  1  CA           	DEX
00C249  1  88           	DEY
00C24A  1  10 E6        	BPL	IVN15		;if not done
00C24C  1               
00C24C  1               ;	Exit.
00C24C  1               
00C24C  1  6C 24 02     	JMP	(VVBLKD)	;process deferred VBLANK NMI, return
00C24F  1               ;	SPACE	4,10
00C24F  1               ;**	PTO - Process Countdown Timer One Expiration
00C24F  1               ;*
00C24F  1               ;*	ENTRY	JSR	PTO
00C24F  1               ;*
00C24F  1               ;*	MODS
00C24F  1               ;*		Original Author Unknown
00C24F  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C24F  1               ;*		   R. K. Nordin	11/01/83
00C24F  1               
00C24F  1               
00C24F  1               PTO	=	*		;entry
00C24F  1  6C 26 02     	JMP	(CDTMA1)	;process countdown timer 1 expiration
00C252  1               ;	SPACE	4,10
00C252  1               ;**	PTT - Process Countdown Timer Two Expiration
00C252  1               ;*
00C252  1               ;*	ENTRY	JSR	PTT
00C252  1               ;*
00C252  1               ;*	MODS
00C252  1               ;*		Original Author Unknown
00C252  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C252  1               ;*		   R. K. Nordin	11/01/83
00C252  1               
00C252  1               
00C252  1               PTT	=	*		;entry
00C252  1  6C 28 02     	JMP	(CDTMA2)	;process countdown timer 2 expiration
00C255  1               ;	SPACE	4,10
00C255  1               ;**	DCT - Decrement Countdown Timer
00C255  1               ;*
00C255  1               ;*	ENTRY	JSR	DCT
00C255  1               ;*		X = offset to timer value
00C255  1               ;*
00C255  1               ;*	EXIT
00C255  1               ;*		A = 0, if timer expired
00C255  1               ;*		  = $FF, if timer did not expire
00C255  1               ;*
00C255  1               ;*	MODS
00C255  1               ;*		Original Author Unknown
00C255  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C255  1               ;*		   R. K. Nordin	11/01/83
00C255  1               
00C255  1               
00C255  1               DCT	=	*		;entry
00C255  1  BC 18 02     	LDY	CDTMV1,X	;low timer value
00C258  1  D0 08        	BNE	DCT1		;if low timer value not zero
00C25A  1               
00C25A  1  BC 19 02     	LDY	CDTMV1+1,X	;high timer value
00C25D  1  F0 10        	BEQ	DCT2		;if timer value zero, exit
00C25F  1               
00C25F  1  DE 19 02     	DEC	CDTMV1+1,X	;decrement high timer value
00C262  1               
00C262  1  DE 18 02     DCT1	DEC	CDTMV1,X	;decrement low timer value
00C265  1  D0 08        	BNE	DCT2		;if low timer value not zero
00C267  1               
00C267  1  BC 19 02     	LDY	CDTMV1+1,X	;high timer value
00C26A  1  D0 03        	BNE	DCT2		;if high timer value not zero
00C26C  1               
00C26C  1  A9 00        	LDA	#0		;indicate timer expired
00C26E  1  60           	RTS			;return
00C26F  1               
00C26F  1  A9 FF        DCT2	LDA	#$FF		;indicate timer did not expire
00C271  1  60           	RTS			;return
00C272  1               ;	SPACE	4,10
00C272  1               ;**	SVP - Set Vertical Blank Parameters
00C272  1               ;*
00C272  1               ;*	SVP sets countdown timers and VBLANK vectors.
00C272  1               ;*
00C272  1               ;*	ENTRY	JSR	SVP
00C272  1               ;*		X = high initial timer value or high vector address
00C272  1               ;*		Y = low initial timer value or low vector address
00C272  1               ;*		A = 1, if timer 1 value
00C272  1               ;*		    2, if timer 2 value
00C272  1               ;*		    3, if timer 3 value
00C272  1               ;*		    4, if timer 4 value
00C272  1               ;*		    5, if timer 5 value
00C272  1               ;*		    6, if immediate VBLANK vector
00C272  1               ;*		    7, if deferred VBLANK vector
00C272  1               ;*
00C272  1               ;*	MODS
00C272  1               ;*		Original Author Unknown
00C272  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C272  1               ;*		   R. K. Nordin	11/01/83
00C272  1               
00C272  1               
00C272  1               SVP	=	*		;entry
00C272  1               
00C272  1               ;	Initialize.
00C272  1               
00C272  1  0A           	ASL	A		;compute offset+2 to value or vector
00C273  1  8D 2D 02     	STA	INTEMP		;offset+2 to value or vector
00C276  1  8A           	TXA			;high timer value or high vector address
00C277  1               
00C277  1               ;	Ensure no VBLANK in progress by delaying after HBLANK.
00C277  1               
00C277  1  A2 05        	LDX	#5		;20 CPU cycles
00C279  1  8D 0A D4     	STA	WSYNC		;wait for HBLANK synchronization
00C27C  1               
00C27C  1  CA           SVP1	DEX
00C27D  1  D0 FD        	BNE	SVP1		;if not done delaying
00C27F  1               
00C27F  1               ;	Set timer value or vector address.
00C27F  1               
00C27F  1  AE 2D 02     	LDX	INTEMP		;offset+2 to value or vector
00C282  1  9D 17 02     	STA	CDTMV1-2+1,X	;high timer value or high vector address
00C285  1  98           	TYA
00C286  1  9D 16 02     	STA	CDTMV1-2,X	;low timer value or low vector address
00C289  1  60           	RTS			;return
00C28A  1               ;	SPACE	4,10
00C28A  1               ;**	DVNM - Process Deferred VBLANK NMI
00C28A  1               ;*
00C28A  1               ;*	ENTRY	JMP	DVNM
00C28A  1               ;*
00C28A  1               ;*	EXIT
00C28A  1               ;*		Exits via RTI
00C28A  1               ;*
00C28A  1               ;*	MODS
00C28A  1               ;*		Original Author Unknown
00C28A  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C28A  1               ;*		   R. K. Nordin	11/01/83
00C28A  1               
00C28A  1               
00C28A  1               DVNM	=	*	;entry
00C28A  1  68           	PLA
00C28B  1  A8           	TAY		;restore Y
00C28C  1  68           	PLA
00C28D  1  AA           	TAX		;restore X
00C28E  1  68           	PLA		;restore A
00C28F  1  40           	RTI		;return
00C290  1               ;	SUBTTL	'Initialization'
00C290  1               ;	SPACE	4,10
00C290  1               ;**	PWS - Perform Warmstart
00C290  1               ;*
00C290  1               ;*	ENTRY	JMP	PWS
00C290  1               ;*
00C290  1               ;*	EXIT
00C290  1               ;*		Exits to PCS or PRS
00C290  1               ;*
00C290  1               ;*	MODS
00C290  1               ;*		Original Author Unknown
00C290  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C290  1               ;*		   R. K. Nordin	11/01/83
00C290  1               
00C290  1               
00C290  1               PWS	=	*	;entry
00C290  1               
00C290  1               ;	Initialize.
00C290  1               
00C290  1  78           	SEI
00C291  1               
00C291  1               ;	Check for cartridge change.
00C291  1               
00C291  1  AD 13 D0     	LDA	TRIG3	;cartridge interlock
00C294  1  CD FA 03     	CMP	GINTLK	;previous cartridge interlock status
00C297  1  D0 2F        	BNE	PCS	;if cartridge changed, perform coldstart
00C299  1               
00C299  1               ;	Check for cartridge.
00C299  1               
00C299  1  6A           	ROR	A
00C29A  1  90 05        	BCC	PWS1	;if no cartridge
00C29C  1               
00C29C  1               ;	Verify no change in cartridge.
00C29C  1               
00C29C  1  20 C9 C4     	JSR	CCE	;check cartridge equivalence
00C29F  1  D0 27        	BNE	PCS	;if different cartridge, coldstart
00C2A1  1               
00C2A1  1               ;	Check coldstart status.
00C2A1  1               
00C2A1  1  AD 44 02     PWS1	LDA	COLDST	;coldstart status
00C2A4  1  D0 22        	BNE	PCS	;if coldstart was in progress, perform coldstart
00C2A6  1               
00C2A6  1               ;	Perform warmstart.
00C2A6  1               
00C2A6  1  A9 FF        	LDA	#$FF	;indicate warmstart
00C2A8  1  D0 20        	BNE	PRS	;preset memory, return
00C2AA  1               ;	SPACE	4,10
00C2AA  1               ;**	RES - Process RESET
00C2AA  1               ;*
00C2AA  1               ;*	ENTRY	JMP	RES
00C2AA  1               ;*
00C2AA  1               ;*	EXIT
00C2AA  1               ;*		Exits to PCS, if coldstart, or PWS, if warmstart
00C2AA  1               ;*
00C2AA  1               ;*	MODS
00C2AA  1               ;*		Original Author Unknown
00C2AA  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C2AA  1               ;*		   R. K. Nordin	11/01/83
00C2AA  1               
00C2AA  1               
00C2AA  1               RES	=	*	;entry
00C2AA  1               
00C2AA  1               ;	Initialize.
00C2AA  1               
00C2AA  1  78           	SEI
00C2AB  1               
00C2AB  1               ;	Delay 0.1 second for RESET bounce.
00C2AB  1               
00C2AB  1  A2 8C        	LDX	#140	;0.1 second delay
00C2AD  1               
00C2AD  1  88           RES1	DEY
00C2AE  1  D0 FD        	BNE	RES1	;if inner loop not done
00C2B0  1               
00C2B0  1  CA           	DEX
00C2B1  1  D0 FA        	BNE	RES1	;if outer loop not done
00C2B3  1               
00C2B3  1               ;	Check power-up validation bytes.
00C2B3  1               
00C2B3  1  AD 3D 03     	LDA	PUPBT1
00C2B6  1  C9 5C        	CMP	#PUPVL1
00C2B8  1  D0 0E        	BNE	PCS	;if validation byte 1 differs, coldstart
00C2BA  1               
00C2BA  1  AD 3E 03     	LDA	PUPBT2
00C2BD  1  C9 93        	CMP	#PUPVL2
00C2BF  1  D0 07        	BNE	PCS	;if validation byte 2 differs, coldstart
00C2C1  1               
00C2C1  1  AD 3F 03     	LDA	PUPBT3
00C2C4  1  C9 25        	CMP	#PUPVL3
00C2C6  1  F0 C8        	BEQ	PWS	;if all bytes validated, perform warmstart
00C2C8  1               
00C2C8  1               ;	JMP	PCS	;perform coldstart, return
00C2C8  1               ;	SPACE	4,10
00C2C8  1               ;**	PCS - Perform Coldstart
00C2C8  1               ;*
00C2C8  1               ;*	ENTRY	JMP	PCS
00C2C8  1               ;*
00C2C8  1               ;*	EXIT
00C2C8  1               ;*		Exits to PRS
00C2C8  1               ;*
00C2C8  1               ;*	MODS
00C2C8  1               ;*		Original Author Unknown
00C2C8  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C2C8  1               ;*		   R. K. Nordin	11/01/83
00C2C8  1               
00C2C8  1               
00C2C8  1               PCS	=	*	;entry
00C2C8  1  A9 00        	LDA	#0	;indicate coldstart
00C2CA  1               ;	JMP	PRS	;preset memory, return
00C2CA  1               ;	SPACE	4,10
00C2CA  1               ;**	PRS - Preset Memory
00C2CA  1               ;*
00C2CA  1               ;*	ENTRY	JMP	PRS
00C2CA  1               ;*
00C2CA  1               ;*	EXIT
00C2CA  1               ;*		Exits via CARTCS vector or DOSVEC vector
00C2CA  1               ;*
00C2CA  1               ;*	MODS
00C2CA  1               ;*		Original Author Unknown
00C2CA  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C2CA  1               ;*		   R. K. Nordin	11/01/83
00C2CA  1               
00C2CA  1               
00C2CA  1               PRS	=	*		;entry
00C2CA  1               
00C2CA  1               ;	Update warmstart flag.
00C2CA  1               
00C2CA  1  85 08        	STA	WARMST		;update warmstart flag
00C2CC  1               
00C2CC  1               ;	Set initial conditions.
00C2CC  1               
00C2CC  1  78           	SEI
00C2CD  1  D8           	CLD
00C2CE  1  A2 FF        	LDX	#$FF
00C2D0  1  9A           	TXS			;set stack pointer
00C2D1  1               
00C2D1  1               ;	Initialize LNBUG flag, if necessary.
00C2D1  1               
00C2D1  1               	IF	LNBUG
00C2D1  1               	LDY	#0		;assume no LNBUG
00C2D1  1               	LDA	LNORG		;first byte of LNBUG
00C2D1  1               	CMP	#$4C		;JMP instruction
00C2D1  1               	BNE	PRS2		;if JMP not present, indicate no LNBUG
00C2D1  1               
00C2D1  1               	INC	LNORG		;try to increment test byte
00C2D1  1               	CMP	LNORG		;original contents of test byte
00C2D1  1               	BEQ	PRS1		;if no change, LNBUG present
00C2D1  1               
00C2D1  1               	DEC	LNORG		;restore test byte
00C2D1  1               	BNE	PRS2		;indicate no LNBUG
00C2D1  1               
00C2D1  1               PRS1	DEY			;LNBUG present indicator
00C2D1  1               
00C2D1  1               PRS2	STY	LNFLG		;LNBUG flag
00C2D1  1               	ENDIF	;LNBUG
00C2D1  1               
00C2D1  1               ;	Perform miscellaneous initialization.
00C2D1  1               
00C2D1  1  20 71 C4     	JSR	PMI		;perform miscellaneous initialization
00C2D4  1               
00C2D4  1               ;	Initialize memory status.
00C2D4  1               
00C2D4  1  A9 01        	LDA	#1		;no failure indicator
00C2D6  1  85 01        	STA	NGFLAG		;memory status flag
00C2D8  1               
00C2D8  1               ;	Check type.
00C2D8  1               
00C2D8  1  A5 08        	LDA	WARMST		;warmstart flag
00C2DA  1  D0 52        	BNE	PRS8		;if warmstart
00C2DC  1               
00C2DC  1               ;	Zero all RAM (except beginning of page zero).
00C2DC  1               
00C2DC  1  A9 00        	LDA	#0
00C2DE  1  A0 08        	LDY	#WARMST		;initial offset into page zero
00C2E0  1  85 04        	STA	RAMLO
00C2E2  1  85 05        	STA	RAMLO+1		;initialize RAM pointer
00C2E4  1               
00C2E4  1  A9 FF        PRS3	LDA	#$FF
00C2E6  1  91 04        	STA	(RAMLO),Y	;attempt to store $FF
00C2E8  1  D1 04        	CMP	(RAMLO),Y
00C2EA  1  F0 02        	BEQ	PRS4		;if $FF stored successfully
00C2EC  1               
00C2EC  1  46 01        	LSR	NGFLAG		;indicate memory failure
00C2EE  1               
00C2EE  1  A9 00        PRS4	LDA	#$00
00C2F0  1  91 04        	STA	(RAMLO),Y	;attempt to store $00
00C2F2  1  D1 04        	CMP	(RAMLO),Y
00C2F4  1  F0 02        	BEQ	PRS5		;if $00 stored successfully
00C2F6  1               
00C2F6  1  46 01        	LSR	NGFLAG		;indicate memory failure
00C2F8  1               
00C2F8  1  C8           PRS5	INY
00C2F9  1  D0 E9        	BNE	PRS3		;if not end of page
00C2FB  1               
00C2FB  1               ;	Advance to next page and check for completion.
00C2FB  1               
00C2FB  1  E6 05        	INC	RAMLO+1		;advance RAM pointer to next page
00C2FD  1  A6 05        	LDX	RAMLO+1
00C2FF  1  E4 06        	CPX	TRAMSZ		;RAM size
00C301  1  D0 E1        	BNE	PRS3		;if not at end of RAM
00C303  1               
00C303  1               ;	Initialize DOSVEC.
00C303  1               
00C303  1  A9 23        	LDA	#low PPD	;power-up display routine address
00C305  1  85 0A        	STA	DOSVEC		;initialize DOS vector
00C307  1  A9 F2        	LDA	#high PPD
00C309  1  85 0B        	STA	DOSVEC+1
00C30B  1               
00C30B  1               ;	Verify ROM checksums.
00C30B  1               
00C30B  1  AD 01 D3     	LDA	PORTB
00C30E  1  29 7F        	AND	#$7F		;select self-test ROM
00C310  1  8D 01 D3     	STA	PORTB		;port B memory control
00C313  1               
00C313  1  20 73 FF     	JSR	VFR		;verify first 8K ROM
00C316  1  B0 05        	BCS	PRS6		;if first 8K ROM bad
00C318  1               
00C318  1  20 92 FF     	JSR	VSR		;verify second 8K ROM
00C31B  1  90 02        	BCC	PRS7		;if seond 8K ROM good
00C31D  1               
00C31D  1  46 01        PRS6	LSR	NGFLAG		;indicate memory bad
00C31F  1               
00C31F  1  AD 01 D3     PRS7	LDA	PORTB
00C322  1  09 80        	ORA	#$80		;disable self-test ROM
00C324  1  8D 01 D3     	STA	PORTB		;update port B memory control
00C327  1               
00C327  1               ;	Indicate coldstart in progress.
00C327  1               
00C327  1  A9 FF        	LDA	#$FF
00C329  1  8D 44 02     	STA	COLDST		;indicate coldstart in progress
00C32C  1  D0 22        	BNE	PRS12		;continue with coldstart procedures
00C32E  1               
00C32E  1               ;	Perform warmstart procedures.
00C32E  1               
00C32E  1  A2 00        PRS8	LDX	#0
00C330  1               
00C330  1  AD EC 03     	LDA	DERRF		;screen OPEN error flag
00C333  1  F0 07        	BEQ	PRS9		;if in screen OPEN
00C335  1               
00C335  1               ;	Clean up APPMHI.
00C335  1               
00C335  1               ;	STX	APPMHI
00C335  1  8E 0E 00     	.BYTE	$8E, low APPMHI, high APPMHI ;originally VFD
00C338  1               ;	STX	APPMHI+1
00C338  1  8E 0F 00     	.BYTE	$8E, low (APPMHI+1), high (APPMHI+1) ;originally VFD
00C33B  1               
00C33B  1  8A           	TXA
00C33C  1               
00C33C  1               ;	Clear page 2 and part of page 3.
00C33C  1               
00C33C  1  9D 00 02     PRS9	STA	$0200,X		;clear byte of page 2
00C33F  1               
00C33F  1  E0 ED        	CPX	#low ACMVAR	;start of page 3 locations not to clear
00C341  1  B0 03        	BCS	PRS10		;if not to clear this page 3 location
00C343  1               
00C343  1  9D 00 03     	STA	$0300,X		;clear byte of page 3
00C346  1               
00C346  1  CA           PRS10	DEX
00C347  1  D0 F3        	BNE	PRS9		;if not done
00C349  1               
00C349  1               ;	Clear part of page 0.
00C349  1               
00C349  1  A2 10        	LDX	#INTZBS		;offset to first page 0 byte to clear
00C34B  1               
00C34B  1  95 00        PRS11	STA	$0000,X		;clear byte of page 0
00C34D  1  E8           	INX
00C34E  1  10 FB        	BPL	PRS11		;if not done
00C350  1               
00C350  1               ;	Record BASIC status.
00C350  1               
00C350  1  A2 00        PRS12	LDX	#0		;initially assume BASIC enabled
00C352  1  AD 01 D3     	LDA	PORTB		;port B memory control
00C355  1  29 02        	AND	#$02		;BASIC enabled indicator
00C357  1  F0 01        	BEQ	PRS13		;if BASIC enabled
00C359  1               
00C359  1  E8           	INX			;indicate BASIC disabled
00C35A  1               
00C35A  1  8E F8 03     PRS13	STX	BASICF		;BASIC flag
00C35D  1               
00C35D  1               ;	Establish power-up validation bytes.
00C35D  1               
00C35D  1  A9 5C        	LDA	#PUPVL1
00C35F  1  8D 3D 03     	STA	PUPBT1		;validation byte 1
00C362  1  A9 93        	LDA	#PUPVL2
00C364  1  8D 3E 03     	STA	PUPBT2		;validation byte 2
00C367  1  A9 25        	LDA	#PUPVL3
00C369  1  8D 3F 03     	STA	PUPBT3		;validation byte 3
00C36C  1               
00C36C  1               ;	Establish screen margins.
00C36C  1               
00C36C  1  A9 02        	LDA	#LEDGE
00C36E  1  85 52        	STA	LMARGN		;left margin
00C370  1  A9 27        	LDA	#REDGE
00C372  1  85 53        	STA	RMARGN		;right margin
00C374  1               
00C374  1               ;	Establish parameters for NTSC or PAL.
00C374  1               
00C374  1  AD 14 D0     	LDA	PAL		;GTIA flag bits
00C377  1  29 0E        	AND	#$0E		;PAL/NTSC indicator
00C379  1  D0 08        	BNE	PRS14		;if NTSC
00C37B  1               
00C37B  1  A9 05        	LDA	#5		;PAL key repeat delay
00C37D  1  A2 01        	LDX	#1		;PAL indicator
00C37F  1  A0 28        	LDY	#40		;PAL key repeat initial delay
00C381  1  D0 06        	BNE	PRS15		;set parameters
00C383  1               
00C383  1  A9 06        PRS14	LDA	#6		;NTSC key repeat delay
00C385  1  A2 00        	LDX	#0		;NTSC indicator
00C387  1  A0 30        	LDY	#48		;NTSC key repeat initial delay
00C389  1               
00C389  1  8D DA 02     PRS15	STA	KEYREP		;set key repeat rate
00C38C  1  86 62        	STX	PALNTS		;set PAL/NTSC status
00C38E  1  8C D9 02     	STY	KRPDEL		;set key repeat initial delay
00C391  1               
00C391  1               ;	Initialize missing controller ports, if not simulated.
00C391  1               
00C391  1               	IF	not VGC
00C391  1               	LDA	#$0F		;joystick centered
00C391  1               	STA	STICK2
00C391  1               	STA	STICK3
00C391  1               	LDA	#$01		;trigger not pressed
00C391  1               	STA	STRIG2
00C391  1               	STA	STRIG3
00C391  1               
00C391  1               	LDX	#3		;offset to last controller
00C391  1               
00C391  1               PRS16	LDA	#$E4		;paddle fully counter-clockwise
00C391  1               	STA	PADDL4,X
00C391  1               	LDA	#$01		;trigger not pressed
00C391  1               	STA	PTRIG4,X
00C391  1               	DEX
00C391  1               	BPL	PRS16		;if not done
00C391  1               	ENDIF	;VGC
00C391  1               
00C391  1               ;	Copy interrupt vector table from ROM to RAM.
00C391  1               
00C391  1  A2 25        	LDX	#TIHVL-1	;offset to last byte of table
00C393  1               
00C393  1  BD 4B C4     PRS17	LDA	TIHV,X		;byte of table of interrupt vectors
00C396  1  9D 00 02     	STA	INTABS,X	;byte of RAM table
00C399  1  CA           	DEX
00C39A  1  10 F7        	BPL	PRS17		;if not done
00C39C  1               
00C39C  1               ;	Copy handler vector table from ROM to RAM.
00C39C  1               
00C39C  1  A2 0E        	LDX	#THAVL-1	;offset to last byte of table
00C39E  1               
00C39E  1  BD 2E C4     PRS18	LDA	THAV,X		;byte of handler vector table
00C3A1  1  9D 1A 03     	STA	HATABS,X	;byte of RAM table
00C3A4  1  CA           	DEX
00C3A5  1  10 F7        	BPL	PRS18		;if not done
00C3A7  1               
00C3A7  1               ;	Initialize software.
00C3A7  1               
00C3A7  1  20 35 C5     	JSR	ISW		;initialize software
00C3AA  1               
00C3AA  1               ;	Initialize ACMI module, if present.
00C3AA  1               
00C3AA  1               	IF	ACMI
00C3AA  1               	ENDIF	;ACMI
00C3AA  1               
00C3AA  1               ;	Enable IRQ interrupts.
00C3AA  1               
00C3AA  1  58           	CLI
00C3AB  1               
00C3AB  1               ;	Check for memory problems.
00C3AB  1               
00C3AB  1  A5 01        	LDA	NGFLAG		;memory status
00C3AD  1  D0 15        	BNE	PRS21		;if memory good
00C3AF  1               
00C3AF  1               ;	Perform memory self-test on bad memory.
00C3AF  1               
00C3AF  1  AD 01 D3     	LDA	PORTB
00C3B2  1  29 7F        	AND	#$7F		;enable self-test ROM
00C3B4  1  8D 01 D3     	STA	PORTB		;update port B memory control
00C3B7  1  A9 02        	LDA	#2
00C3B9  1  8D F3 02     	STA	CHACT		;CHACTL (character control) shadow
00C3BC  1  A9 E0        	LDA	#high DCSORG	;high domestic character set origin
00C3BE  1  8D F4 02     	STA	CHBAS		;CHBASE (character base) shadow
00C3C1  1  4C 03 50     	JMP	EMS		;execute memory self-test
00C3C4  1               
00C3C4  1               ;	Check for cartridge.
00C3C4  1               
00C3C4  1  A2 00        PRS21	LDX	#0
00C3C6  1  86 06        	STX	TRAMSZ		;clear cartridge flag
00C3C8  1               
00C3C8  1  AE E4 02     	LDX	RAMSIZ		;RAM size
00C3CB  1  E0 B0        	CPX	#high $B000	;start of cartridge area
00C3CD  1  B0 0D        	BCS	PRS22		;if RAM in cartridge area
00C3CF  1               
00C3CF  1  AE FC BF     	LDX	CART
00C3D2  1  D0 08        	BNE	PRS22		;if no cartridge
00C3D4  1               
00C3D4  1  E6 06        	INC	TRAMSZ		;set cartridge flag
00C3D6  1  20 C9 C4     	JSR	CCE		;check cartridge equivalence
00C3D9  1  20 29 C4     	JSR	ICS		;initialize cartridge software
00C3DC  1               
00C3DC  1               ;	Open screen editor.
00C3DC  1               
00C3DC  1  A9 03        PRS22	LDA	#OPEN
00C3DE  1  A2 00        	LDX	#SEIOCB		;screen editor IOCB index
00C3E0  1  9D 42 03     	STA	ICCOM,X		;command
00C3E3  1  A9 48        	LDA	#low SEDS	;screen editor device specification
00C3E5  1  9D 44 03     	STA	ICBAL,X		;buffer address
00C3E8  1  A9 C4        	LDA	#high SEDS
00C3EA  1  9D 45 03     	STA	ICBAH,X
00C3ED  1  A9 0C        	LDA	#OPNIN+OPNOT	;open for input/output
00C3EF  1  9D 4A 03     	STA	ICAX1,X		;auxiliary informatin 1
00C3F2  1  20 56 E4     	JSR	CIOV		;vector to CIO
00C3F5  1  10 03        	BPL	PRS23		;if no error
00C3F7  1               
00C3F7  1               ;	Process error (which should never happen).
00C3F7  1               
00C3F7  1  4C AA C2     	JMP	RES		;retry power-up
00C3FA  1               
00C3FA  1               ;	Delay, ensuring VBLANK.
00C3FA  1               
00C3FA  1  E8           PRS23	INX
00C3FB  1  D0 FD        	BNE	PRS23		;if inner loop not done
00C3FD  1               
00C3FD  1  C8           	INY
00C3FE  1  10 FA        	BPL	PRS23		;if outer loop not done
00C400  1               
00C400  1               ;	Attempt cassette boot.
00C400  1               
00C400  1  20 6E C6     	JSR	ACB		;attempt cassette boot
00C403  1               
00C403  1               ;	Check cartridge for disk boot.
00C403  1               
00C403  1  A5 06        	LDA	TRAMSZ
00C405  1  F0 06        	BEQ	PRS24		;if no cartridge
00C407  1               
00C407  1  AD FD BF     	LDA	CARTFG		;cartridge mode flags
00C40A  1  6A           	ROR	A
00C40B  1  90 06        	BCC	PRS25		;if disk boot not desired
00C40D  1               
00C40D  1               ;	Attempt disk boot.
00C40D  1               
00C40D  1  20 8B C5     PRS24	JSR	ADB		;attempt disk boot
00C410  1               
00C410  1               ;	Initialize peripheral handler loading facility.
00C410  1               
00C410  1  20 39 E7     	JSR	PHR		;poll, load, relocate, init:
00C413  1               
00C413  1               ;	Indicate coldstart complete.
00C413  1               
00C413  1  A9 00        PRS25	LDA	#0
00C415  1  8D 44 02     	STA	COLDST		;indicate coldstart complete
00C418  1               
00C418  1               ;	Check cartridge for execution.
00C418  1               
00C418  1  A5 06        	LDA	TRAMSZ
00C41A  1  F0 0A        	BEQ	PRS26		;if no cartridge
00C41C  1               
00C41C  1  AD FD BF     	LDA	CARTFG		;cartridge mode flags
00C41F  1  29 04        	AND	#$04
00C421  1  F0 03        	BEQ	PRS26		;if execution not desired
00C423  1               
00C423  1               ;	Execute cartridge.
00C423  1               
00C423  1  6C FA BF     	JMP	(CARTCS)	;execute cartridge
00C426  1               
00C426  1               ;	Exit to power-up display or booted program.
00C426  1               
00C426  1  6C 0A 00     PRS26	JMP	(DOSVEC)	;vector to booted program
00C429  1               ;	SPACE	4,10
00C429  1               ;**	ICS - Initialize Cartridge Software
00C429  1               ;*
00C429  1               ;*	ENTRY	JSR	ICS
00C429  1               ;*
00C429  1               ;*	MODS
00C429  1               ;*		Original Author Unknown
00C429  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C429  1               ;*		   R. K. Nordin	11/01/83
00C429  1               
00C429  1               
00C429  1               ICS	=	*	;entry
00C429  1  6C FE BF     	JMP	(CARTAD)	;initialize cartridge software
00C42C  1               ;	SPACE	4,10
00C42C  1               ;**	PAI - Process ACMI Interrupt
00C42C  1               ;*
00C42C  1               ;*	PAI does nothing.
00C42C  1               ;*
00C42C  1               ;*	ENTRY	JSR	PAI
00C42C  1               ;*
00C42C  1               ;*	NOTES
00C42C  1               ;*		Problem: this code is unneeded unless ACMI :
00C42C  1               ;*		option is selected.
00C42C  1               ;*
00C42C  1               ;*	MODS
00C42C  1               ;*		Original Author Unknown
00C42C  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C42C  1               ;*		   R. K. Nordin	11/01/83
00C42C  1               
00C42C  1               
00C42C  1               PAI	=	*	;entry
00C42C  1  18           	CLC
00C42D  1  60           	RTS		;return
00C42E  1               ;	SPACE	4,10
00C42E  1               ;**	THAV - Table of Handler Vectors
00C42E  1               ;*
00C42E  1               ;*	NOTES
00C42E  1               ;*		THAV is moved to RAM table HATABS.
00C42E  1               
00C42E  1               
00C42E  1  50 30 E4     THAV	DB	PRINTR	;printer device code
00C431  1               	DW	PRINTV	;printer handler vector table
00C431  1               
00C431  1  43 40 E4     	DB	CASSET	;cassette device code
00C434  1               	DW	CASETV	;cassette handler vector table
00C434  1               
00C434  1  45 00 E4     	DB	SCREDT	;editor device code
00C437  1               	DW	EDITRV	;editor handler vector table
00C437  1               
00C437  1  53 10 E4     	DB	DISPLY	;screen device code
00C43A  1               	DW	SCRENV	;screen handler vector table
00C43A  1               
00C43A  1  4B 20 E4     	DB	KBD	;keyboard device code
00C43D  1               	DW	KEYBDV	;keyboard handler vector table
00C43D  1               
00C43D  1               THAVL	=	*-THAV	;length
00C43D  1               ;	SPACE	4,10
00C43D  1               ;**	BMSG - Boot Error Message
00C43D  1               
00C43D  1               
00C43D  1  42 4F 4F 54  BMSG	DB	'BOOT ERROR',EOL
00C441  1  20 45 52 52  
00C445  1  4F 52 9B     
00C448  1               ;	SPACE	4,10
00C448  1               ;**	Screen Editor Device Specification
00C448  1               
00C448  1               
00C448  1  45 3A 9B     SEDS	DB	'E:',EOL
00C44B  1               ;	SPACE	4,10
00C44B  1               ;**	TIHV - Table of Interrupt Handler Vectors
00C44B  1               ;*
00C44B  1               ;*	NOTES
00C44B  1               ;*		TIHV is moved to RAM table INTABS.
00C44B  1               
00C44B  1               
00C44B  1  CE C0 CD C0  TIHV	DW	RIR	;VDSLST - display list NMI vector
00C44F  1  CD C0 CD C0  
00C453  1  19 FC 2C EB  
00C471  1               	DW	XIR	;VPRCED - proceed line IRQ vector
00C471  1               	DW	XIR	;VINTER - interrupt line IRQ vector
00C471  1               	DW	XIR	;VBREAK - BRK instruction IRQ vector
00C471  1               	DW	KIR	;VKEYBD - keyboard IRQ vector
00C471  1               	DW	IRIR	;VSERIN - serial input ready IRQ vector
00C471  1               	DW	ORIR	;VSEROR - serial output ready IRQ vector
00C471  1               	DW	OCIR	;VSEROC - serial output complete IRQ vector
00C471  1               	DW	XIR	;VTIMR1 - POKEY timer 1 IRQ vector
00C471  1               	DW	XIR	;VTIMR2 - POKEY timer 2 IRQ vector
00C471  1               	DW	XIR	;VTIMR4 - POKEY timer 4 IRQ vector
00C471  1               	DW	IIR	;VIMIRQ - immediate IRQ vector
00C471  1               	DW	0	;CDTMV1 - countdown timer 1 vector
00C471  1               	DW	0	;CDTMV2 - countdown timer 2 vector
00C471  1               	DW	0	;CDTMV3 - countdown timer 3 vector
00C471  1               	DW	0	;CDTMV4 - countdown timer 4 vector
00C471  1               	DW	0	;CDTMV5 - countdown timer 5 vector
00C471  1               	DW	IVNM	;VVBLKI - immediate VBLANK NMI vector
00C471  1               	DW	DVNM	;VVBLKD - deferred VBLANK NMI vector
00C471  1               
00C471  1               TIHVL	=	*-TIHV	;length
00C471  1               ;	SPACE	4,10
00C471  1               ;**	PMI - Perform Miscellaneous Initialization
00C471  1               ;*
00C471  1               ;*	ENTRY	JSR	PMI
00C471  1               ;*
00C471  1               ;*	NOTES
00C471  1               ;*		Problem: initial address for sizing RAM sho:
00C471  1               ;*		$4000 (16K) instead of $2800.
00C471  1               ;*
00C471  1               ;*	MODS
00C471  1               ;*		Original Author Unknown
00C471  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C471  1               ;*		   R. K. Nordin	11/01/83
00C471  1               
00C471  1               
00C471  1               PMI	=	*	;entry
00C471  1               
00C471  1               ;	Check for cartridge special execution case.
00C471  1               
00C471  1  AD 13 D0     	LDA	TRIG3
00C474  1  6A           	ROR	A
00C475  1  90 0D        	BCC	PMI1	;if cartridge not inserted
00C477  1               
00C477  1  AD FC BF     	LDA	CART
00C47A  1  D0 08        	BNE	PMI1	;if not cartridge
00C47C  1               
00C47C  1  AD FD BF     	LDA	CARTFG	;cartridge flags
00C47F  1  10 03        	BPL	PMI1	;if special execution not desired
00C481  1               
00C481  1               ;	Execute cartridge.
00C481  1               
00C481  1  6C FE BF     	JMP	(CARTAD)	;execute cartridge
00C484  1               
00C484  1               ;	Initialize hardware.
00C484  1               
00C484  1  20 DA C4     PMI1	JSR	IHW	;initialize hardware
00C487  1               
00C487  1               ;	Disable BASIC.
00C487  1               
00C487  1  AD 01 D3     	LDA	PORTB
00C48A  1  09 02        	ORA	#$02	;disable BASIC
00C48C  1  8D 01 D3     	STA	PORTB	;update port B memory control
00C48F  1               
00C48F  1               ;	If warmstart, check previous BASIC status.
00C48F  1               
00C48F  1  A5 08        	LDA	WARMST
00C491  1  F0 07        	BEQ	PMI2	;if coldstart
00C493  1               
00C493  1  AD F8 03     	LDA	BASICF	;BASIC flag
00C496  1  D0 11        	BNE	PMI4	;if BASIC not previously enabled
00C498  1               
00C498  1  F0 07        	BEQ	PMI3	;enable BASIC
00C49A  1               
00C49A  1               ;	Check OPTION key.
00C49A  1               
00C49A  1  AD 1F D0     PMI2	LDA	CONSOL	;console switches
00C49D  1  29 04        	AND	#$04	;OPTION key indicator
00C49F  1  F0 08        	BEQ	PMI4	;if OPTION key pressed, do not enable BASIC
00C4A1  1               
00C4A1  1               ;	Enable BASIC.
00C4A1  1               
00C4A1  1  AD 01 D3     PMI3	LDA	PORTB
00C4A4  1  29 FD        	AND	#$FD	;enable BASIC
00C4A6  1  8D 01 D3     	STA	PORTB	;update port B memory control
00C4A9  1               
00C4A9  1               ;	Determine size of RAM.
00C4A9  1               
00C4A9  1               	IF	RAMSYS
00C4A9  1               PMI4	LDA	#high $2800	;10K
00C4A9  1               	STA	TRAMSZ		;set RAM size
00C4A9  1               	RTS			;return
00C4A9  1               	ELSE	;RAMSYS
00C4A9  1               
00C4A9  1  A9 00        PMI4	LDA	#low $2800	;initial low address
00C4AB  1  A8           	TAY			;offset to first byte of page
00C4AC  1  85 05        	STA	TRAMSZ-1	;set initial low address
00C4AE  1               
00C4AE  1  A9 28        	LDA	#high $2800	;initial RAM size
00C4B0  1  85 06        	STA	TRAMSZ		;set initial RAM size (high address)
00C4B2  1               
00C4B2  1  B1 05        PMI5	LDA	(TRAMSZ-1),Y	;first byte of page
00C4B4  1  49 FF        	EOR	#$FF		;complement
00C4B6  1  91 05        	STA	(TRAMSZ-1),Y	;attempt to store complement
00C4B8  1  D1 05        	CMP	(TRAMSZ-1),Y
00C4BA  1  D0 0C        	BNE	PMI6		;if complement not stored
00C4BC  1               
00C4BC  1  49 FF        	EOR	#$FF		;original value
00C4BE  1  91 05        	STA	(TRAMSZ-1),Y	;attempt to store original value
00C4C0  1  D1 05        	CMP	(TRAMSZ-1),Y
00C4C2  1  D0 04        	BNE	PMI6		;if original value not stored
00C4C4  1               
00C4C4  1  E6 06        	INC	TRAMSZ		;increment high address
00C4C6  1  D0 EA        	BNE	PMI5		;continue
00C4C8  1               
00C4C8  1               ;	Exit.
00C4C8  1               
00C4C8  1  60           PMI6	RTS			;return
00C4C9  1               	ENDIF	;RAMSYS
00C4C9  1               ;	SPACE	4,10
00C4C9  1               ;**	CCE - Check Cartridge Equivalence
00C4C9  1               ;*
00C4C9  1               ;*	ENTRY	JSR	CCE
00C4C9  1               ;*
00C4C9  1               ;*	NOTES
00C4C9  1               ;*		Problem: this code checksums $BFF0 - $C0EF;:
00C4C9  1               ;*		checksum $BF00 - $BFFF.
00C4C9  1               ;*
00C4C9  1               ;*	MODS
00C4C9  1               ;*		Original Author Unknown
00C4C9  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C4C9  1               ;*		   R. K. Nordin	11/01/83
00C4C9  1               
00C4C9  1               
00C4C9  1               CCE	=	*	;entry
00C4C9  1               
00C4C9  1               ;	Initialize.
00C4C9  1               
00C4C9  1  A9 00        	LDA	#0	;initial sum
00C4CB  1  AA           	TAX		;offset to first byte
00C4CC  1  18           	CLC
00C4CD  1               
00C4CD  1               ;	Checksum 256 bytes of cartridge area.
00C4CD  1               
00C4CD  1  7D F0 BF     CCE1	ADC	$BFF0,X	;add in byte
00C4D0  1  E8           	INX
00C4D1  1  D0 FA        	BNE	CCE1	;if not done
00C4D3  1               
00C4D3  1               ;	Exit.
00C4D3  1               
00C4D3  1  CD EB 03     	CMP	CARTCK	;previous checksum
00C4D6  1  8D EB 03     	STA	CARTCK	;new checksum
00C4D9  1  60           	RTS		;return
00C4DA  1               ;	SPACE	4,10
00C4DA  1               ;**	IHW - Initialize Hardware
00C4DA  1               ;*
00C4DA  1               ;*	ENTRY	JSR	IHW
00C4DA  1               ;*
00C4DA  1               ;*	MODS
00C4DA  1               ;*		Original Author Unknown
00C4DA  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C4DA  1               ;*		   R. K. Nordin	11/01/83
00C4DA  1               
00C4DA  1               
00C4DA  1               IHW	=	*	;entry
00C4DA  1               
00C4DA  1               ;	Initialize CTIA, ANTIC and POKEY areas.
00C4DA  1               
00C4DA  1  A9 00        	LDA	#0		;initialization value
00C4DC  1  AA           	TAX			;initial offset
00C4DD  1  8D 03 D3     	STA	PBCTL		;set for direction register first
00C4E0  1               
00C4E0  1  9D 00 D0     IHW1	STA	CTIA,X		;initialize CTIA/GTIA area register
00C4E3  1  9D 00 D4     	STA	ANTIC,X		;initialize ANTIC area register
00C4E6  1  9D 00 D2     	STA	POKEY,X		;initialize POKEY area register
00C4E9  1  E0 01        	CPX	#low PORTB
00C4EB  1  F0 03        	BEQ	IHW2		;if port B, don't initialize
00C4ED  1               
00C4ED  1  9D 00 D3     	STA	PIA,X		;initialize PIA area register
00C4F0  1               
00C4F0  1  E8           IHW2	INX
00C4F1  1  D0 ED        	BNE	IHW1		;if not done
00C4F3  1               
00C4F3  1               ;	Initialize PIA.
00C4F3  1               
00C4F3  1  A9 3C        	LDA	#$3C
00C4F5  1  8D 03 D3     	STA	PBCTL	;precondition port B outputs
00C4F8  1  A9 FF        	LDA	#$FF
00C4FA  1  8D 01 D3     	STA	PORTB	;all high
00C4FD  1  A9 38        	LDA	#$38
00C4FF  1  8D 02 D3     	STA	PACTL	;select data direction register
00C502  1  8D 03 D3     	STA	PBCTL	;select data direction register
00C505  1  A9 00        	LDA	#$00
00C507  1  8D 00 D3     	STA	PORTA	;all inputs
00C50A  1  A9 FF        	LDA	#$FF
00C50C  1  8D 01 D3     	STA	PORTB	;all outputs
00C50F  1  A9 3C        	LDA	#$3C
00C511  1  8D 02 D3     	STA	PACTL	;back to port
00C514  1  8D 03 D3     	STA	PBCTL	;back to port
00C517  1  AD 01 D3     	LDA	PORTB	;clear interrupts
00C51A  1  AD 00 D3     	LDA	PORTA	;clear interrupts
00C51D  1               
00C51D  1               ;	Initialize POKEY.
00C51D  1               
00C51D  1  A9 22        	LDA	#$22	;get POKEY out of initialize mode and set ch. 4
00C51F  1  8D 0F D2     	STA	SKCTL	;set serial port control
00C522  1               
00C522  1  A9 A0        	LDA	#$A0	;pure tone, no volume
00C524  1  8D 05 D2     	STA	AUDC3	;turn off channel 3
00C527  1  8D 07 D2     	STA	AUDC4	;turn off channel 4
00C52A  1               
00C52A  1  A9 28        	LDA	#$28	;clock ch. 3 with 1.79 MHz, ch. 4 with ch. 3
00C52C  1  8D 08 D2     	STA	AUDCTL	;set audio control
00C52F  1               
00C52F  1  A9 FF        	LDA	#$FF
00C531  1  8D 0D D2     	STA	SEROUT	;start bit only
00C534  1               
00C534  1  60           	RTS		;return
00C535  1               ;	SPACE	4,10
00C535  1               ;**	ISW - Initialize Software
00C535  1               ;*
00C535  1               ;*	ENTRY	JSR	ISW
00C535  1               ;*
00C535  1               ;*	MODS
00C535  1               ;*		Original Author Unknown
00C535  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C535  1               ;*		   R. K. Nordin	11/01/83
00C535  1               
00C535  1               
00C535  1               ISW	=	*		;entry
00C535  1               
00C535  1               ;	Initialize BREAK key handling.
00C535  1               
00C535  1  C6 11        	DEC	BRKKEY		;turn off BREAK key flag
00C537  1               
00C537  1  A9 92        	LDA	#low BIR
00C539  1  8D 36 02     	STA	BRKKY		;set BREAK key IRQ routine address
00C53C  1  A9 C0        	LDA	#high BIR
00C53E  1  8D 37 02     	STA	BRKKY+1
00C541  1               
00C541  1               ;	Initialize RAMSIZ and MEMTOP.
00C541  1               
00C541  1  A5 06        	LDA	TRAMSZ		;determined size of RAM
00C543  1  8D E4 02     	STA	RAMSIZ		;size of RAM
00C546  1  8D E6 02     	STA	MEMTOP+1	;high top of memory
00C549  1  A9 00        	LDA	#$00
00C54B  1  8D E5 02     	STA	MEMTOP		;low top of memory
00C54E  1               
00C54E  1               ;	Initialize MEMLO.
00C54E  1               
00C54E  1  A9 00        	LDA	#low INIML	;initial MEMLO address
00C550  1  8D E7 02     	STA	MEMLO
00C553  1  A9 07        	LDA	#high INIML
00C555  1  8D E8 02     	STA	MEMLO+1
00C558  1               
00C558  1               ;	Initialize device handlers.
00C558  1               
00C558  1  20 0C E4     	JSR	EDITRV+12	;initialize editor handler
00C55B  1  20 1C E4     	JSR	SCRENV+12	;initialize screen handler
00C55E  1  20 2C E4     	JSR	KEYBDV+12	;initialize keyboard handler
00C561  1  20 3C E4     	JSR	PRINTV+12	;initialize printer handler
00C564  1  20 4C E4     	JSR	CASETV+12	;initialize cassette handler
00C567  1               
00C567  1               ;	Initialize various routines.
00C567  1               
00C567  1  20 6E E4     	JSR	CIOINV		;initialize CIO
00C56A  1  20 65 E4     	JSR	SIOINV		;initialize SIO
00C56D  1  20 6B E4     	JSR	INTINV		;initialize interrupt handler
00C570  1  20 50 E4     	JSR	DINITV		;initialize DIO
00C573  1               
00C573  1               ;	Initialize generic parallel device handler.
00C573  1               
00C573  1  A9 6E        	LDA	#low PIR
00C575  1  8D 38 02     	STA	VPIRQ		;parallel device IRQ routin:
00C578  1  A9 C9        	LDA	#high PIR
00C57A  1  8D 39 02     	STA	VPIRQ+1
00C57D  1               
00C57D  1  20 9B E4     	JSR	GPDVV+12	;initialize parallel device:
00C580  1               
00C580  1               ;	Set status of START key.
00C580  1               
00C580  1  AD 1F D0     	LDA	CONSOL		;console switches
00C583  1  29 01        	AND	#$01		;START key indicator
00C585  1  49 01        	EOR	#$01		;START key status
00C587  1  8D E9 03     	STA	CKEY		;cassette boot request flag
00C58A  1               
00C58A  1  60           	RTS			;return
00C58B  1               ;	SPACE	4,10
00C58B  1               ;**	ADB - Attempt Disk Boot
00C58B  1               ;*
00C58B  1               ;*	ENTRY	JSR	ADB
00C58B  1               ;*
00C58B  1               ;*	MODS
00C58B  1               ;*		Original Author Unknown
00C58B  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C58B  1               ;*		   R. K. Nordin	11/01/83
00C58B  1               
00C58B  1               
00C58B  1               ADB	=	*	;entry
00C58B  1               
00C58B  1               ;	Check type of reset.
00C58B  1               
00C58B  1  A5 08        	LDA	WARMST
00C58D  1  F0 09        	BEQ	ADB1	;if not warmstart
00C58F  1               
00C58F  1               ;	Process warmstart.
00C58F  1               
00C58F  1  A5 09        	LDA	BOOTq	;successful boot flags
00C591  1  29 01        	AND	#$01	;successful disk boot indicator
00C593  1  F0 33        	BEQ	BAI2	;if disk boot not successful, return
00C595  1               
00C595  1               ;	Initialize disk booted software.
00C595  1               
00C595  1  4C 3B C6     	JMP	IBS	;initialize booted software
00C598  1               
00C598  1               ;	Process coldstart.
00C598  1               
00C598  1  A9 01        ADB1	LDA	#1
00C59A  1  8D 01 03     	STA	DUNIT	;disk unit number
00C59D  1  A9 53        	LDA	#STATC	;status
00C59F  1  8D 02 03     	STA	DCOMND	;command
00C5A2  1  20 53 E4     	JSR	DSKINV	;issue command
00C5A5  1  30 21        	BMI	BAI2	;if error, return
00C5A7  1               
00C5A7  1               ;	Boot.
00C5A7  1               
00C5A7  1               ;	JMP	ABI	;attempt boot and initialize
00C5A7  1               ;	SPACE	4,10
00C5A7  1               ;**	ABI - Attempt Boot and Initialize
00C5A7  1               ;*
00C5A7  1               ;*	ENTRY	JSR	ABI
00C5A7  1               ;*
00C5A7  1               ;*	MODS
00C5A7  1               ;*		Original Author Unknown
00C5A7  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C5A7  1               ;*		   R. K. Nordin	11/01/83
00C5A7  1               
00C5A7  1               
00C5A7  1               ABI	=	*		;entry
00C5A7  1               
00C5A7  1  A9 00        	LDA	#high 1
00C5A9  1  8D 0B 03     	STA	DAUX2
00C5AC  1  A9 01        	LDA	#low 1		;sector number
00C5AE  1  8D 0A 03     	STA	DAUX1
00C5B1  1               
00C5B1  1  A9 00        	LDA	#low (CASBUF+3)	;buffer address
00C5B3  1  8D 04 03     	STA	DBUFLO
00C5B6  1  A9 04        	LDA	#high (CASBUF+3)
00C5B8  1  8D 05 03     	STA	DBUFHI
00C5BB  1               
00C5BB  1               ;	JMP	BAI		;boot and initialize
00C5BB  1               ;	SPACE	4,10
00C5BB  1               ;**	BAI - Boot and Initialize
00C5BB  1               ;*
00C5BB  1               ;*	ENTRY	JSR	BAI
00C5BB  1               ;*
00C5BB  1               ;*	MODS
00C5BB  1               ;*		Original Author Unknown
00C5BB  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C5BB  1               ;*		   R. K. Nordin	11/01/83
00C5BB  1               
00C5BB  1               
00C5BB  1               BAI	=	*	;entry
00C5BB  1               
00C5BB  1               ;	Read first sector.
00C5BB  1               
00C5BB  1  20 59 C6     	JSR	GNS	;get next sector
00C5BE  1  10 09        	BPL	CBI	;if no error, complete boot and initialize
00C5C0  1               
00C5C0  1               ;	Process error.
00C5C0  1               
00C5C0  1  20 3E C6     BAI1	JSR	DBE	;display boot error message
00C5C3  1               
00C5C3  1  AD EA 03     	LDA	CASSBT
00C5C6  1  F0 DF        	BEQ	ABI	;if not cassette boot, try again
00C5C8  1               
00C5C8  1               ;	Exit.
00C5C8  1               
00C5C8  1  60           BAI2	RTS		;return
00C5C9  1               ;	SPACE	4,10
00C5C9  1               ;**	CBI - Complete Boot and Initialize
00C5C9  1               ;*
00C5C9  1               ;*	ENTRY	JSR	CBI
00C5C9  1               ;*
00C5C9  1               ;*	MODS
00C5C9  1               ;*		Original Author Unknown
00C5C9  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C5C9  1               ;*		   R. K. Nordin	11/01/83
00C5C9  1               
00C5C9  1               
00C5C9  1               CBI	=	*	;entry
00C5C9  1               
00C5C9  1               ;	Transfer flags.
00C5C9  1               
00C5C9  1  A2 03        	LDX	#3
00C5CB  1               
00C5CB  1  BD 00 04     CBI1	LDA	CASBUF+3,X	;byte from buffer
00C5CE  1  9D 40 02     	STA	DFLAGS,X	;flag byte
00C5D1  1  CA           	DEX
00C5D2  1  10 F7        	BPL	CBI1		;if not done
00C5D4  1               
00C5D4  1               ;	Transfer sector.
00C5D4  1               
00C5D4  1  AD 42 02     	LDA	BOOTAD
00C5D7  1  85 04        	STA	RAMLO		;set boot address
00C5D9  1  AD 43 02     	LDA	BOOTAD+1
00C5DC  1  85 05        	STA	RAMLO+1
00C5DE  1               
00C5DE  1  AD 04 04     	LDA	CASBUF+7
00C5E1  1  85 0C        	STA	DOSINI		;establish initializtion address
00C5E3  1  AD 05 04     	LDA	CASBUF+8
00C5E6  1  85 0D        	STA	DOSINI+1
00C5E8  1               
00C5E8  1  A0 7F        CBI2	LDY	#127		;offset to last byte of sector
00C5EA  1               
00C5EA  1  B9 00 04     CBI3	LDA	CASBUF+3,Y	;byte of sector buffer
00C5ED  1  91 04        	STA	(RAMLO),Y	;byte of boot program
00C5EF  1  88           	DEY
00C5F0  1  10 F8        	BPL	CBI3		;if not done
00C5F2  1               
00C5F2  1               ;	Increment loader buffer pointer.
00C5F2  1               
00C5F2  1  18           	CLC
00C5F3  1  A5 04        	LDA	RAMLO
00C5F5  1  69 80        	ADC	#$80
00C5F7  1  85 04        	STA	RAMLO
00C5F9  1  A5 05        	LDA	RAMLO+1
00C5FB  1  69 00        	ADC	#0
00C5FD  1  85 05        	STA	RAMLO+1		;increment boot loader buffer pointer
00C5FF  1               
00C5FF  1               ;	Decrement and check number of sectors.
00C5FF  1               
00C5FF  1  CE 41 02     	DEC	DBSECT		;decrement number of sectors
00C602  1  F0 12        	BEQ	CBI5		;if no more sectors
00C604  1               
00C604  1               ;	Get next sector.
00C604  1               
00C604  1  EE 0A 03     	INC	DAUX1	;increment sector number
00C607  1               
00C607  1  20 59 C6     CBI4	JSR	GNS	;get next sector
00C60A  1  10 DC        	BPL	CBI2	;if status OK
00C60C  1               
00C60C  1               ;	Process error.
00C60C  1               
00C60C  1  20 3E C6     	JSR	DBE	;display boot error message
00C60F  1  AD EA 03     	LDA	CASSBT
00C612  1  D0 AC        	BNE	BAI1	;if cassette, start over
00C614  1               
00C614  1  F0 F1        	BEQ	CBI4	;try sector again
00C616  1               
00C616  1               ;	Clean up.
00C616  1               
00C616  1  AD EA 03     CBI5	LDA	CASSBT
00C619  1  F0 03        	BEQ	CBI6	;if not cassette boot
00C61B  1               
00C61B  1  20 59 C6     	JSR	GNS	;get EOF record (but do not use it)
00C61E  1               
00C61E  1               ;	Execute boot loader.
00C61E  1               
00C61E  1  20 29 C6     CBI6	JSR	EBL	;execute boot loader
00C621  1  B0 9D        	BCS	BAI1	;if bad boot, try again
00C623  1               
00C623  1               ;	Initialize booted software.
00C623  1               
00C623  1  20 3B C6     	JSR	IBS	;initialize booted software
00C626  1  E6 09        	INC	BOOTq	;indicate boot success
00C628  1  60           	RTS		;return
00C629  1               ;	SPACE	4,10
00C629  1               ;**	EBL - Execute Boot Loader
00C629  1               ;*
00C629  1               ;*	ENTRY	JSR	EBL
00C629  1               ;*
00C629  1               ;*	MODS
00C629  1               ;*		Original Author Unknown
00C629  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C629  1               ;*		   R. K. Nordin	11/01/83
00C629  1               
00C629  1               
00C629  1               EBL	=	*		;entry
00C629  1               
00C629  1               ;	Move boot loader start address to RAMLO.
00C629  1               
00C629  1  18           	CLC
00C62A  1  AD 42 02     	LDA	BOOTAD
00C62D  1  69 06        	ADC	#6
00C62F  1  85 04        	STA	RAMLO		;boot loader start address
00C631  1  AD 43 02     	LDA	BOOTAD+1
00C634  1  69 00        	ADC	#0
00C636  1  85 05        	STA	RAMLO+1
00C638  1               
00C638  1               ;	Execute boot loader.
00C638  1               
00C638  1  6C 04 00     	JMP	(RAMLO)		;execute boot loader
00C63B  1               ;	SPACE	4,10
00C63B  1               ;**	IBS - Initialize Booted Software
00C63B  1               ;*
00C63B  1               ;*	ENTRY	JSR	IBS
00C63B  1               ;*
00C63B  1               ;*	MODS
00C63B  1               ;*		Original Author Unknown
00C63B  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C63B  1               ;*		   R. K. Nordin	11/01/83
00C63B  1               
00C63B  1               
00C63B  1               IBS	=	*		;entry
00C63B  1  6C 0C 00     	JMP	(DOSINI)	;initialize booted software
00C63E  1               ;	SPACE	4,10
00C63E  1               ;**	DBE - Display Boot Error Message
00C63E  1               ;*
00C63E  1               ;*	ENTRY	JSR	DBE
00C63E  1               ;*
00C63E  1               ;*	NOTES
00C63E  1               ;*		Problem: bytes wasted by LDX/TXA and LDY/TYA
00C63E  1               ;*		combinations.
00C63E  1               ;*
00C63E  1               ;*	MODS
00C63E  1               ;*		Original Author Unknown
00C63E  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C63E  1               ;*		   R. K. Nordin	11/01/83
00C63E  1               
00C63E  1               
00C63E  1               DBE	=	*		;entry
00C63E  1               
00C63E  1               ;	Set up IOCB.
00C63E  1               
00C63E  1  A2 3D        	LDX	#low BMSG	;boot error message
00C640  1  A0 C4        	LDY	#high BMSG
00C642  1  8A           	TXA
00C643  1  A2 00        	LDX	#SEIOCB		;screen editor IOCB index
00C645  1  9D 44 03     	STA	ICBAL,X 	;low buffer address
00C648  1  98           	TYA
00C649  1  9D 45 03     	STA	ICBAH,X		;high buffer address
00C64C  1  A9 09        	LDA	#PUTREC
00C64E  1  9D 42 03     	STA	ICCOM,X		;command
00C651  1  A9 FF        	LDA	#$FF
00C653  1  9D 48 03     	STA	ICBLL,X		;buffer length
00C656  1               
00C656  1               ;	Perform CIO.
00C656  1               
00C656  1  4C 56 E4     	JMP	CIOV		;vector to CIO, return
00C659  1               ;	SPACE	4,10
00C659  1               ;**	GNS - Get Next Sector
00C659  1               ;*
00C659  1               ;*	ENTRY	JSR	GNS
00C659  1               ;*
00C659  1               ;*	MODS
00C659  1               ;*		Original Author Unknown
00C659  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C659  1               ;*		   R. K. Nordin	11/01/83
00C659  1               
00C659  1               
00C659  1               GNS	=	*	;entry
00C659  1               
00C659  1               ;	Check type of boot.
00C659  1               
00C659  1  AD EA 03     	LDA	CASSBT
00C65C  1  F0 03        	BEQ	GNS1	;if not cassette boot
00C65E  1               
00C65E  1               ;	Read block from cassette.
00C65E  1               
00C65E  1  4C 7A E4     	JMP	RBLOKV	;vector to read cassette block routine, return
00C661  1               
00C661  1               ;	Read sector from disk.
00C661  1               
00C661  1  A9 52        GNS1	LDA	#READ
00C663  1  8D 02 03     	STA	DCOMND	;command
00C666  1  A9 01        	LDA	#1	;drive number 1
00C668  1  8D 01 03     	STA	DUNIT	;set drive number
00C66B  1  4C 53 E4     	JMP	DSKINV	;vector to DIO, return
00C66E  1               ;	SPACE	4,10
00C66E  1               ;**	ACB - Attempt Cassette Boot
00C66E  1               ;*
00C66E  1               ;*	ENTRY	JSR	ACB
00C66E  1               ;*
00C66E  1               ;*	MODS
00C66E  1               ;*		Original Author Unknown
00C66E  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C66E  1               ;*		   R. K. Nordin	11/01/83
00C66E  1               
00C66E  1               
00C66E  1               ACB	=	*	;entry
00C66E  1               
00C66E  1               ;	Check type.
00C66E  1               
00C66E  1  A5 08        	LDA	WARMST	;warmstart flag
00C670  1  F0 09        	BEQ	ACB1	;if coldstart
00C672  1               
00C672  1               ;	Perform warmstart procedures.
00C672  1               
00C672  1  A5 09        	LDA	BOOTq	;successful boot flags
00C674  1  29 02        	AND	#$02	;successful cassette boot indicator
00C676  1  F0 27        	BEQ	ACB2	;if cassette boot not successful
00C678  1               
00C678  1  4C A0 C6     	JMP	ACB3	;initialize cassette
00C67B  1               
00C67B  1               ;	Perform coldstart procedures.
00C67B  1               
00C67B  1  AD E9 03     ACB1	LDA	CKEY	;cassette boot request flag
00C67E  1  F0 1F        	BEQ	ACB2	;if cassette boot not requested, return
00C680  1               
00C680  1               ;	Boot cassette.
00C680  1               
00C680  1  A9 80        	LDA	#$80
00C682  1  85 3E        	STA	FTYPE	;set long IRG type
00C684  1  EE EA 03     	INC	CASSBT	;set cassette boot flag
00C687  1  20 7D E4     	JSR	CSOPIV	;open cassette for input
00C68A  1  20 BB C5     	JSR	BAI	;boot and initialize
00C68D  1  A9 00        	LDA	#0
00C68F  1  8D EA 03     	STA	CASSBT	;clear cassette boot flag
00C692  1  8D E9 03     	STA	CKEY	;clear cassette boot request flag
00C695  1  06 09        	ASL	BOOTq	;indicate successful cassette boot
00C697  1               
00C697  1  A5 0C        	LDA	DOSINI
00C699  1  85 02        	STA	CASINI	;cassette software initialization address
00C69B  1  A5 0D        	LDA	DOSINI+1
00C69D  1  85 03        	STA	CASINI+1
00C69F  1               
00C69F  1               ;	Exit.
00C69F  1               
00C69F  1  60           ACB2	RTS		;return
00C6A0  1               
00C6A0  1               ;	Initialize cassette booted program.
00C6A0  1               
00C6A0  1  6C 02 00     ACB3	JMP	(CASINI)	;initialize cassette booted program
00C6A3  1               ;	SUBTTL	'Disk Input/Ouput'
00C6A3  1               ;	SPACE	4,10
00C6A3  1               ;**	IDIO - Initialize DIO
00C6A3  1               ;*
00C6A3  1               ;*	ENTRY	JSR	IDIO
00C6A3  1               ;*
00C6A3  1               ;*	MODS
00C6A3  1               ;*		Original Author Unknown
00C6A3  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C6A3  1               ;*		   R. K. Nordin	11/01/83
00C6A3  1               
00C6A3  1               
00C6A3  1               IDIO	=	*		;entry
00C6A3  1  A9 A0        	LDA	#160		;160 second timeout
00C6A5  1  8D 46 02     	STA	DSKTIM		;set initial disk timeout
00C6A8  1  A9 80        	LDA	#low DSCTSZ	;disk sector size
00C6AA  1  8D D5 02     	STA	DSCTLN
00C6AD  1  A9 00        	LDA	#high DSCTSZ
00C6AF  1  8D D6 02     	STA	DSCTLN+1
00C6B2  1  60           	RTS			;return
00C6B3  1               ;	SPACE	4,10
00C6B3  1               ;**	DIO - Disk I/O
00C6B3  1               ;*
00C6B3  1               ;*	ENTRY	JSR	DIO
00C6B3  1               ;*
00C6B3  1               ;*	MODS
00C6B3  1               ;*		Original Author Unknown
00C6B3  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C6B3  1               ;*		   R. K. Nordin	11/01/83
00C6B3  1               
00C6B3  1               
00C6B3  1               DIO	=	*		;entry
00C6B3  1               
00C6B3  1               ;	Initialize.
00C6B3  1               
00C6B3  1  A9 31        	LDA	#DISKID		;disk bus ID
00C6B5  1  8D 00 03     	STA	DDEVIC		;device bus ID
00C6B8  1  AD 46 02     	LDA	DSKTIM		;timeout
00C6BB  1  AE 02 03     	LDX	DCOMND		;command
00C6BE  1  E0 21        	CPX	#FOMAT
00C6C0  1  F0 02        	BEQ	DIO1		;if FORMAT command
00C6C2  1               
00C6C2  1  A9 07        	LDA	#7		;set timeout to 7 seconds
00C6C4  1               
00C6C4  1  8D 06 03     DIO1	STA	DTIMLO		;timeout
00C6C7  1               
00C6C7  1               ;	Set SIO command.
00C6C7  1               
00C6C7  1  A2 40        	LDX	#GETDAT		;assume GET DATA
00C6C9  1               
00C6C9  1  AD 02 03     	LDA	DCOMND		;command
00C6CC  1  C9 50        	CMP	#PUTSEC
00C6CE  1  F0 04        	BEQ	DIO2		;if PUT SECTOR command
00C6D0  1               
00C6D0  1  C9 57        	CMP	#WRITE
00C6D2  1  D0 02        	BNE	DIO3		;if not WRITE command
00C6D4  1               
00C6D4  1  A2 80        DIO2	LDX	#PUTDAT		;select PUT DATA
00C6D6  1               
00C6D6  1               ;	Check command.
00C6D6  1               
00C6D6  1  C9 53        DIO3	CMP	#STATC
00C6D8  1  D0 10        	BNE	DIO4		;if not STATUS command
00C6DA  1               
00C6DA  1               ;	Set up STATUS command.
00C6DA  1               
00C6DA  1  A9 EA        	LDA	#low DVSTAT
00C6DC  1  8D 04 03     	STA	DBUFLO		;buffer address
00C6DF  1  A9 02        	LDA	#high DVSTAT
00C6E1  1  8D 05 03     	STA	DBUFHI
00C6E4  1  A0 04        	LDY	#low 4		;low byte count
00C6E6  1  A9 00        	LDA	#high 4		;high byte count
00C6E8  1  F0 06        	BEQ	DIO5		;perform SIO
00C6EA  1               
00C6EA  1               ;	Set up other commands.
00C6EA  1               
00C6EA  1  AC D5 02     DIO4	LDY	DSCTLN		;low byte count
00C6ED  1  AD D6 02     	LDA	DSCTLN+1	;high byte count
00C6F0  1               
00C6F0  1               ;	Perform SIO.
00C6F0  1               
00C6F0  1  8E 03 03     DIO5	STX	DSTATS		;SIO command
00C6F3  1  8C 08 03     	STY	DBYTLO		;low byte count
00C6F6  1  8D 09 03     	STA	DBYTHI		;high byte count
00C6F9  1  20 59 E4     	JSR	SIOV		;vector to SIO
00C6FC  1  10 01        	BPL	DIO6		;if no error
00C6FE  1               
00C6FE  1               ;	Process error.
00C6FE  1               
00C6FE  1  60           	RTS			;return
00C6FF  1               
00C6FF  1               ;	Process successful operation.
00C6FF  1               
00C6FF  1  AD 02 03     DIO6	LDA	DCOMND		;command
00C702  1  C9 53        	CMP	#STATC
00C704  1  D0 0A        	BNE	DIO7		;if not STATUS command
00C706  1               
00C706  1  20 3A C7     	JSR	SBA		;set buffer address
00C709  1  A0 02        	LDY	#2
00C70B  1  B1 15        	LDA	(BUFADR),Y	;timeout status
00C70D  1  8D 46 02     	STA	DSKTIM		;disk timeout
00C710  1               
00C710  1               ;	Set byte count.
00C710  1               
00C710  1  AD 02 03     DIO7	LDA	DCOMND
00C713  1  C9 21        	CMP	#FOMAT
00C715  1  D0 1F        	BNE	DIO10		;if not FORMAT command
00C717  1               
00C717  1  20 3A C7     	JSR	SBA		;set buffer address
00C71A  1  A0 FE        	LDY	#$FE		;initial buffer pointer
00C71C  1               
00C71C  1  C8           DIO8	INY			;increment buffer pointer
00C71D  1  C8           	INY			;increment buffer pointer
00C71E  1               
00C71E  1  B1 15        DIO9	LDA	(BUFADR),Y	;low bad sector data
00C720  1  C9 FF        	CMP	#$FF
00C722  1  D0 F8        	BNE	DIO8		;if low not $FF
00C724  1               
00C724  1  C8           	INY
00C725  1  B1 15        	LDA	(BUFADR),Y	;high bad sector data
00C727  1  C8           	INY
00C728  1  C9 FF        	CMP	#$FF
00C72A  1  D0 F2        	BNE	DIO9		;if high not $FF
00C72C  1               
00C72C  1  88           	DEY
00C72D  1  88           	DEY
00C72E  1  8C 08 03     	STY	DBYTLO		;low bad sector byte count
00C731  1  A9 00        	LDA	#0
00C733  1  8D 09 03     	STA	DBYTHI		;high bad sector byte count
00C736  1               
00C736  1               ;	Exit.
00C736  1               
00C736  1  AC 03 03     DIO10	LDY	DSTATS		;status
00C739  1  60           	RTS			;return
00C73A  1               ;	SPACE	4,10
00C73A  1               ;**	SBA - Set Buffer Address
00C73A  1               ;*
00C73A  1               ;*	ENTRY	JSR	SBA
00C73A  1               ;*
00C73A  1               ;*	MODS
00C73A  1               ;*		Original Author Unknown
00C73A  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C73A  1               ;*		   R. K. Nordin	11/01/83
00C73A  1               
00C73A  1               
00C73A  1               SBA	=	*		;entry
00C73A  1  AD 04 03     	LDA	DBUFLO
00C73D  1  85 15        	STA	BUFADR		;buffer address
00C73F  1  AD 05 03     	LDA	DBUFHI
00C742  1  85 16        	STA	BUFADR+1
00C744  1  60           	RTS			;return
00C745  1               ;	SUBTTL	'Relocating Loader'
00C745  1               ;	SPACE	4,10
00C745  1               ;**	RLR - Relocate Routine
00C745  1               ;*
00C745  1               ;*	RLR relocates a relocatable routine which is assemb:
00C745  1               ;*	origin 0.
00C745  1               ;*
00C745  1               ;*	ENTRY	JSR	RLR
00C745  1               ;*		GBYTEA - GBYTEA+1 = address of get-byte rou:
00C745  1               ;*
00C745  1               ;*	MODS
00C745  1               ;*		Y. M. Chen	04/01/82
00C745  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C745  1               ;*		   R. K. Nordin	11/01/83
00C745  1               
00C745  1               
00C745  1               RLR	=	*		;entry
00C745  1               
00C745  1               ;	Clear parameter block.
00C745  1               
00C745  1  A2 05        	LDX	#5		;offset to last parameter
00C747  1               
00C747  1  A9 00        RLR1	LDA	#0
00C749  1  9D C9 02     	STA	PARMBL,X	;clear byte of parameter bl:
00C74C  1  CA           	DEX
00C74D  1  10 F8        	BPL	RLR1		;if not done
00C74F  1               
00C74F  1               ;	Get a new record type and set the subroutine vector:
00C74F  1               
00C74F  1  A9 00        RLR2	LDA	#0
00C751  1  8D 33 02     	STA	LCOUNT		;process 0th byte of a reco:
00C754  1  20 CF C7     	JSR	GBY		;get type ID
00C757  1  A0 9C        	LDY	#DATAER
00C759  1  B0 39        	BCS	RLR4		;if EOF before END record
00C75B  1               
00C75B  1  8D 88 02     	STA	HIBYTE		;save type ID
00C75E  1  20 CF C7     	JSR	GBY		;get record length
00C761  1  A0 9C        	LDY	#DATAER
00C763  1  B0 2F        	BCS	RLR4		;if EOF before END record
00C765  1               
00C765  1  8D 45 02     	STA	RECLEN
00C768  1  AD 88 02     	LDA	HIBYTE		;get type ID
00C76B  1  C9 0B        	CMP	#$0B		;END record
00C76D  1  F0 26        	BEQ	END		;if END record
00C76F  1               
00C76F  1  2A           	ROL	A		;set subroutine vectors
00C770  1  AA           	TAX
00C771  1  BD E4 C8     	LDA	TRPR,X
00C774  1  8D C9 02     	STA	RUNADR
00C777  1  BD E5 C8     	LDA	TRPR+1,X
00C77A  1  8D CA 02     	STA	RUNADR+1
00C77D  1               
00C77D  1  AD 45 02     RLR3	LDA	RECLEN
00C780  1  CD 33 02     	CMP	LCOUNT
00C783  1  F0 CA        	BEQ	RLR2		;if LCOUNT=RECLEN, get new :
00C785  1               
00C785  1  20 CF C7     	JSR	GBY		;get next byte
00C788  1  A0 9C        	LDY	#DATAER
00C78A  1  B0 08        	BCS	RLR4		;if EOF before END record
00C78C  1               
00C78C  1  20 D2 C7     	JSR	CAL		;call record subroutine
00C78F  1  EE 33 02     	INC	LCOUNT
00C792  1  D0 E9        	BNE	RLR3		;continue
00C794  1               
00C794  1  60           RLR4	RTS			;return
00C795  1               ;	SPACE	4,10
00C795  1               ;**	END - Handle END Record
00C795  1               ;*
00C795  1               ;*	END handles record type of
00C795  1               ;*	1.End Record
00C795  1               ;*
00C795  1               ;*	Record format:
00C795  1               ;*	Byte 0		Type ID
00C795  1               ;*	Byte 1		Self-start flag
00C795  1               ;*	Bytes 2 - 3	Run address
00C795  1               ;*
00C795  1               ;*	Process formula
00C795  1               ;*
00C795  1               ;*	RUNADR+LOADAD ==> Start Execution Address n Loader-:
00C795  1               ;*	parameter block.
00C795  1               ;*
00C795  1               ;*	End record calculates the start execution address b:
00C795  1               ;*	RUNADR with LOADAD, and returns to the Caller with :
00C795  1               ;*	block and a status byte in the Y register. Y=1 mean:
00C795  1               ;*	successful, else is a data structure error.
00C795  1               ;*
00C795  1               ;*	ENTRY	JSR	END
00C795  1               ;*
00C795  1               ;*	MODS
00C795  1               ;*		Y. M. Chen	04/01/82
00C795  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C795  1               ;*		   R. K. Nordin	11/01/83
00C795  1               
00C795  1               
00C795  1               END	=	*	;entry
00C795  1  20 CF C7     	JSR	GBY	;get low byte of the RUNADR
00C798  1  A0 9C        	LDY	#DATAER
00C79A  1  B0 2C        	BCS	END3	;if EOF before END record
00C79C  1               
00C79C  1  8D C9 02     	STA	RUNADR
00C79F  1  20 CF C7     	JSR	GBY	;get high byte of the RUNADR
00C7A2  1  A0 9C        	LDY	#DATAER
00C7A4  1  B0 22        	BCS	END3	;if EOF before END record
00C7A6  1               
00C7A6  1  8D CA 02     	STA	RUNADR+1
00C7A9  1  AD 45 02     	LDA	RECLEN	;RECLEN here is self-start flag
00C7AC  1  C9 01        	CMP	#1
00C7AE  1  F0 16        	BEQ	END2	;if 1, an absolute RUNADR, no fixup
00C7B0  1               
00C7B0  1  90 17        	BCC	END4	;if 0, this is not a self-start pro:
00C7B2  1               
00C7B2  1               ;	Process relative start.
00C7B2  1               
00C7B2  1  18           	CLC
00C7B3  1  AD C9 02     	LDA	RUNADR		;execution address, needs f:
00C7B6  1  6D D1 02     	ADC	LOADAD
00C7B9  1  A8           	TAY
00C7BA  1  AD CA 02     	LDA	RUNADR+1
00C7BD  1  6D D2 02     	ADC	LOADAD+1	;A= high byte, Y=low byte
00C7C0  1               
00C7C0  1  8C C9 02     END1	STY	RUNADR		;set up Loader-Caller param:
00C7C3  1  8D CA 02     	STA	RUNADR+1
00C7C6  1               
00C7C6  1  A0 01        END2	LDY	#SUCCES		;Y=1 successful operation
00C7C8  1               
00C7C8  1  60           END3	RTS			;return
00C7C9  1               
00C7C9  1  A0 00        END4	LDY	#0		;fill self-start parameter :
00C7CB  1  A9 00        	LDA	#0		;for non-self start program
00C7CD  1  F0 F1        	BEQ	END1		;continue
00C7CF  1               ;	SPACE	4,10
00C7CF  1               ;**	GBY - Get Byte
00C7CF  1               ;*
00C7CF  1               ;*	ENTRY	JSR	GBY
00C7CF  1               ;*
00C7CF  1               ;*	MODS
00C7CF  1               ;*		Y. M. Chen	04/01/82
00C7CF  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C7CF  1               ;*		   R. K. Nordin	11/01/83
00C7CF  1               
00C7CF  1               
00C7CF  1               GBY	=	*		;entry
00C7CF  1  6C CF 02     	JMP	(GBYTEA)	;get byte, return
00C7D2  1               ;	SPACE	4,10
00C7D2  1               ;**	CAL - Execute at Run Address
00C7D2  1               ;*
00C7D2  1               ;*	ENTRY	JSR	CAL
00C7D2  1               ;*
00C7D2  1               ;*	MODS
00C7D2  1               ;*		Y. M. Chen	04/01/82
00C7D2  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C7D2  1               ;*		   R. K. Nordin	11/01/83
00C7D2  1               
00C7D2  1               
00C7D2  1               CAL	=	*		;entry
00C7D2  1  6C C9 02     	JMP	(RUNADR)	;process record, return
00C7D5  1               ;	SPACE	4,10
00C7D5  1               ;**	TEX - Handle Text Record
00C7D5  1               ;*
00C7D5  1               ;*	TEX handles record types of
00C7D5  1               ;*
00C7D5  1               ;*	1.Non-zero page relocatable text
00C7D5  1               ;*	2.Zero page relocatable text
00C7D5  1               ;*	3.Absolute text
00C7D5  1               ;*
00C7D5  1               ;*	Record format
00C7D5  1               ;*
00C7D5  1               ;*	|Type	|Length		|Relative addr.	|text	|
00C7D5  1               ;*	|ID	|(RECLEN)	|(RELADR)	|	|
00C7D5  1               ;*
00C7D5  1               ;*	Process formula
00C7D5  1               ;*	A register ===> (NEWADR+LCOUNT)
00C7D5  1               ;*
00C7D5  1               ;*	Relocate object text into fixed address of NEWADR+L:
00C7D5  1               ;*
00C7D5  1               ;*	ENTRY	JSR	TEX
00C7D5  1               ;*
00C7D5  1               ;*	NOTES
00C7D5  1               ;*
00C7D5  1               ;*	1.The relocating address (NEWADR) for absolute text:
00C7D5  1               ;*	relative address (RELADR), relocating address fixup:
00C7D5  1               ;*	needed.
00C7D5  1               ;*	2.There is no need to compare MEMTOP for processing:
00C7D5  1               ;*	text.
00C7D5  1               ;*	3.X register is used as an indexing to zero page va:
00C7D5  1               ;*	or non-zero page variables.	X=0 means pointing :
00C7D5  1               ;*	page fariable, whereas X=2 means pointing to zero p:
00C7D5  1               ;*	variables.
00C7D5  1               ;*	4.Each byte of the object text comes in A register.
00C7D5  1               ;*
00C7D5  1               ;*	MODS
00C7D5  1               ;*		Y. M. Chen	04/01/82
00C7D5  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C7D5  1               ;*		   R. K. Nordin	11/01/83
00C7D5  1               
00C7D5  1               
00C7D5  1               TEX	=	*	;entry
00C7D5  1  AC 33 02     	LDY	LCOUNT	;A register=data coming in
00C7D8  1  C0 01        	CPY	#$01
00C7DA  1  F0 0A        	BEQ	TEX1	;if 1, process highest used address
00C7DC  1               
00C7DC  1  B0 73        	BCS	FTX	;if 2 or greater, relocate object t:
00C7DE  1               
00C7DE  1  8D 4A 02     	STA	RELADR
00C7E1  1  8D 8E 02     	STA	NEWADR	;for absolute text NEWADR=RELADR
00C7E4  1  90 6A        	BCC	TEX8
00C7E6  1               
00C7E6  1               ;	Set highest used address.
00C7E6  1               
00C7E6  1  8D 4B 02     TEX1	STA	RELADR+1	;save high byte of RELADR
00C7E9  1  8D 8F 02     	STA	NEWADR+1	;for absolute text NEWADR=R:
00C7EC  1  A2 00        	LDX	#0		;X=an index to non-zero or :
00C7EE  1  AD 88 02     	LDA	HIBYTE		;HIBYTE=Type ID
00C7F1  1  F0 06        	BEQ	TEX2		;if 0, process non-zero pag:
00C7F3  1  C9 0A        	CMP	#$0A
00C7F5  1  F0 15        	BEQ	TEX3		;if $0A, needs no relative :
00C7F7  1               
00C7F7  1  A2 02        	LDX	#2		;X=2 for zero page text rec:
00C7F9  1               
00C7F9  1  18           TEX2	CLC			;fix relocating addr. for n:
00C7FA  1  AD 4A 02     	LDA	RELADR		;text & zero page text
00C7FD  1  7D D1 02     	ADC	LOADAD,X	;NEWADR=RELADR+LOADAD
00C800  1  8D 8E 02     	STA	NEWADR
00C803  1  AD 4B 02     	LDA	RELADR+1
00C806  1  7D D2 02     	ADC	LOADAD+1,X
00C809  1  8D 8F 02     	STA	NEWADR+1	;Loader start relocating
00C80C  1               
00C80C  1  18           TEX3	CLC
00C80D  1  AD 8E 02     	LDA	NEWADR	;NEWADR+RECLEN is the last used mem:
00C810  1  6D 45 02     	ADC	RECLEN	;for this particular record
00C813  1  48           	PHA
00C814  1  A9 00        	LDA	#0	;A=high byte, S=low byte
00C816  1  6D 8F 02     	ADC	NEWADR+1
00C819  1  A8           	TAY		;high byte
00C81A  1  68           	PLA		;low byte
00C81B  1  38           	SEC
00C81C  1  E9 02        	SBC	#2	;skip unwanted 2 bytes of relative :
00C81E  1  B0 01        	BCS	TEX4
00C820  1               
00C820  1  88           	DEY
00C821  1               
00C821  1  48           TEX4	PHA
00C822  1  98           	TYA
00C823  1  DD CC 02     	CMP	HIUSED+1,X	;HIUSED stores the highest :
00C826  1  68           	PLA
00C827  1  90 10        	BCC	TEX6		;if HIUSED>(NEWADR+RECLEN),:
00C829  1               
00C829  1  D0 05        	BNE	TEX5		;if HIUSED<=(NEWADR+RECLEN)
00C82B  1               
00C82B  1  DD CB 02     	CMP	HIUSED,X
00C82E  1  90 09        	BCC	TEX6
00C830  1               
00C830  1               ;	Update HIUSED.
00C830  1               
00C830  1  9D CB 02     TEX5	STA	HIUSED,X	;update HIUSED
00C833  1  48           	PHA
00C834  1  98           	TYA
00C835  1  9D CC 02     	STA	HIUSED+1,X
00C838  1  68           	PLA
00C839  1               
00C839  1  AE 88 02     TEX6	LDX	HIBYTE
00C83C  1  E0 01        	CPX	#$01
00C83E  1  F0 10        	BEQ	TEX8	;if zero page text
00C840  1               
00C840  1               ;	Check MEMTOP.
00C840  1               
00C840  1  CC E6 02     	CPY	MEMTOP+1	;MEMTOP>HIUSED, OK
00C843  1  90 0B        	BCC	TEX8
00C845  1               
00C845  1  D0 05        	BNE	TEX7
00C847  1               
00C847  1  CD E5 02     	CMP	MEMTOP
00C84A  1  90 04        	BCC	TEX8
00C84C  1               
00C84C  1  68           TEX7	PLA			;MEMTOP<=HIUSED then error
00C84D  1  68           	PLA			;do a force return to calle:
00C84E  1  A0 9D        	LDY	#MEMERR		;set memory insufficient fl:
00C850  1               
00C850  1  60           TEX8	RTS			;return
00C851  1               ;	SPACE	4,10
00C851  1               ;**	FTX - Relocate Text into Memory
00C851  1               ;*
00C851  1               ;*	ENTRY	JSR	FTX
00C851  1               ;*
00C851  1               ;*	NOTES
00C851  1               ;*		Problem: bytes wasted by JMP to RTS.
00C851  1               ;*
00C851  1               ;*	MODS
00C851  1               ;*		Y. M. Chen	04/01/82
00C851  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C851  1               ;*		   R. K. Nordin	11/01/83
00C851  1               
00C851  1               
00C851  1               FTX	=	*	;entry
00C851  1  38           	SEC
00C852  1  48           	PHA		;A register has object text
00C853  1  AD 33 02     	LDA	LCOUNT	;LCOUNT counts 2 bytes of relative :
00C856  1  E9 02        	SBC	#2	;-2 is the total bytes of object te:
00C858  1  18           	CLC
00C859  1  6D 8E 02     	ADC	NEWADR
00C85C  1  85 36        	STA	LTEMP	;A ===>(NEWADR+LCOUNT-2)
00C85E  1  A9 00        	LDA	#0
00C860  1  6D 8F 02     	ADC	NEWADR+1
00C863  1  85 37        	STA	LTEMP+1
00C865  1  68           	PLA
00C866  1  A0 00        	LDY	#0
00C868  1  91 36        	STA	(LTEMP),Y
00C86A  1  4C 50 C8     	JMP	TEX8	;return
00C86D  1               ;	SPACE	4,10
00C86D  1               ;**	WOR - Handle Word Reference Record Type
00C86D  1               ;*
00C86D  1               ;*	WOR handles record types of
00C86D  1               ;*
00C86D  1               ;*	1.Non-zero page word references to non-zero page.
00C86D  1               ;*	2.Zero page word references to non-zero page.
00C86D  1               ;*
00C86D  1               ;*	Record format
00C86D  1               ;*
00C86D  1               ;*	|Type	|Length		|Offset1|Offset2|Offsetn|
00C86D  1               ;*	|ID	|(RECLEN)	|A Reg.	|	|	|
00C86D  1               ;*
00C86D  1               ;*	Process formula
00C86D  1               ;*
00C86D  1               ;*	(A register +NEWADR)W +LOADAD ===> (NEWADR+ A regis:
00C86D  1               ;*
00C86D  1               ;*	Count, the offset from the start relocating address:
00C86D  1               ;*	low byte
00C86D  1               ;*	of a word needing to be fixed.  The fixup process i:
00C86D  1               ;*	content of the word and add loading address, then r:
00C86D  1               ;*	fixed word.
00C86D  1               ;*
00C86D  1               ;*	Offset information comes in A register.
00C86D  1               ;*
00C86D  1               ;*	ENTRY	JSR	WOR
00C86D  1               ;*
00C86D  1               ;*	MODS
00C86D  1               ;*		Y. M. Chen	04/01/82
00C86D  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C86D  1               ;*		   R. K. Nordin	11/01/83
00C86D  1               
00C86D  1               
00C86D  1               WOR	=	*		;entry
00C86D  1  18           	CLC
00C86E  1  6D 8E 02     	ADC	NEWADR		;offset in A register
00C871  1  85 36        	STA	LTEMP
00C873  1  A9 00        	LDA	#0
00C875  1  6D 8F 02     	ADC	NEWADR+1
00C878  1  85 37        	STA	LTEMP+1		;offset +NEWADR= LTEMP
00C87A  1  A0 00        	LDY	#0
00C87C  1  B1 36        	LDA	(LTEMP),Y	;get low byte content of wh:
00C87E  1  18           	CLC
00C87F  1  6D D1 02     	ADC	LOADAD		;fix low byte of a word
00C882  1  91 36        	STA	(LTEMP),Y
00C884  1  E6 36        	INC	LTEMP		;increment LTEMP pointer by:
00C886  1  D0 02        	BNE	WOR1		;if low not zero
00C888  1               
00C888  1  E6 37        	INC	LTEMP+1		;increment high
00C88A  1               
00C88A  1  B1 36        WOR1	LDA	(LTEMP),Y	;fix high byte of a word
00C88C  1  6D D2 02     	ADC	LOADAD+1
00C88F  1  91 36        	STA	(LTEMP),Y	;restore processed content
00C891  1  60           	RTS			;return
00C892  1               ;	SPACE	4,10
00C892  1               ;**	LOO - Handle Low Byte and One Byte Record Types
00C892  1               ;*
00C892  1               ;*	LOO handles record types of
00C892  1               ;*
00C892  1               ;*	1.Non-zero page low byte references to non-zero ppa:
00C892  1               ;*	2.Zero page low byte references to non-zero page.
00C892  1               ;*	3.Non-zero page one byte references to zero page.
00C892  1               ;*	4.Zero page one byte references to zero page.
00C892  1               ;*
00C892  1               ;*	Record format
00C892  1               ;*
00C892  1               ;*	|Type	|Length		|Offset1|Offset2|Offsetn|
00C892  1               ;*	|ID	|(RECLEN)	|A Reg.	|A Reg.	|	|
00C892  1               ;*
00C892  1               ;*	The process formula for non-zero page low byte refe:
00C892  1               ;*	non-zero page record and zero page low byte referen:
00C892  1               ;*	non-zero page record is
00C892  1               ;*
00C892  1               ;*	(offset + NEWADR)+LOADAD ===> (offset +NEWADR)
00C892  1               ;*
00C892  1               ;*	The process formula for non-zero page one byte refe:
00C892  1               ;*	zero
00C892  1               ;*	page record and zero page one byte references to ze:
00C892  1               ;*	record
00C892  1               ;*	is
00C892  1               ;*
00C892  1               ;*	(offset + NEWADR)+LOADADZ ===> (offset + NEWADR)
00C892  1               ;*
00C892  1               ;*	Count from the offset from the start relocating add:
00C892  1               ;*	low byte or one byte need to be fixed. Get the cont:
00C892  1               ;*	low byte or one byteand add either LOADAD or LOADAD:
00C892  1               ;*	page loading address), then restore the value.
00C892  1               ;*
00C892  1               ;*	The offset comes in A register.
00C892  1               ;*
00C892  1               ;*	The X register for this routine points to either no:
00C892  1               ;*	variables or zero page variables. Record type 2 & 3:
00C892  1               ;*	non-zero page variable, type 4 & 5 needs zero page :
00C892  1               ;*
00C892  1               ;*	X=2 points to zero page variable.
00C892  1               ;*
00C892  1               ;*	ENTRY	JSR	LOO
00C892  1               ;*
00C892  1               ;*	MODS
00C892  1               ;*		Y. M. Chen	04/01/82
00C892  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C892  1               ;*		   R. K. Nordin	11/01/83
00C892  1               
00C892  1               
00C892  1               LOO	=	*	;entry
00C892  1  A2 00        	LDX	#0	;X=0 points to non-zero page variab:
00C894  1  AC 88 02     	LDY	HIBYTE	;HIBYTE has Type ID
00C897  1  C0 04        	CPY	#4	;type 4 & 5 needs zero page variabl:
00C899  1  90 02        	BCC	LOO1	;if type 2 or 3, need non-zero page:
00C89B  1               
00C89B  1  A2 02        	LDX	#2	;point to zero page variable
00C89D  1               
00C89D  1  18           LOO1	CLC		;offset is in A register
00C89E  1  6D 8E 02     	ADC	NEWADR	;offset+NEWADR=the byte needs fixup
00C8A1  1  85 36        	STA	LTEMP
00C8A3  1  A9 00        	LDA	#0
00C8A5  1  6D 8F 02     	ADC	NEWADR+1
00C8A8  1  85 37        	STA	LTEMP+1
00C8AA  1  A0 00        	LDY	#0
00C8AC  1  B1 36        	LDA	(LTEMP),Y	;get the content of offset+:
00C8AE  1  18           	CLC
00C8AF  1  7D D1 02     	ADC	LOADAD,X	;do relocating fixup
00C8B2  1  91 36        	STA	(LTEMP),Y	;restore the being fixed va:
00C8B4  1  60           	RTS			;return
00C8B5  1               ;	SPACE	4,10
00C8B5  1               ;**	HIG - Handle High Byte Record Types
00C8B5  1               ;*
00C8B5  1               ;*	HIG handles record types of
00C8B5  1               ;*
00C8B5  1               ;*	1.Non-zero page high bytes references to non-zero p:
00C8B5  1               ;*	2.Zero page high bytes references to non-zero page.
00C8B5  1               ;*
00C8B5  1               ;*	Record format
00C8B5  1               ;*
00C8B5  1               ;*	|Type	|Length		|Offset1|Low byte|Offset2|L:
00C8B5  1               ;*	|ID	|(RECLEN)	|HIBYTE	|A Reg.  | (HIBYTE):
00C8B5  1               ;*
00C8B5  1               ;*	Process formula
00C8B5  1               ;*
00C8B5  1               ;*	(HIBYTE+NEWADR)+[[LOADAD+A]/256] ==> (HIBYTE+NEWADR:
00C8B5  1               ;*
00C8B5  1               ;*	Count the offset from the start relocating address :
00C8B5  1               ;*	byte needs to be fixed. Get the low byte informatio:
00C8B5  1               ;*	A register, then add the low byte with LOADAD and s:
00C8B5  1               ;*	flag depending on the calculation. Next do an addit:
00C8B5  1               ;*	high byte, NEWADR and the C flag. Restore the addit:
00C8B5  1               ;*	back to the high byte location in memory.
00C8B5  1               ;*
00C8B5  1               ;*	HIBYTE is not Type ID here. HIBYTE is used to store:
00C8B5  1               ;*	byte value.
00C8B5  1               ;*
00C8B5  1               ;*	ENTRY	JSR	HIG
00C8B5  1               ;*
00C8B5  1               ;*	NOTES
00C8B5  1               ;*		Problem: many instances of jumping to RTS i:
00C8B5  1               ;*		wastes bytes.
00C8B5  1               ;*
00C8B5  1               ;*	MODS
00C8B5  1               ;*		Y. M. Chen	04/01/82
00C8B5  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C8B5  1               ;*		   R. K. Nordin	11/01/83
00C8B5  1               
00C8B5  1               
00C8B5  1               HIG	=	*		;entry
00C8B5  1               
00C8B5  1               ;	Initialize.
00C8B5  1               
00C8B5  1  48           	PHA			;save offset pointing to hi:
00C8B6  1               
00C8B6  1               ;	Check LCOUNT odd or even.
00C8B6  1               
00C8B6  1  AD 33 02     	LDA	LCOUNT
00C8B9  1  6A           	ROR	A
00C8BA  1  68           	PLA
00C8BB  1  B0 15        	BCS	HIG2		;if even number, process lo:
00C8BD  1               
00C8BD  1               ;	Process high byte.
00C8BD  1               
00C8BD  1  18           	CLC
00C8BE  1  6D 8E 02     	ADC	NEWADR
00C8C1  1  85 36        	STA	LTEMP		;get high byte value
00C8C3  1  A9 00        	LDA	#0
00C8C5  1  6D 8F 02     	ADC	NEWADR+1
00C8C8  1  85 37        	STA	LTEMP+1
00C8CA  1  A0 00        	LDY	#0
00C8CC  1  B1 36        	LDA	(LTEMP),Y
00C8CE  1  8D 88 02     	STA	HIBYTE		;save high byte content
00C8D1  1               
00C8D1  1  60           HIG1	RTS			;return
00C8D2  1               
00C8D2  1               ;	Process low byte
00C8D2  1               
00C8D2  1  18           HIG2	CLC
00C8D3  1  6D D1 02     	ADC	LOADAD		;add low byte with LOADAD
00C8D6  1  A9 00        	LDA	#0
00C8D8  1  6D D2 02     	ADC	LOADAD+1
00C8DB  1  6D 88 02     	ADC	HIBYTE		;C flag+LOADAD(high byte)+H:
00C8DE  1  A0 00        	LDY	#0
00C8E0  1  91 36        	STA	(LTEMP),Y	;store being fixed high byt:
00C8E2  1  F0 ED        	BEQ	HIG1
00C8E4  1               ;	SPACE	4,10
00C8E4  1               ;**	TRPR - Table of Record Processing Routines
00C8E4  1               
00C8E4  1               
00C8E4  1  D5 C7 D5 C7  TRPR	DW	TEX	;0 - non-zero page relocatable text
00C8E8  1  92 C8 92 C8  
00C8EC  1  92 C8 92 C8  
00C8FC  1               	DW	TEX	;1 - zero page relocatable text
00C8FC  1               	DW	LOO	;2 - non-zero page low byte to non-:
00C8FC  1               	DW	LOO	;3 - zero page low byte to non-zero:
00C8FC  1               	DW	LOO	;4 - non-zero page one byte to zero:
00C8FC  1               	DW	LOO	;5 - zero page one byte to zero pag:
00C8FC  1               	DW	WOR	;6 - non-zero page word to non-zero:
00C8FC  1               	DW	WOR	;7 - zero page word to non-zero pag:
00C8FC  1               	DW	HIG	;8 - non-zero page high byte to non:
00C8FC  1               	DW	HIG	;9 - zero page high byte to non-zer:
00C8FC  1               	DW	TEX	;10 - absolute text
00C8FC  1               	DW	END	;11 - end record
00C8FC  1               ;	SUBTTL	'Self-test, Part 1'
00C8FC  1               ;	SPACE	4,10
00C8FC  1               ;**	SES - Select and Execute Self-test
00C8FC  1               ;*
00C8FC  1               ;*	SES selects the self-test ROM and executes the self-test.
00C8FC  1               ;*
00C8FC  1               ;*	ENTRY	JSR	SES
00C8FC  1               ;*
00C8FC  1               ;*	NOTES
00C8FC  1               ;*		Problem: this could be contiguous with other OS ROM
00C8FC  1               ;*		self-test code (near TSTO).
00C8FC  1               ;*
00C8FC  1               ;*	MODS
00C8FC  1               ;*		M. W. Colburn	10/26/82
00C8FC  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C8FC  1               ;*		   R. K. Nordin	11/01/83
00C8FC  1               
00C8FC  1               
00C8FC  1               SES	=	*	;entry
00C8FC  1               
00C8FC  1  A9 FF        	LDA	#$FF
00C8FE  1  8D 44 02     	STA	COLDST	;force coldstart on RESET
00C901  1               
00C901  1  AD 01 D3     	LDA	PORTB
00C904  1  29 7F        	AND	#$7F	;enable self-test ROM
00C906  1  8D 01 D3     	STA	PORTB	;update port B memory control
00C909  1               
00C909  1  4C 83 E4     	JMP	SLFTSV	;vector to self-test
00C90C  1               ;	SUBTTL	'Parallel Input/Output'
00C90C  1               ;	SPACE	4,10
00C90C  1               ;**	GIN - Initialize Generic Parallel Device
00C90C  1               ;*
00C90C  1               ;*	ENTRY	JSR	GIN
00C90C  1               ;*
00C90C  1               ;*	MODS
00C90C  1               ;*		Y. M. Chen	02/18/83
00C90C  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C90C  1               ;*		   R. K. Nordin	11/01/83
00C90C  1               
00C90C  1               
00C90C  1               GIN	=	*	;entry
00C90C  1               
00C90C  1               ;	Initialize.
00C90C  1               
00C90C  1  A9 01        	LDA	#$01	;initially select device 0
00C90E  1  8D 48 02     	STA	SHPDVS	;device select shadow
00C911  1               
00C911  1               ;	For each potential device, initialize if device pre:
00C911  1               
00C911  1  AD 48 02     GIN1	LDA	SHPDVS	;device select shadow
00C914  1  8D FF D1     	STA	PDVS	;device select
00C917  1               
00C917  1  AD 03 D8     	LDA	PDID1	;first ID
00C91A  1  C9 80        	CMP	#$80	;required value
00C91C  1  D0 0A        	BNE	GIN2	;if first ID not verified
00C91E  1               
00C91E  1  AD 0B D8     	LDA	PDID2	;second ID
00C921  1  C9 91        	CMP	#$91	;required value
00C923  1  D0 03        	BNE	GIN2	;if second ID not verified
00C925  1               
00C925  1  20 19 D8     	JSR	PDVV+12	;initialize parallel device handler
00C928  1               
00C928  1  0E 48 02     GIN2	ASL	SHPDVS	;advance to next device
00C92B  1  D0 E4        	BNE	GIN1	;if devices remain
00C92D  1               
00C92D  1               ;	Exit
00C92D  1               
00C92D  1  A9 00        	LDA	#$00	;select FPP (deselect device)
00C92F  1               ;	STA	SHPDVS	;device select shadow
00C92F  1  8D FF D1     	STA	PDVS	;device select
00C932  1  60           	RTS		;return
00C933  1               ;	SPACE	4,10
00C933  1               ;**	PIO - Parallel Input/Output
00C933  1               ;*
00C933  1               ;*	ENTRY	JSR	PIO
00C933  1               ;*
00C933  1               ;*	NOTES
00C933  1               ;*		Problem: in the CRASS65 section, CRITIC was:
00C933  1               ;*		zero-page.
00C933  1               ;*
00C933  1               ;*	MODS
00C933  1               ;*		Y. M. Chen	02/18/83
00C933  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C933  1               ;*		   R. K. Nordin	11/01/83
00C933  1               
00C933  1               
00C933  1               PIO	=	*	;entry
00C933  1               
00C933  1               ;	Initialize.
00C933  1               
00C933  1  A9 01        	LDA	#1
00C935  1               ;	STA	CRITIC	;indicate critical section
00C935  1  8D 42 00     	.BYTE	$8D, low CRITIC, high CRITIC ;originally VFD
00C938  1  AD 01 03     	LDA	DUNIT	;device unit number
00C93B  1  48           	PHA		;save device unit number
00C93C  1  AD 47 02     	LDA	PDVMSK	;device selection mask
00C93F  1  F0 1A        	BEQ	PIO2	;if no device to select
00C941  1               
00C941  1               ;	For each device, pass request to device I/O routine:
00C941  1               
00C941  1  A2 08        	LDX	#TPDSL	;offset to first byte beyond table
00C943  1               
00C943  1  20 AF C9     PIO1	JSR	SNP	;select next parallel device
00C946  1  F0 13        	BEQ	PIO2	;if no device selected
00C948  1               
00C948  1  8A           	TXA
00C949  1  48           	PHA		;save offset
00C94A  1  20 05 D8     	JSR	PDIOV	;perform parallel device I/O
00C94D  1  68           	PLA		;saved offset
00C94E  1  AA           	TAX		;restore offset
00C94F  1  90 F2        	BCC	PIO1	;if device did not field request
00C951  1               
00C951  1               ;	Restore Floating Point Package.
00C951  1               
00C951  1  A9 00        	LDA	#$00	;select FPP (deselect device)
00C953  1  8D 48 02     	STA	SHPDVS	;device select shadow
00C956  1  8D FF D1     	STA	PDVS	;device select
00C959  1  F0 03        	BEQ	PIO3	;exit
00C95B  1               
00C95B  1               ;	Perform SIO.
00C95B  1               
00C95B  1  20 71 E9     PIO2	JSR	SIO	;perform SIO
00C95E  1               
00C95E  1               ;	Exit.
00C95E  1               
00C95E  1  68           PIO3	PLA		;saved device unit number
00C95F  1  8D 01 03     	STA	DUNIT	;restore device unit number
00C962  1  A9 00        	LDA	#0
00C964  1               ;	STA	CRITIC	;indicate non-critical section
00C964  1  8D 42 00     	.BYTE	$8D, low CRITIC, high CRITIC ;originally VFD
00C967  1  8C 03 03     	STY	DSTATS
00C96A  1  AC 03 03     	LDY	DSTATS	;status (re-establish N)
00C96D  1  60           	RTS		;return
00C96E  1               ;	SPACE	4,10
00C96E  1               ;**	PIR - Handle Parallel Device IRQ
00C96E  1               ;*
00C96E  1               ;*	ENTRY	JSR	PIR
00C96E  1               ;*
00C96E  1               ;*	EXIT
00C96E  1               ;*		Exits via RTI
00C96E  1               ;*
00C96E  1               ;*	MODS
00C96E  1               ;*		Y. M. Chen	02/18/83
00C96E  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C96E  1               ;*		   R. K. Nordin	11/01/83
00C96E  1               
00C96E  1               
00C96E  1               PIR	=	*	;entry
00C96E  1               
00C96E  1               ;	Determine which device made IRQ, in order of priori:
00C96E  1               
00C96E  1  A2 08        	LDX	#TPDSL	;offset to first byte beyond table
00C970  1               
00C970  1  6A           PIR1	ROR	A
00C971  1  B0 03        	BCS	PIR2	;if IRQ of that device
00C973  1               
00C973  1  CA           	DEX
00C974  1  D0 FA        	BNE	PIR1	;if devices remain
00C976  1               
00C976  1               ;	Select device and process IRQ.
00C976  1               
00C976  1  AD 48 02     PIR2	LDA	SHPDVS		;current device selection
00C979  1  48           	PHA			;save current device select:
00C97A  1  BD 20 CA     	LDA	TPDS-1,X	;device selection desired
00C97D  1  8D 48 02     	STA	SHPDVS		;device select shadow
00C980  1  8D FF D1     	STA	PDVS		;device select
00C983  1  20 08 D8     	JSR	PDIRQV		;process IRQ
00C986  1               
00C986  1               ;	Exit.
00C986  1               
00C986  1  68           	PLA			;saved device selection
00C987  1  8D 48 02     	STA	SHPDVS		;restore device select shad:
00C98A  1  8D FF D1     	STA	PDVS		;device select
00C98D  1  68           	PLA			;saved X
00C98E  1  AA           	TAX			;restore X
00C98F  1  68           	PLA			;restore A
00C990  1  40           	RTI			;return
00C991  1               ;	SPACE	4,10
00C991  1               ;**	GOP - Perform Generic Parallel Device OPEN
00C991  1               ;*
00C991  1               ;*	ENTRY	JSR	GOP
00C991  1               ;*
00C991  1               ;*	MODS
00C991  1               ;*		Y. M. Chen	02/18/83
00C991  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C991  1               ;*		   R. K. Nordin	11/01/83
00C991  1               
00C991  1               
00C991  1               GOP	=	*	;entry
00C991  1  A0 01        	LDY	#1	;offset for OPEN
00C993  1  4C DC C9     	JMP	EPC	;execute parallel device handler co:
00C996  1               ;	SPACE	4,10
00C996  1               ;**	GCL - Perform Generic Parallel Device CLOSE
00C996  1               ;*
00C996  1               ;*	ENTRY	JSR	GCL
00C996  1               ;*
00C996  1               ;*	MODS
00C996  1               ;*		Y. M. Chen	02/18/83
00C996  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C996  1               ;*		   R. K. Nordin	11/01/83
00C996  1               
00C996  1               
00C996  1               GCL	=	*	;entry
00C996  1  A0 03        	LDY	#3	;offset for CLOSE
00C998  1  4C DC C9     	JMP	EPC	;execute parallel device handler co:
00C99B  1               ;	SPACE	4,10
00C99B  1               ;**	GGB - Perform Generic Parallel Device GET-BYTE
00C99B  1               ;*
00C99B  1               ;*	ENTRY	JSR	GGB
00C99B  1               ;*
00C99B  1               ;*	MODS
00C99B  1               ;*		Y. M. Chen	02/18/83
00C99B  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C99B  1               ;*		   R. K. Nordin	11/01/83
00C99B  1               
00C99B  1               
00C99B  1               GGB	=	*	;entry
00C99B  1  A0 05        	LDY	#5	;offset for GET-BYTE
00C99D  1  4C DC C9     	JMP	EPC	;execute parallel device handler co:
00C9A0  1               ;	SPACE	4,10
00C9A0  1               ;**	GPB - Perform Generic Parallel Device PUT-BYTE
00C9A0  1               ;*
00C9A0  1               ;*	ENTRY	JSR	GPB
00C9A0  1               ;*
00C9A0  1               ;*	MODS
00C9A0  1               ;*		Y. M. Chen	02/18/83
00C9A0  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C9A0  1               ;*		   R. K. Nordin	11/01/83
00C9A0  1               
00C9A0  1               
00C9A0  1               GPB	=	*	;entry
00C9A0  1  A0 07        	LDY	#7	;offset for PUT-BYTE
00C9A2  1  4C DC C9     	JMP	EPC	;execute parallel device handler co:
00C9A5  1               ;	SPACE	4,10
00C9A5  1               ;**	GST - Perform Generic Parallel Device STATUS
00C9A5  1               ;*
00C9A5  1               ;*	ENTRY	JSR	GST
00C9A5  1               ;*
00C9A5  1               ;*	MODS
00C9A5  1               ;*		Y. M. Chen	02/18/83
00C9A5  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C9A5  1               ;*		   R. K. Nordin	11/01/83
00C9A5  1               
00C9A5  1               
00C9A5  1               GST	=	*	;entry
00C9A5  1  A0 09        	LDY	#9	;offset for STATUS
00C9A7  1  4C DC C9     	JMP	EPC	;execute parallel device handler co:
00C9AA  1               ;	SPACE	4,10
00C9AA  1               ;**	GSP - Perform Generic Parallel Device SPECIAL
00C9AA  1               ;*
00C9AA  1               ;*	ENTRY	JSR	GSP
00C9AA  1               ;*
00C9AA  1               ;*	MODS
00C9AA  1               ;*		Y. M. Chen	02/18/83
00C9AA  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C9AA  1               ;*		   R. K. Nordin	11/01/83
00C9AA  1               
00C9AA  1               
00C9AA  1               GSP	=	*	;entry
00C9AA  1  A0 0B        	LDY	#11	;offset for SPECIAL
00C9AC  1  4C DC C9     	JMP	EPC	;execute parallel device handler co:
00C9AF  1               ;	SPACE	4,10
00C9AF  1               ;**	SNP - Select Next Parallel Device
00C9AF  1               ;*
00C9AF  1               ;*	ENTRY	JSR	SNP
00C9AF  1               ;*
00C9AF  1               ;*	MODS
00C9AF  1               ;*		Y. M. Chen	02/18/83
00C9AF  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C9AF  1               ;*		   R. K. Nordin	11/01/83
00C9AF  1               
00C9AF  1               
00C9AF  1               SNP	=	*	;entry
00C9AF  1               
00C9AF  1               ;	Decrement and check offset.
00C9AF  1               
00C9AF  1  CA           SNP1	DEX		;decrement offset
00C9B0  1  10 09        	BPL	SNP2	;if devices remain
00C9B2  1               
00C9B2  1               ;	Exit
00C9B2  1               
00C9B2  1  A9 00        	LDA	#$00	;select FPP (deselect device)
00C9B4  1  8D 48 02     	STA	SHPDVS	;device select shadow
00C9B7  1  8D FF D1     	STA	PDVS	;device select
00C9BA  1  60           	RTS		;return
00C9BB  1               
00C9BB  1               ;	Ensure device is indicated by selection mask.
00C9BB  1               
00C9BB  1  AD 47 02     SNP2	LDA	PDVMSK	;device selection mask
00C9BE  1  3D 21 CA     	AND	TPDS,X	;device select
00C9C1  1  F0 EC        	BEQ	SNP1	;if device not indicated for select:
00C9C3  1               
00C9C3  1               ;	Select device.
00C9C3  1               
00C9C3  1  8D 48 02     	STA	SHPDVS	;device select shadow
00C9C6  1  8D FF D1     	STA	PDVS	;device select
00C9C9  1  60           	RTS		;return
00C9CA  1               ;	SPACE	4,10
00C9CA  1               ;**	IPH - Invoke Parallel Device Handler
00C9CA  1               ;*
00C9CA  1               ;*	ENTRY	JSR	IPH
00C9CA  1               ;*		Y = offset into parallel defice vector tabl:
00C9CA  1               ;*		PPTMPA	= original A value
00C9CA  1               ;*		PPTMPX	= original X value
00C9CA  1               ;*
00C9CA  1               ;*	NOTES
00C9CA  1               ;*		Problem: wasted byte for DEY.
00C9CA  1               ;*
00C9CA  1               ;*	MODS
00C9CA  1               ;*		Y. M. Chen	02/18/83
00C9CA  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C9CA  1               ;*		   R. K. Nordin	11/01/83
00C9CA  1               
00C9CA  1               
00C9CA  1               IPH	=	*	;entry
00C9CA  1  B9 0D D8     	LDA	PDVV,Y	;high routine address-1
00C9CD  1  48           	PHA		;place on stack
00C9CE  1  88           	DEY
00C9CF  1  B9 0D D8     	LDA	PDVV,Y	;low routine address-1
00C9D2  1  48           	PHA		;place on stack
00C9D3  1  AD 4C 02     	LDA	PPTMPA	;restore A for handler
00C9D6  1  AE 4D 02     	LDX	PPTMPX	;restore X for handler
00C9D9  1  A0 92        	LDY	#FNCNOT	;preset status
00C9DB  1  60           	RTS		;invoke handler routine (address on:
00C9DC  1               ;	SPACE	4,10
00C9DC  1               ;**	EPC - Execute Parallel Device Handler Command
00C9DC  1               ;*
00C9DC  1               ;*	ENTRY	JSR	EPC
00C9DC  1               ;*
00C9DC  1               ;*	NOTES
00C9DC  1               ;*		Problem: in the CRASS65 version, CRITIC was:
00C9DC  1               ;*		zero-page.
00C9DC  1               ;*
00C9DC  1               ;*	MODS
00C9DC  1               ;*		Y. M. Chen	02/18/83
00C9DC  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00C9DC  1               ;*		   R. K. Nordin	11/01/83
00C9DC  1               
00C9DC  1               
00C9DC  1               EPC	=	*	;entry
00C9DC  1               
00C9DC  1               ;	Initialize.
00C9DC  1               
00C9DC  1  8D 4C 02     	STA	PPTMPA	;save data byte
00C9DF  1  8E 4D 02     	STX	PPTMPX	;save X
00C9E2  1               ;	LDA	CRITIC
00C9E2  1  AD 42 00     	.BYTE	$AD, low CRITIC, high CRITIC ;originally VFD
00C9E5  1  48           	PHA		;save critical section status
00C9E6  1  A9 01        	LDA	#1
00C9E8  1               ;	STA	CRITIC	;indicate critical section
00C9E8  1  8D 42 00     	.BYTE	$8D, low CRITIC, high CRITIC ;originally VFD
00C9EB  1               
00C9EB  1               ;	For each device, pass request to device handler.
00C9EB  1               
00C9EB  1  A2 08        	LDX	#TPDSL	;offset to first byte beyond table
00C9ED  1               
00C9ED  1  20 AF C9     EPC1	JSR	SNP	;select next device
00C9F0  1  F0 11        	BEQ	EPC2	;if no device selected, return erro:
00C9F2  1               
00C9F2  1  8A           	TXA
00C9F3  1  48           	PHA		;save offset
00C9F4  1  98           	TYA
00C9F5  1  48           	PHA		;save Y
00C9F6  1  20 CA C9     	JSR	IPH	;invoke parallel device handler
00C9F9  1  90 20        	BCC	EPC4	;if device did not field, try next :
00C9FB  1               
00C9FB  1               ;	Clean up.
00C9FB  1               
00C9FB  1  8D 4C 02     	STA	PPTMPA	;save possile data byte
00C9FE  1  68           	PLA		;clean stack
00C9FF  1  68           	PLA
00CA00  1  4C 05 CA     	JMP	EPC3	;exit
00CA03  1               
00CA03  1               ;	Return Nonexistent Device error.
00CA03  1               
00CA03  1  A0 82        EPC2	LDY	#NONDEV
00CA05  1               
00CA05  1               ;	Restore Floating Point Package
00CA05  1               
00CA05  1  A9 00        EPC3	LDA	#$00	;select FPP (deselect device)
00CA07  1  8D 48 02     	STA	SHPDVS	;device select shadow
00CA0A  1  8D FF D1     	STA	PDVS	;device select
00CA0D  1  68           	PLA		;saved critical section status
00CA0E  1               ;	STA	CRITIC	;restore critical section status
00CA0E  1  8D 42 00     	.BYTE	$8D, low CRITIC, high CRITIC ;originally VFD
00CA11  1  AD 4C 02     	LDA	PPTMPA	;restore possible data byte
00CA14  1  8C 4D 02     	STY	PPTMPX
00CA17  1  AC 4D 02     	LDY	PPTMPX	;status (re-establish N)
00CA1A  1  60           	RTS		;return
00CA1B  1               
00CA1B  1               ;	Prepare to try next device.
00CA1B  1               
00CA1B  1  68           EPC4	PLA
00CA1C  1  A8           	TAY		;restore Y
00CA1D  1  68           	PLA
00CA1E  1  AA           	TAX		;restore X
00CA1F  1  90 CC        	BCC	EPC1	;try next device
00CA21  1               ;	SPACE	4,10
00CA21  1               ;**	TPDS - Table of Parallel Device Selects
00CA21  1               ;*
00CA21  1               ;*	NOTES
00CA21  1               ;*		Problem: bytes wasted by replication of thi:
00CA21  1               ;*		elsewhere.
00CA21  1               
00CA21  1               
00CA21  1  80 40 20 10  TPDS	DB	$80	;0 - device 7 (lowest priority)
00CA25  1  08 04 02 01  
00CA29  1               	DB	$40	;1 - device 6
00CA29  1               	DB	$20	;2 - device 5
00CA29  1               	DB	$10	;3 - device 4
00CA29  1               	DB	$08	;4 - device 3
00CA29  1               	DB	$04	;5 - device 2
00CA29  1               	DB	$02	;6 - device 1
00CA29  1               	DB	$01	;7 - device 0 (highest priority)
00CA29  1               
00CA29  1               TPDSL	=	*-TPDS	;length
00CA29  1               ;	SUBTTL	'Peripheral Handler Loading Facility, Part 1'
00CA29  1               ;	SPACE	4,10
00CA29  1               ;**	PHL - Load and Initialize Peripheral Handler
00CA29  1               ;*
00CA29  1               ;*	Subroutine to load, relocate, initialize and open a
00CA29  1               ;*	"provisionally" opened IOCB. This routine is called
00CA29  1               ;*	upon first I/O attempt following provisional open.
00CA29  1               ;*	It does the final opening by simulating the first
00CA29  1               ;*	part of a normal CIO OPEN and then finishing with
00CA29  1               ;*	code which is in CIO.
00CA29  1               ;*
00CA29  1               ;*	Input parameters:
00CA29  1               ;*	ICIDNO	(specifies which IOCB);
00CA29  1               ;*	various values in the provisionally-opened IOCB:
00CA29  1               ;*		ICSPR (handler name)
00CA29  1               ;*		ICSPR+1 (serial address for loading);
00CA29  1               ;*	whatever the called subroutines require.
00CA29  1               ;*
00CA29  1               ;*	Output parameters:
00CA29  1               ;*	None. (Error returns are all handled by called subr:
00CA29  1               ;*		in fact, all returns are handled by called :
00CA29  1               ;*
00CA29  1               ;*	Modified:
00CA29  1               ;*	ICHID in both calling IOCB and ZIOCB (part of compl:
00CA29  1               ;*	ICCOMT (a CIO variable);
00CA29  1               ;*	Registers not saved.
00CA29  1               ;*
00CA29  1               ;*	Subroutines called:
00CA29  1               ;*	LPH (does the loading);
00CA29  1               ;*	PHC (initializes the loaded handler);
00CA29  1               ;*	FDH (a CIO entry--finds handler table entry of
00CA29  1               ;*		newly loaded/initialized handler);
00CA29  1               ;*	IIO (a CIO entry--finishes full proper opening of I:
00CA29  1               ;*		including calling handler OPEN entry--IIO r:
00CA29  1               ;*		to PHL's caller);
00CA29  1               ;*	IND (a CIO entry--returns with error to PHL's calle:
00CA29  1               ;*
00CA29  1               ;*	ENTRY	JSR	PHL
00CA29  1               ;*
00CA29  1               ;*	NOTES
00CA29  1               ;*		Problem: in the CRASS65 version, ICIDNO was:
00CA29  1               ;*		zero-page.
00CA29  1               ;*
00CA29  1               ;*	MODS
00CA29  1               ;*		R. S. Scheiman	04/01/82
00CA29  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00CA29  1               ;*		   R. K. Nordin	11/01/83
00CA29  1               
00CA29  1               
00CA29  1               PHL	=	*		;entry
00CA29  1               
00CA29  1               ;	Load peripheral handler.
00CA29  1               
00CA29  1               ;	LDX	ICIDNO		;IOCB index
00CA29  1  AE 2E 00     	.BYTE	$AE, low ICIDNO, high ICIDNO ;originally VFD
00CA2C  1  BD 4D 03     	LDA	ICSPR+1,X
00CA2F  1  20 DE E7     	JSR	LPH		;load peripheral handler
00CA32  1  B0 20        	BCS	PHL1		;if error
00CA34  1               
00CA34  1               ;	Initialize peripheral handler
00CA34  1               
00CA34  1  18           	CLC			;indicate zero handler size
00CA35  1  20 9E E8     	JSR	PHC		;initialize peripheral hand:
00CA38  1  B0 1A        	BCS	PHL1		;if error
00CA3A  1               
00CA3A  1               ;	Find device handler
00CA3A  1               
00CA3A  1               ;	LDX	ICIDNO		;IOCB index
00CA3A  1  AE 2E 00     	.BYTE	$AE, low ICIDNO, high ICIDNO ;originally VFD
00CA3D  1  BD 4C 03     	LDA	ICSPR,X
00CA40  1  20 16 E7     	JSR	FDH		;find device handler
00CA43  1  B0 0F        	BCS	PHL1		;if not found
00CA45  1               
00CA45  1               ;	Set handler ID.
00CA45  1               
00CA45  1               ;	LDX	ICIDNO		;IOCB index
00CA45  1  AE 2E 00     	.BYTE	$AE, low ICIDNO, high ICIDNO ;originally VFD
00CA48  1  9D 40 03     	STA	ICHID,X		;handler ID
00CA4B  1  85 20        	STA	ICHIDZ
00CA4D  1               
00CA4D  1               ;	Simulate initial CIO OPEN processing.
00CA4D  1               
00CA4D  1  A9 03        	LDA	#OPEN	;OPEN command
00CA4F  1  85 17        	STA	ICCOMT	;command
00CA51  1  4C 5C E5     	JMP	IIO	;initialize IOCB for OPEN, return
00CA54  1               
00CA54  1               ;	Indicate nonexistent device error.
00CA54  1               
00CA54  1  4C 10 E5     PHL1	JMP	IND	;indicate nonexistent device error,:
00CA57  1               ;	SUBTTL	'Self-test, Part 2'
00CA57  1               ;	SPACE	4,10
00CA57  1               ;**	TSTO - Table of Self-test Text Offsets
00CA57  1               
00CA57  1               
00CA57  1  00 13 16 D1  TSTO	DB	TXT0-TTXT	;0 - offset to "MEMORY TEST   ROM" text
00CA5B  1  E4 E4 E8 29  
00CA5F  1  EB EE        
00CA61  1               	DB	TXT1-TTXT	;1 - offset to "RAM" text
00CA61  1               	DB	TXT2-TTXT	;2 - offset to "KEYBOARD TEST" text
00CA61  1               	DB	TXT3-TTXT	;3 - offset to "S P A C E   B A R" text
00CA61  1               	DB	TXT4-TTXT	;4 - offset to "SH" text
00CA61  1               	DB	TXT5-TTXT	;5 - offset to "SH" text
00CA61  1               	DB	TXT6-TTXT	;6 - offset to "B S" text
00CA61  1               	DB	TXT7-TTXT	;7 - offset to keyboard text
00CA61  1               	DB	TXT8-TTXT	;8 - offset to control key text
00CA61  1               	DB	TXT9-TTXT	;9 - offset to "VOICE #" text
00CA61  1               ;	SPACE	4,10
00CA61  1               ;**	TTXT - Table of Text Sequences
00CA61  1               
00CA61  1               
00CA61  1               TTXT	=	*
00CA61  1               ;	SPACE	4,10
00CA61  1               ;**	TXT0 - "MEMORY TEST   ROM" Text
00CA61  1               
00CA61  1               
00CA61  1  00 00 2D 25  TXT0	DB	$00,$00
00CA65  1  2D 2F 32 39  
00CA69  1  00 34 25 33  
00CA74  1               	DB	$2D,$25,$2D,$2F,$32,$39	;"MEMORY"
00CA74  1               	DB	$00
00CA74  1               	DB	$34,$25,$33,$34		;"TEST"
00CA74  1               	DB	$00,$00,$00
00CA74  1               	DB	$32,$2F,$2D		;"ROM"
00CA74  1               
00CA74  1               TXT0L	=	*-TXT0	;length
00CA74  1               ;	SPACE	4,10
00CA74  1               ;**	TXT1 - "RAM" Text
00CA74  1               
00CA74  1               
00CA74  1  32 21 2D     TXT1	DB	$32,$21,$2D		;"RAM"
00CA77  1               
00CA77  1               TXT1L	=	*-TXT1	;length
00CA77  1               ;	SPACE	4,10
00CA77  1               ;**	TXT2 - "KEYBOARD TEST" Text
00CA77  1               
00CA77  1               
00CA77  1  00 00 2B 25  TXT2	DB	$00,$00
00CA7B  1  39 22 2F 21  
00CA7F  1  32 24 00 34  
00CA8A  1               	DB	$2B,$25,$39,$22,$2F,$21,$32,$24	;"KEYBOARD"
00CA8A  1               	DB	$00
00CA8A  1               	DB	$34,$25,$33,$34			;"TEST"
00CA8A  1               	DB	$00,$00,$00
00CA8A  1               	DB	$B2
00CA8A  1               
00CA8A  1               TXT2L	=	*-TXT2	;length
00CA8A  1               ;	SPACE	4,10
00CA8A  1               ;**	TXT7 - Keyboard
00CA8A  1               
00CA8A  1               
00CA8A  1               TXT7	=	*
00CA8A  1               
00CA8A  1               ;	First Row (Function Keys)
00CA8A  1               
00CA8A  1  91 00 92 00  	DB	$91		;"1"
00CA8E  1  93 00 94 00  
00CA92  1  A8 00 A1 00  
00CA9A  1               	DB	$00
00CA9A  1               	DB	$92		;"2"
00CA9A  1               	DB	$00
00CA9A  1               	DB	$93		;"3"
00CA9A  1               	DB	$00
00CA9A  1               	DB	$94		;"4"
00CA9A  1               	DB	$00
00CA9A  1               	DB	$A8		;"H"
00CA9A  1               	DB	$00
00CA9A  1               	DB	$A1		;"A"
00CA9A  1               	DB	$00
00CA9A  1               	DB	$A2		;"B"
00CA9A  1               	DB	$00,$00,$00
00CA9A  1               
00CA9A  1               ;	Second Row ("1 2 3 4 5 6 7 8 9 0 < >")
00CA9A  1               
00CA9A  1  5B 00 11 00  	DB	$5B
00CA9E  1  12 00 13 00  
00CAA2  1  14 00 15 00  
00CABA  1               	DB	$00
00CABA  1               	DB	$11		;"1"
00CABA  1               	DB	$00
00CABA  1               	DB	$12		;"2"
00CABA  1               	DB	$00
00CABA  1               	DB	$13		;"3"
00CABA  1               	DB	$00
00CABA  1               	DB	$14		;"4"
00CABA  1               	DB	$00
00CABA  1               	DB	$15		;"5"
00CABA  1               	DB	$00
00CABA  1               	DB	$16		;"6"
00CABA  1               	DB	$00
00CABA  1               	DB	$17		;"7"
00CABA  1               	DB	$00
00CABA  1               	DB	$18		;"8"
00CABA  1               	DB	$00
00CABA  1               	DB	$19		;"9"
00CABA  1               	DB	$00
00CABA  1               	DB	$10		;"0"
00CABA  1               	DB	$00
00CABA  1               	DB	$1C		;"<"
00CABA  1               	DB	$00
00CABA  1               	DB	$1E		;">"
00CABA  1               	DB	$00
00CABA  1               	DB	$A2		;"B"
00CABA  1               	DB	$80
00CABA  1               	DB	$B3		;"S"
00CABA  1               	DB	$00,$00,$00
00CABA  1               
00CABA  1               ;	Third Row ("Q W E R T Y U I O P - =")
00CABA  1               
00CABA  1  FF FF 00 31  	DB	$FF
00CABE  1  00 37 00 25  
00CAC2  1  00 32 00 34  
00CADA  1               	DB	$FF
00CADA  1               	DB	$00
00CADA  1               	DB	$31		;"Q"
00CADA  1               	DB	$00
00CADA  1               	DB	$37		;"W"
00CADA  1               	DB	$00
00CADA  1               	DB	$25		;"E"
00CADA  1               	DB	$00
00CADA  1               	DB	$32		;"R"
00CADA  1               	DB	$00
00CADA  1               	DB	$34		;"T"
00CADA  1               	DB	$00
00CADA  1               	DB	$39		;"Y"
00CADA  1               	DB	$00
00CADA  1               	DB	$35		;"U"
00CADA  1               	DB	$00
00CADA  1               	DB	$29		;"I"
00CADA  1               	DB	$00
00CADA  1               	DB	$2F		;"O"
00CADA  1               	DB	$00
00CADA  1               	DB	$30		;"P"
00CADA  1               	DB	$00
00CADA  1               	DB	$0D		;"-"
00CADA  1               	DB	$00
00CADA  1               	DB	$1D		;"="
00CADA  1               	DB	$00
00CADA  1               	DB	$B2		;"R"
00CADA  1               	DB	$B4		;"T"
00CADA  1               	DB	$00,$00,$00
00CADA  1               
00CADA  1               ;	Fourth Row ("A S D F G H J K L ; + *")
00CADA  1               
00CADA  1  80 DC 80 00  	DB	$80
00CADE  1  21 00 33 00  
00CAE2  1  24 00 26 00  
00CAFA  1               	DB	$DC
00CAFA  1               	DB	$80
00CAFA  1               	DB	$00
00CAFA  1               	DB	$21		;"A"
00CAFA  1               	DB	$00
00CAFA  1               	DB	$33		;"S"
00CAFA  1               	DB	$00
00CAFA  1               	DB	$24		;"D"
00CAFA  1               	DB	$00
00CAFA  1               	DB	$26		;"F"
00CAFA  1               	DB	$00
00CAFA  1               	DB	$27		;"G"
00CAFA  1               	DB	$00
00CAFA  1               	DB	$28		;"H"
00CAFA  1               	DB	$00
00CAFA  1               	DB	$2A		;"J"
00CAFA  1               	DB	$00
00CAFA  1               	DB	$2B		;"K"
00CAFA  1               	DB	$00
00CAFA  1               	DB	$2C		;"L"
00CAFA  1               	DB	$00
00CAFA  1               	DB	$1B		;";"
00CAFA  1               	DB	$00
00CAFA  1               	DB	$0B		;"+"
00CAFA  1               	DB	$00
00CAFA  1               	DB	$0A		;"*"
00CAFA  1               	DB	$00
00CAFA  1               	DB	$A3		;"C"
00CAFA  1               	DB	$00,$00,$00
00CAFA  1               
00CAFA  1               ;	Fifth Row ("Z X C V B N M , . /")
00CAFA  1               
00CAFA  1  80 B3 A8 80  	DB	$80
00CAFE  1  00 3A 00 38  
00CB02  1  00 23 00 36  
00CB1A  1               	DB	$B3		;"S"
00CB1A  1               	DB	$A8		;"H"
00CB1A  1               	DB	$80
00CB1A  1               	DB	$00
00CB1A  1               	DB	$3A		;"Z"
00CB1A  1               	DB	$00
00CB1A  1               	DB	$38		;"X"
00CB1A  1               	DB	$00
00CB1A  1               	DB	$23		;"C"
00CB1A  1               	DB	$00
00CB1A  1               	DB	$36		;"V"
00CB1A  1               	DB	$00
00CB1A  1               	DB	$22		;"B"
00CB1A  1               	DB	$00
00CB1A  1               	DB	$2E		;"N"
00CB1A  1               	DB	$00
00CB1A  1               	DB	$2D		;"M"
00CB1A  1               	DB	$00
00CB1A  1               	DB	$0C		;","
00CB1A  1               	DB	$00
00CB1A  1               	DB	$0E		;"."
00CB1A  1               	DB	$00
00CB1A  1               	DB	$0F		;"/"
00CB1A  1               	DB	$00
00CB1A  1               	DB	$80
00CB1A  1               	DB	$B3		;"S"
00CB1A  1               	DB	$A8		;"H"
00CB1A  1               	DB	$80
00CB1A  1               	DB	$00,$00,$00
00CB1A  1               
00CB1A  1               ;	Sixth Row (Space Bar)
00CB1A  1               
00CB1A  1  00 00 00 00  	DB	$00,$00,$00,$00,$00
00CB1E  1  00 80 B3 80  
00CB22  1  B0 80 A1 80  
00CB32  1               	DB	$80
00CB32  1               	DB	$B3		;"S"
00CB32  1               	DB	$80
00CB32  1               	DB	$B0		;"P"
00CB32  1               	DB	$80
00CB32  1               	DB	$A1		;"A"
00CB32  1               	DB	$80
00CB32  1               	DB	$A3		;"C"
00CB32  1               	DB	$80
00CB32  1               	DB	$A5		;"E"
00CB32  1               	DB	$80
00CB32  1               	DB	$80
00CB32  1               	DB	$80
00CB32  1               	DB	$A2		;"B"
00CB32  1               	DB	$80
00CB32  1               	DB	$A1		;"A"
00CB32  1               	DB	$80
00CB32  1               	DB	$B2		;"R"
00CB32  1               	DB	$80
00CB32  1               
00CB32  1               TXT7L	=	*-TXT7	;length
00CB32  1               ;	SPACE	4,10
00CB32  1               ;**	TXT3 - "S P A C E   B A R" Text
00CB32  1               
00CB32  1               
00CB32  1  00 33 00 30  TXT3	DB	$00
00CB36  1  00 21 00 23  
00CB3A  1  00 25 00 00  
00CB45  1               	DB	$33		;"S"
00CB45  1               	DB	$00
00CB45  1               	DB	$30		;"P"
00CB45  1               	DB	$00
00CB45  1               	DB	$21		;"A"
00CB45  1               	DB	$00
00CB45  1               	DB	$23		;"C"
00CB45  1               	DB	$00
00CB45  1               	DB	$25		;"E"
00CB45  1               	DB	$00
00CB45  1               	DB	$00
00CB45  1               	DB	$00
00CB45  1               	DB	$22		;"B"
00CB45  1               	DB	$00
00CB45  1               	DB	$21		;"A"
00CB45  1               	DB	$00
00CB45  1               	DB	$32		;"R"
00CB45  1               	DB	$00
00CB45  1               
00CB45  1               TXT3L	=	*-TXT3	;length
00CB45  1               ;	SPACE	4,10
00CB45  1               ;**	TXT4 - "SH" Text
00CB45  1               
00CB45  1               
00CB45  1  00 33 28 00  TXT4	DB	$00
00CB49  1               	DB	$33,$28		;"SH"
00CB49  1               	DB	$00
00CB49  1               
00CB49  1               TXT4L	=	*-TXT4	;length
00CB49  1               ;	SPACE	4,10
00CB49  1               ;**	TXT5 - "SH" Text
00CB49  1               
00CB49  1               
00CB49  1               TXT5	=	TXT4
00CB49  1               
00CB49  1               TXT5L	=	TXT4L	;length
00CB49  1               ;	SPACE	4,10
00CB49  1               ;**	TXT6 - "B S" Text
00CB49  1               
00CB49  1               
00CB49  1  22 00 33     TXT6	DB	$22	;"B"
00CB4C  1               	DB	$00
00CB4C  1               	DB	$33	;"S"
00CB4C  1               
00CB4C  1               TXT6L	=	*-TXT6	;length
00CB4C  1               ;	SPACE	4,10
00CB4C  1               ;**	TXT8 - Control Key
00CB4C  1               
00CB4C  1               
00CB4C  1  00 5C 00     TXT8	DB	$00
00CB4F  1               	DB	$5C
00CB4F  1               	DB	$00
00CB4F  1               
00CB4F  1               TXT8L	=	*-TXT8	;length
00CB4F  1               ;	SPACE	4,10
00CB4F  1               ;**	TXT9 - "VOICE #" Text
00CB4F  1               
00CB4F  1               
00CB4F  1  36 2F 29 23  TXT9	DB	$36,$2F,$29,$23,$25	;"VOICE"
00CB53  1  25 00 03     
00CB56  1               	DB	$00
00CB56  1               	DB	$03			;"#"
00CB56  1               
00CB56  1               TXT9L	=	*-TXT9	;length
00CB56  1               ;	SUBTTL	'Peripheral Handler Loading Facility, Part 2'
00CB56  1               ;	SPACE	4,10
00CB56  1               ;**	CLT - Checksum Linkage Table
00CB56  1               ;*
00CB56  1               ;*	ENTRY	JSR	CLT
00CB56  1               ;*		ZCHAIN = ZCHAIN+1 = address of linkage tabl:
00CB56  1               ;*
00CB56  1               ;*	EXIT
00CB56  1               ;*		A = checksum of linkage table
00CB56  1               ;*
00CB56  1               ;*	CHANGES
00CB56  1               ;*		Y
00CB56  1               ;*
00CB56  1               ;*	CALLS
00CB56  1               ;*		-none-
00CB56  1               ;*
00CB56  1               ;*	MODS
00CB56  1               ;*		R. S. Scheiman	04/01/82
00CB56  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00CB56  1               ;*		   R. K. Nordin	11/01/83
00CB56  1               
00CB56  1               
00CB56  1               CLT	=	*		;entry
00CB56  1               
00CB56  1  A0 11        	LDY	#17		;offset to last byte to sum
00CB58  1  A9 00        	LDA	#0		;initial sum
00CB5A  1  18           	CLC
00CB5B  1               
00CB5B  1  71 4A        CLT1	ADC	(ZCHAIN),Y	;add byte
00CB5D  1  88           	DEY
00CB5E  1  10 FB        	BPL	CLT1		;if not done
00CB60  1               
00CB60  1  69 00        	ADC	#0		;add final carry
00CB62  1  49 FF        	EOR	#$FF		;complement
00CB64  1  60           	RTS			;return
00CB65  1               ;	SUBTTL	'International Character Set'
00CB65  1               ;	SPACE	4,10
00CB65  1  00 00 00 00  	FIX	ICSORG
00CB69  1  00 00 00 00  
00CB6D  1  00 00 00 00  
00CC00  1               ;	SPACE	4,10
00CC00  1               ;**	International Character Set
00CC00  1               
00CC00  1               
00CC00  1  00 00 00 00  	DB	$00,$00,$00,$00,$00,$00,$00,$00	;$00 - space
00CC04  1  00 00 00 00  
00CC08  1  00 18 18 18  
00CC80  1               	DB	$00,$18,$18,$18,$18,$00,$18,$00	;$01 - !
00CC80  1               	DB	$00,$66,$66,$66,$00,$00,$00,$00	;$02 - "
00CC80  1               	DB	$00,$66,$FF,$66,$66,$FF,$66,$00	;$03 - #
00CC80  1               	DB	$18,$3E,$60,$3C,$06,$7C,$18,$00	;$04 - $
00CC80  1               	DB	$00,$66,$6C,$18,$30,$66,$46,$00	;$05 - %
00CC80  1               	DB	$1C,$36,$1C,$38,$6F,$66,$3B,$00	;$06 - &
00CC80  1               	DB	$00,$18,$18,$18,$00,$00,$00,$00	;$07 - '
00CC80  1               	DB	$00,$0E,$1C,$18,$18,$1C,$0E,$00	;$08 - (
00CC80  1               	DB	$00,$70,$38,$18,$18,$38,$70,$00	;$09 - )
00CC80  1               	DB	$00,$66,$3C,$FF,$3C,$66,$00,$00	;$0A - asterisk
00CC80  1               	DB	$00,$18,$18,$7E,$18,$18,$00,$00	;$0B - plus
00CC80  1               	DB	$00,$00,$00,$00,$00,$18,$18,$30	;$0C - comma
00CC80  1               	DB	$00,$00,$00,$7E,$00,$00,$00,$00	;$0D - minus
00CC80  1               	DB	$00,$00,$00,$00,$00,$18,$18,$00	;$0E - period
00CC80  1               	DB	$00,$06,$0C,$18,$30,$60,$40,$00	;$0F - /
00CC80  1               
00CC80  1  00 3C 66 6E  	DB	$00,$3C,$66,$6E,$76,$66,$3C,$00	;$10 - 0
00CC84  1  76 66 3C 00  
00CC88  1  00 18 38 18  
00CD00  1               	DB	$00,$18,$38,$18,$18,$18,$7E,$00	;$11 - 1
00CD00  1               	DB	$00,$3C,$66,$0C,$18,$30,$7E,$00	;$12 - 2
00CD00  1               	DB	$00,$7E,$0C,$18,$0C,$66,$3C,$00	;$13 - 3
00CD00  1               	DB	$00,$0C,$1C,$3C,$6C,$7E,$0C,$00	;$14 - 4
00CD00  1               	DB	$00,$7E,$60,$7C,$06,$66,$3C,$00	;$15 - 5
00CD00  1               	DB	$00,$3C,$60,$7C,$66,$66,$3C,$00	;$16 - 6
00CD00  1               	DB	$00,$7E,$06,$0C,$18,$30,$30,$00	;$17 - 7
00CD00  1               	DB	$00,$3C,$66,$3C,$66,$66,$3C,$00	;$18 - 8
00CD00  1               	DB	$00,$3C,$66,$3E,$06,$0C,$38,$00	;$19 - 9
00CD00  1               	DB	$00,$00,$18,$18,$00,$18,$18,$00	;$1A - colon
00CD00  1               	DB	$00,$00,$18,$18,$00,$18,$18,$30	;$1B - semicolon
00CD00  1               	DB	$06,$0C,$18,$30,$18,$0C,$06,$00	;$1C - <
00CD00  1               	DB	$00,$00,$7E,$00,$00,$7E,$00,$00	;$1D - =
00CD00  1               	DB	$60,$30,$18,$0C,$18,$30,$60,$00	;$1E - >
00CD00  1               	DB	$00,$3C,$66,$0C,$18,$00,$18,$00	;$1F - ?
00CD00  1               
00CD00  1  00 3C 66 6E  	DB	$00,$3C,$66,$6E,$6E,$60,$3E,$00	;$20 - @
00CD04  1  6E 60 3E 00  
00CD08  1  00 18 3C 66  
00CD80  1               	DB	$00,$18,$3C,$66,$66,$7E,$66,$00	;$21 - A
00CD80  1               	DB	$00,$7C,$66,$7C,$66,$66,$7C,$00	;$22 - B
00CD80  1               	DB	$00,$3C,$66,$60,$60,$66,$3C,$00	;$23 - C
00CD80  1               	DB	$00,$78,$6C,$66,$66,$6C,$78,$00	;$24 - D
00CD80  1               	DB	$00,$7E,$60,$7C,$60,$60,$7E,$00	;$25 - E
00CD80  1               	DB	$00,$7E,$60,$7C,$60,$60,$60,$00	;$26 - F
00CD80  1               	DB	$00,$3E,$60,$60,$6E,$66,$3E,$00	;$27 - G
00CD80  1               	DB	$00,$66,$66,$7E,$66,$66,$66,$00	;$28 - H
00CD80  1               	DB	$00,$7E,$18,$18,$18,$18,$7E,$00	;$29 - I
00CD80  1               	DB	$00,$06,$06,$06,$06,$66,$3C,$00	;$2A - J
00CD80  1               	DB	$00,$66,$6C,$78,$78,$6C,$66,$00	;$2B - K
00CD80  1               	DB	$00,$60,$60,$60,$60,$60,$7E,$00	;$2C - L
00CD80  1               	DB	$00,$63,$77,$7F,$6B,$63,$63,$00	;$2D - M
00CD80  1               	DB	$00,$66,$76,$7E,$7E,$6E,$66,$00	;$2E - N
00CD80  1               	DB	$00,$3C,$66,$66,$66,$66,$3C,$00	;$2F - O
00CD80  1               
00CD80  1  00 7C 66 66  	DB	$00,$7C,$66,$66,$7C,$60,$60,$00	;$30 - P
00CD84  1  7C 60 60 00  
00CD88  1  00 3C 66 66  
00CE00  1               	DB	$00,$3C,$66,$66,$66,$6C,$36,$00	;$31 - Q
00CE00  1               	DB	$00,$7C,$66,$66,$7C,$6C,$66,$00	;$32 - R
00CE00  1               	DB	$00,$3C,$60,$3C,$06,$06,$3C,$00	;$33 - S
00CE00  1               	DB	$00,$7E,$18,$18,$18,$18,$18,$00	;$34 - T
00CE00  1               	DB	$00,$66,$66,$66,$66,$66,$7E,$00	;$35 - U
00CE00  1               	DB	$00,$66,$66,$66,$66,$3C,$18,$00	;$36 - V
00CE00  1               	DB	$00,$63,$63,$6B,$7F,$77,$63,$00	;$37 - W
00CE00  1               	DB	$00,$66,$66,$3C,$3C,$66,$66,$00	;$38 - X
00CE00  1               	DB	$00,$66,$66,$3C,$18,$18,$18,$00	;$39 - Y
00CE00  1               	DB	$00,$7E,$0C,$18,$30,$60,$7E,$00	;$3A - Z
00CE00  1               	DB	$00,$1E,$18,$18,$18,$18,$1E,$00	;$3B - [
00CE00  1               	DB	$00,$40,$60,$30,$18,$0C,$06,$00	;$3C - \
00CE00  1               	DB	$00,$78,$18,$18,$18,$18,$78,$00	;$3D - ]
00CE00  1               	DB	$00,$08,$1C,$36,$63,$00,$00,$00	;$3E - ^
00CE00  1               	DB	$00,$00,$00,$00,$00,$00,$FF,$00	;$3F - underline
00CE00  1               
00CE00  1  0C 18 3C 06  	DB	$0C,$18,$3C,$06,$3E,$66,$3E,$00	;$40 - acute accent a
00CE04  1  3E 66 3E 00  
00CE08  1  30 18 00 66  
00CE80  1               	DB	$30,$18,$00,$66,$66,$66,$3E,$00	;$41 - acute accent u
00CE80  1               	DB	$36,$6C,$00,$76,$76,$7E,$6E,$00	;$42 - tilde N
00CE80  1               	DB	$0C,$18,$7E,$60,$7C,$60,$7E,$00	;$43 - acute accent E
00CE80  1               	DB	$00,$00,$3C,$60,$60,$3C,$18,$30	;$44 - cedilla c
00CE80  1               	DB	$3C,$66,$00,$3C,$66,$66,$3C,$00	;$45 - circumflex o
00CE80  1               	DB	$30,$18,$00,$3C,$66,$66,$3C,$00	;$46 - grave accent o
00CE80  1               	DB	$30,$18,$00,$38,$18,$18,$3C,$00	;$47 - grave accent i
00CE80  1               	DB	$1C,$30,$30,$78,$30,$30,$7E,$00	;$48 - U.K. currency
00CE80  1               	DB	$00,$66,$00,$38,$18,$18,$3C,$00	;$49 - diaeresis i
00CE80  1               	DB	$00,$66,$00,$66,$66,$66,$3E,$00	;$4A - umlaut u
00CE80  1               	DB	$36,$00,$3C,$06,$3E,$66,$3E,$00	;$4B - umlaut a
00CE80  1               	DB	$66,$00,$3C,$66,$66,$66,$3C,$00	;$4C - umlaut O
00CE80  1               	DB	$0C,$18,$00,$66,$66,$66,$3E,$00	;$4D - grave accent u
00CE80  1               	DB	$0C,$18,$00,$3C,$66,$66,$3C,$00	;$4E - acute accent o
00CE80  1               	DB	$00,$66,$00,$3C,$66,$66,$3C,$00	;$4F - umlaut o
00CE80  1               
00CE80  1  66 00 66 66  	DB	$66,$00,$66,$66,$66,$66,$7E,$00	;$50 - umlaut U
00CE84  1  66 66 7E 00  
00CE88  1  3C 66 1C 06  
00CF00  1               	DB	$3C,$66,$1C,$06,$3E,$66,$3E,$00	;$51 - circumflex a
00CF00  1               	DB	$3C,$66,$00,$66,$66,$66,$3E,$00	;$52 - circumflex u
00CF00  1               	DB	$3C,$66,$00,$38,$18,$18,$3C,$00	;$53 - circumflex i
00CF00  1               	DB	$0C,$18,$3C,$66,$7E,$60,$3C,$00	;$54 - acute accent e
00CF00  1               	DB	$30,$18,$3C,$66,$7E,$60,$3C,$00	;$55 - grave accent e
00CF00  1               	DB	$36,$6C,$00,$7C,$66,$66,$66,$00	;$56 - tilde n
00CF00  1               	DB	$3C,$C3,$3C,$66,$7E,$60,$3C,$00	;$57 - circumflex e
00CF00  1               	DB	$18,$00,$3C,$06,$3E,$66,$3E,$00	;$58 - ring a
00CF00  1               	DB	$30,$18,$3C,$06,$3E,$66,$3E,$00	;$59 - grave accent a
00CF00  1               	DB	$18,$00,$18,$3C,$66,$7E,$66,$00	;$5A - ring A
00CF00  1               	DB	$78,$60,$78,$60,$7E,$18,$1E,$00	;$5B - display escape
00CF00  1               	DB	$00,$18,$3C,$7E,$18,$18,$18,$00	;$5C - up arrow
00CF00  1               	DB	$00,$18,$18,$18,$7E,$3C,$18,$00	;$5D - down arrow
00CF00  1               	DB	$00,$18,$30,$7E,$30,$18,$00,$00	;$5E - left arrow
00CF00  1               	DB	$00,$18,$0C,$7E,$0C,$18,$00,$00	;$5F - right arrow
00CF00  1               
00CF00  1  18 00 18 18  	DB	$18,$00,$18,$18,$18,$18,$18,$00	;$60 - Spanish !
00CF04  1  18 18 18 00  
00CF08  1  00 00 3C 06  
00CF80  1               	DB	$00,$00,$3C,$06,$3E,$66,$3E,$00	;$61 - a
00CF80  1               	DB	$00,$60,$60,$7C,$66,$66,$7C,$00	;$62 - b
00CF80  1               	DB	$00,$00,$3C,$60,$60,$60,$3C,$00	;$63 - c
00CF80  1               	DB	$00,$06,$06,$3E,$66,$66,$3E,$00	;$64 - d
00CF80  1               	DB	$00,$00,$3C,$66,$7E,$60,$3C,$00	;$65 - e
00CF80  1               	DB	$00,$0E,$18,$3E,$18,$18,$18,$00	;$66 - f
00CF80  1               	DB	$00,$00,$3E,$66,$66,$3E,$06,$7C	;$67 - g
00CF80  1               	DB	$00,$60,$60,$7C,$66,$66,$66,$00	;$68 - h
00CF80  1               	DB	$00,$18,$00,$38,$18,$18,$3C,$00	;$69 - i
00CF80  1               	DB	$00,$06,$00,$06,$06,$06,$06,$3C	;$6A - j
00CF80  1               	DB	$00,$60,$60,$6C,$78,$6C,$66,$00	;$6B - k
00CF80  1               	DB	$00,$38,$18,$18,$18,$18,$3C,$00	;$6C - l
00CF80  1               	DB	$00,$00,$66,$7F,$7F,$6B,$63,$00	;$6D - m
00CF80  1               	DB	$00,$00,$7C,$66,$66,$66,$66,$00	;$6E - n
00CF80  1               	DB	$00,$00,$3C,$66,$66,$66,$3C,$00	;$6F - o
00CF80  1               
00CF80  1  00 00 7C 66  	DB	$00,$00,$7C,$66,$66,$7C,$60,$60	;$70 - p
00CF84  1  66 7C 60 60  
00CF88  1  00 00 3E 66  
00D000  1               	DB	$00,$00,$3E,$66,$66,$3E,$06,$06	;$71 - q
00D000  1               	DB	$00,$00,$7C,$66,$60,$60,$60,$00	;$72 - r
00D000  1               	DB	$00,$00,$3E,$60,$3C,$06,$7C,$00	;$73 - s
00D000  1               	DB	$00,$18,$7E,$18,$18,$18,$0E,$00	;$74 - t
00D000  1               	DB	$00,$00,$66,$66,$66,$66,$3E,$00	;$75 - u
00D000  1               	DB	$00,$00,$66,$66,$66,$3C,$18,$00	;$76 - v
00D000  1               	DB	$00,$00,$63,$6B,$7F,$3E,$36,$00	;$77 - w
00D000  1               	DB	$00,$00,$66,$3C,$18,$3C,$66,$00	;$78 - x
00D000  1               	DB	$00,$00,$66,$66,$66,$3E,$0C,$78	;$79 - y
00D000  1               	DB	$00,$00,$7E,$0C,$18,$30,$7E,$00	;$7A - z
00D000  1               	DB	$66,$66,$18,$3C,$66,$7E,$66,$00	;$7B - umlaut A
00D000  1               	DB	$18,$18,$18,$18,$18,$18,$18,$18	;$7C - |
00D000  1               	DB	$00,$7E,$78,$7C,$6E,$66,$06,$00	;$7D - display clear
00D000  1               	DB	$08,$18,$38,$78,$38,$18,$08,$00	;$7E - display backspace
00D000  1               	DB	$10,$18,$1C,$1E,$1C,$18,$10,$00	;$7F - display tab
00D000  1               ;	SUBTTL	'Self-test, Part 3'
00D000  1               ;	SPACE	4,10
00D000  1               	FIX	$D000
005000  1               	LOC	$5000	;$D000 - $D7FF mapped to $5000 - $57FF
005000  1               ;	SPACE	4,10
005000  1               ;**	STH - Self-test Hardware
005000  1               ;*
005000  1               ;*	ENTRY	JSR	STH
005000  1               ;*
005000  1               ;*	NOTES
005000  1               ;*		Problem: this is superfluous; SLFTSV could vector to
005000  1               ;*		EST.
005000  1               ;*
005000  1               ;*	MODS
005000  1               ;*		M. W. Colburn	10/26/82
005000  1               ;*		1. Bring closer to Coding Standard (object unchanged).
005000  1               ;*		   R. K. Nordin	11/01/83
005000  1               
005000  1               
005000  1               STH	=	*	;entry
005000  1  4C 09 50     	JMP	EST	;execute self-test
005003  1               ;	SPACE	4,10
005003  1               ;**	EMS - Execute Memory Self-test
005003  1               ;*
005003  1               ;*	ENTRY	JSR	EMS
005003  1               ;*
005003  1               ;*	MODS
005003  1               ;*		M. W. Colburn	10/26/82
005003  1               ;*		1. Bring closer to Coding Standard (object unchanged).
005003  1               ;*		   R. K. Nordin	11/01/83
005003  1               
005003  1               
005003  1               EMS	=	*	;entry
005003  1  20 86 50     	JSR	IST	;initialize self-test
005006  1  4C 91 52     	JMP	STM	;self-test memory
005009  1               ;	SPACE	4,10
005009  1               ;**	EST - Execute Self-test
005009  1               ;*
005009  1               ;*	ENTRY	JSR	EST
005009  1               ;*
005009  1               ;*	MODS
005009  1               ;*		M. W. Colburn	10/26/82
005009  1               ;*		1. Bring closer to Coding Standard (object unchanged).
005009  1               ;*		   R. K. Nordin	11/01/83
005009  1               
005009  1               
005009  1               EST	=	*	;entry
005009  1  20 86 50     	JSR	IST	;initialize self-test
00500C  1               ;	JMP	SEL	;self-test
00500C  1               ;	SPACE	4,10
00500C  1               ;**	SEL - Self-test
00500C  1               ;*
00500C  1               ;*	ENTRY	JSR	SEL
00500C  1               ;*
00500C  1               ;*	MODS
00500C  1               ;*		M. W. Colburn	10/26/82
00500C  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00500C  1               ;*		   R. K. Nordin	11/01/83
00500C  1               
00500C  1               
00500C  1               SEL	=	*		;entry
00500C  1               
00500C  1               ;	Initialize.
00500C  1               
00500C  1  A9 00        	LDA	#0
00500E  1  85 80        	STA	STTIME		;clear main screen timeout timer
005010  1  85 81        	STA	STTIME+1
005012  1  85 82        	STA	STAUT		;clear auto-mode flag
005014  1  8D 08 D2     	STA	AUDCTL		;initialize audio control register
005017  1  A9 03        	LDA	#$03		;initialize POKEY
005019  1  8D 0F D2     	STA	SKCTL		;serial port control
00501C  1  20 10 55     	JSR	SAS		;silence all sounds
00501F  1  A9 40        	LDA	#$40		;disable DLI
005021  1  8D 0E D4     	STA	NMIEN		;NMI enable
005024  1  A2 00        	LDX	#0		;main screen colors
005026  1  20 73 57     	JSR	SUC		;set up colors
005029  1  A2 3A        	LDX	#low DISL1	;display list for main screen
00502B  1  A0 51        	LDY	#high DISL1
00502D  1  20 9E 50     	JSR	SDL		;set up display list
005030  1  A9 D0        	LDA	#low PMD	;process main screen DLI routine
005032  1  8D 00 02     	STA	VDSLST		;display list NMI address
005035  1  A9 50        	LDA	#high PMD
005037  1  8D 01 02     	STA	VDSLST+1
00503A  1  A2 0C        	LDX	#3*4		;main screen bold lines
00503C  1  A9 AA        	LDA	#$AA		;color 1
00503E  1  20 2A 57     	JSR	SVR		;set value in range
005041  1               
005041  1               ;	Wait for all screen DLI's to clear and for VBLANK.
005041  1               
005041  1  A2 00        	LDX	#0
005043  1               
005043  1  8E 0A D4     SEL1	STX	WSYNC		;wait for HBLANK synchronization
005046  1  E8           	INX
005047  1  D0 FA        	BNE	SEL1		;if not done waiting
005049  1               
005049  1               ;	Wait until beam close to top (main screen DLI near).
005049  1               
005049  1  AD 0B D4     SEL2	LDA	VCOUNT
00504C  1  C9 18        	CMP	#24
00504E  1  B0 F9        	BCS	SEL2		;if not done waiting
005050  1               
005050  1               ;	Preset for self-test type determination.
005050  1               
005050  1  A9 10        	LDA	#$10		;initially select memory test
005052  1  85 87        	STA	STPASS		;pass indicator
005054  1  A9 C0        	LDA	#$C0		;enable DLI
005056  1  8D 0E D4     	STA	NMIEN
005059  1               
005059  1               ;	Determine type of self-test.
005059  1               
005059  1  AD 1F D0     SEL3	LDA	CONSOL		;console switches
00505C  1  29 01        	AND	#$01		;START key indicator
00505E  1  D0 F9        	BNE	SEL3		;if START key not pressed
005060  1               
005060  1  A9 FF        	LDA	#$FF		;clear character
005062  1  8D FC 02     	STA	CH
005065  1               
005065  1  A5 86        	LDA	STSEL		;selection
005067  1  29 0F        	AND	#$0F		;selection
005069  1  C9 01        	CMP	#$01		;memory test indicator
00506B  1  F0 10        	BEQ	SEL5		;if memory test
00506D  1               
00506D  1  C9 02        	CMP	#$02
00506F  1  F0 0F        	BEQ	SEL6		;if audio-visual test
005071  1               
005071  1  C9 04        	CMP	#$04
005073  1  F0 0E        	BEQ	SEL7		;if keyboard test
005075  1               
005075  1               ;	Self-test all.
005075  1               
005075  1  A9 88        SEL4	LDA	#$88		;indicate all tests
005077  1  85 86        	STA	STSEL		;selection
005079  1  A9 FF        	LDA	#$FF		;auto-mode indicator
00507B  1  85 82        	STA	STAUT		;auto-mode flag
00507D  1               
00507D  1               ;	Self-test memory.
00507D  1               
00507D  1  4C 91 52     SEL5	JMP	STM		;self-test memory
005080  1               
005080  1               ;	Self-test audio-visual.
005080  1               
005080  1  4C 57 55     SEL6	JMP	STV		;self-test audio-visual
005083  1               
005083  1               ;	Self-test keyboard.
005083  1               
005083  1  4C 50 54     SEL7	JMP	STK		;self-test keyboard
005086  1               ;	SPACE	4,10
005086  1               ;**	IST - Initialize Self-test
005086  1               ;*
005086  1               ;*	ENTRY	JSR	IST
005086  1               ;*
005086  1               ;*	MODS
005086  1               ;*		M. W. Colburn	10/26/82
005086  1               ;*		1. Bring closer to Coding Standard (object unchanged).
005086  1               ;*		   R. K. Nordin	11/01/83
005086  1               
005086  1               
005086  1               IST	=	*	;entry
005086  1  A9 11        	LDA	#$11	;indicate memory test
005088  1  85 86        	STA	STSEL	;selection
00508A  1  A9 21        	LDA	#$21
00508C  1  8D 2F 02     	STA	SDMCTL	;select small size playfield
00508F  1  A9 C0        	LDA	#$C0
005091  1  8D 0E D4     	STA	NMIEN	;enable DLI
005094  1  A9 41        	LDA	#$41
005096  1  85 83        	STA	STJMP	;ANTIC jump instruction
005098  1  A9 FF        	LDA	#$FF	;clear code indicator
00509A  1  8D FC 02     	STA	CH	;key code
00509D  1  60           	RTS		;return
00509E  1               ;	SPACE	4,10
00509E  1               ;**	SDL - Set Up Display List
00509E  1               ;*
00509E  1               ;*	ENTRY	JSR	SDL
00509E  1               ;*
00509E  1               ;*	MODS
00509E  1               ;*		M. W. Colburn	10/26/82
00509E  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00509E  1               ;*		   R. K. Nordin	11/01/83
00509E  1               
00509E  1               
00509E  1               SDL	=	*	;entry
00509E  1               
00509E  1  85 8A        	STA	STKST		;keyboard self-test flag
0050A0  1  98           	TYA
0050A1  1  48           	PHA			;save high address
0050A2  1  8A           	TXA
0050A3  1  48           	PHA			;save low address
0050A4  1  A9 00        	LDA	#0
0050A6  1  8D 2F 02     	STA	SDMCTL		;DMACTL (DMA control) shadow
0050A9  1  8D DC 02     	STA	HELPFG		;HELP key flag
0050AC  1  A9 DA        	LDA	#low POD	;process DLI routine
0050AE  1  8D 00 02     	STA	VDSLST
0050B1  1  A9 53        	LDA	#high POD
0050B3  1  8D 01 02     	STA	VDSLST+1
0050B6  1  A2 00        	LDX	#0*4		;screen memory
0050B8  1  8A           	TXA			;value is 0
0050B9  1  20 2A 57     	JSR	SVR		;set value in range
0050BC  1  68           	PLA			;saved low address
0050BD  1  AA           	TAX
0050BE  1  68           	PLA			;saved high address
0050BF  1  A8           	TAY
0050C0  1  8E 30 02     	STX	SDLSTL		;low display list address
0050C3  1  86 84        	STX	STJMP+1		;low display list address
0050C5  1  8C 31 02     	STY	SDLSTH		;high display list address
0050C8  1  84 85        	STY	STJMP+2		;high display list address
0050CA  1  A9 21        	LDA	#$21
0050CC  1  8D 2F 02     	STA	SDMCTL
0050CF  1  60           	RTS		;return
0050D0  1               ;	SPACE	4,10
0050D0  1               ;**	PMD - Process Main Screen DLI
0050D0  1               ;*
0050D0  1               ;*	1) IF MAIN SCREEN IS ON FOR MORE than FIVE MINUTES
0050D0  1               ;*	THEN 'ALL TESTS' SELECTION IS SELECTED AND EXECUTED
0050D0  1               ;*	2) COLORS FOR CURRENTLY SELECTED CHOICE AND THE
0050D0  1               ;*	NON-SELECTED CHOICES ARE DISPLAYED ON FLY
0050D0  1               ;*	3) SELECTION PROCESS IS HANDLED
0050D0  1               ;*
0050D0  1               ;*	ENTRY	JMP	PMD
0050D0  1               ;*
0050D0  1               ;*	EXIT
0050D0  1               ;*		Exits via RTI
0050D0  1               ;*
0050D0  1               ;*	MODS
0050D0  1               ;*		M. W. Colburn	10/26/82
0050D0  1               ;*		1. Bring closer to Coding Standard (object unchanged).
0050D0  1               ;*		   R. K. Nordin	11/01/83
0050D0  1               
0050D0  1               
0050D0  1               PMD	=	*	;entry
0050D0  1               
0050D0  1               ;	Initialize.
0050D0  1               
0050D0  1  48           	PHA		;save A
0050D1  1  8A           	TXA
0050D2  1  48           	PHA		;save X
0050D3  1               
0050D3  1               ;	Check for 4th time.
0050D3  1               
0050D3  1  A2 7A        PMD1	LDX	#$7A	;assume non-selected color
0050D5  1  A5 87        	LDA	STPASS	;pass indicator
0050D7  1  C9 01        	CMP	#$01	;4th time indicator
0050D9  1  F0 1F        	BEQ	PMD3	;if 4th time
0050DB  1               
0050DB  1               ;	Check for selection.
0050DB  1               
0050DB  1  29 01        	AND	#$01	;selection indicatorn
0050DD  1  F0 0A        	BEQ	PMD2	;if selected
0050DF  1               
0050DF  1               ;	Increment and check blink counter.
0050DF  1               
0050DF  1  E6 A2        	INC	STBL	;increment blink counter
0050E1  1  A5 A2        	LDA	STBL	;blink counter
0050E3  1  29 20        	AND	#$20	;blink indicator
0050E5  1  F0 02        	BEQ	PMD2	;if not to blink
0050E7  1               
0050E7  1  A2 2C        	LDX	#$2C	;use selected color
0050E9  1               
0050E9  1               ;	Set color.
0050E9  1               
0050E9  1  8E 0A D4     PMD2	STX	WSYNC	;wait for HBLANK synchronization
0050EC  1  8E 16 D0     	STX	COLPF0	;playfield 0 color
0050EF  1  18           	CLC
0050F0  1  66 87        	ROR	STPASS	;advance pass indicator
0050F2  1  A9 00        	LDA	#0
0050F4  1  85 4D        	STA	ATRACT
0050F6  1               
0050F6  1               ;	Exit.
0050F6  1               
0050F6  1  68           	PLA
0050F7  1  AA           	TAX		;restore X
0050F8  1  68           	PLA		;restore A
0050F9  1  40           	RTI		;return
0050FA  1               
0050FA  1               ;	Check for SELECT previously pressed.
0050FA  1               
0050FA  1  A5 88        PMD3	LDA	STSPP	;SELECT previously pressed  flag
0050FC  1  D0 16        	BNE	PMD4	;if SELECT previously pressed
0050FE  1               
0050FE  1               ;	Check for SELECT pressed.
0050FE  1               
0050FE  1  AD 1F D0     	LDA	CONSOL	;console switches
005101  1  29 02        	AND	#$02	;SELECT key indicator
005103  1  D0 1A        	BNE	PMD5	;if SELECT not pressed, exit
005105  1               
005105  1               ;	Process SELECT pressed.
005105  1               
005105  1  A5 86        	LDA	STSEL	;current selection
005107  1  2A           	ROL	A
005108  1  26 86        	ROL	STSEL	;next selection
00510A  1  A9 20        	LDA	#$20	;blink indicator
00510C  1  85 A2        	STA	STBL	;blink counter
00510E  1  A9 FF        	LDA	#$FF	;SELECT previously pressed indicator
005110  1  85 88        	STA	STSPP	;SELECT previously pressed flag
005112  1  D0 0B        	BNE	PMD5
005114  1               
005114  1               ;	Process SELECT previously pressed.
005114  1               
005114  1  AD 1F D0     PMD4	LDA	CONSOL	;console switches
005117  1  29 02        	AND	#$02	;SELECT key indicator
005119  1  F0 04        	BEQ	PMD5	;if SELECT still pressed
00511B  1               
00511B  1  A9 00        	LDA	#0	;SELECT not previously pressed indicator
00511D  1  85 88        	STA	STSPP	;SELECT previously pressed flag
00511F  1               
00511F  1               ;	???every 4th time???
00511F  1               
00511F  1  A5 86        PMD5	LDA	STSEL	;selection
005121  1  29 0F        	AND	#$0F
005123  1  09 10        	ORA	#$10	;reset indicate memory test
005125  1  85 87        	STA	STPASS	;pass indicator
005127  1               
005127  1               ;	Advance main screen timer.
005127  1               
005127  1  E6 80        	INC	STTIME
005129  1  D0 02        	BNE	PMD6	;if low not zero
00512B  1               
00512B  1  E6 81        	INC	STTIME+1
00512D  1               
00512D  1               ;	Check main screen timer.
00512D  1               
00512D  1  A5 81        PMD6	LDA	STTIME+1
00512F  1  C9 FA        	CMP	#250	;main screen timeout
005131  1  D0 04        	BNE	PMD7	;if main screen timed out
005133  1               
005133  1               ;	Process main screen timeout.
005133  1               
005133  1  58           	CLI
005134  1  4C 75 50     	JMP	SEL4	;self-test all
005137  1               
005137  1               ;	Continue.
005137  1               
005137  1  4C D3 50     PMD7	JMP	PMD1	;continue
00513A  1               ;	SPACE	4,10
00513A  1               ;**	DISL1 - Display List for Main Screen
00513A  1               
00513A  1               
00513A  1  70 70 70 70  DISL1	DB	$70,$70,$70,$70,$70
00513E  1  70 47 61 51  
005142  1  70 70 70 4E  
005161  1               	DB	$47
005161  1               	DW	SMEM1
005161  1               	DB	$70,$70,$70
005161  1               	DB	$4E
005161  1               	DW	ST3000
005161  1               	DB	$70
005161  1               	DB	$F0
005161  1               	DB	$C6
005161  1               	DW	SMEM2
005161  1               	DB	$70,$86
005161  1               	DB	$70,$86
005161  1               	DB	$70,$06
005161  1               	DB	$70,$70
005161  1               	DB	$4E
005161  1               	DW	ST3000
005161  1               	DB	$70,$70,$70
005161  1               	DB	$42
005161  1               	DW	SMEM3
005161  1               	DB	$41
005161  1               	DW	DISL1
005161  1               ;	SPACE	4,10
005161  1               ;**	SMEM1 - "SELF TEST" Text
005161  1               
005161  1               
005161  1  00 00 00 00  SMEM1	DB	$00,$00,$00,$00
005165  1  33 25 2C 26  
005169  1  00 34 25 33  
005171  1               	DB	$33,$25,$2C,$26		;"SELF"
005171  1               	DB	$00
005171  1               	DB	$34,$25,$33,$34		;"TEST"
005171  1               	DB	$00,$00,$00
005171  1               ;	SPACE	4,10
005171  1               ;**	SMEM2 - "MEMORY AUDIO-VISUAL KEYBOARD ALL TESTS" Text
005171  1               
005171  1               
005171  1  00 00 2D 25  SMEM2	DB	$00,$00
005175  1  2D 2F 32 39  
005179  1  00 00 00 00  
0051B1  1               	DB	$2D,$25,$2D,$2F,$32,$39			;"MEMORY"
0051B1  1               	DB	$00,$00,$00,$00,$00
0051B1  1               	DB	$00,$00,$00,$00,$00
0051B1  1               	DB	$21,$35,$24,$29,$2F			;"AUDIO"
0051B1  1               	DB	$0D					;"-"
0051B1  1               	DB	$36,$29,$33,$35,$21,$2C			;"VISUAL"
0051B1  1               	DB	$00,$00,$00,$00
0051B1  1               	DB	$2B,$25,$39,$22,$2F,$21,$32,$24		;"KEYBOARD"
0051B1  1               	DB	$00,$00,$00,$00,$00,$00,$00,$00
0051B1  1               	DB	$21,$2C,$2C				;"ALL"
0051B1  1               	DB	$00
0051B1  1               	DB	$34,$25,$33,$34,$33			;"TESTS"
0051B1  1               	DB	$00,$00,$00,$00,$00
0051B1  1               ;	SPACE	4,10
0051B1  1               ;**	SMEM3 - "SELECT,START OR RESET" Text
0051B1  1               
0051B1  1               
0051B1  1  00 00 00 00  SMEM3	DB	$00,$00,$00,$00
0051B5  1  42 B3 A5 AC  
0051B9  1  A5 A3 B4 56  
0051D1  1               	DB	$42
0051D1  1               	DB	$B3,$A5,$AC,$A5,$A3,$B4		;"SELECT"
0051D1  1               	DB	$56
0051D1  1               	DB	$0C				;","
0051D1  1               	DB	$42
0051D1  1               	DB	$B3,$B4,$A1,$B2,$B4		;"START"
0051D1  1               	DB	$56
0051D1  1               	DB	$2F,$32				;"OR"
0051D1  1               	DB	$42
0051D1  1               	DB	$B2,$A5,$B3,$A5,$B4		;"RESET"
0051D1  1               	DB	$56
0051D1  1               	DB	$00,$00,$00
0051D1  1               ;	SPACE	4,10
0051D1  1               ;**	DISL2 - Display List for Memory Test
0051D1  1               
0051D1  1               
0051D1  1  70 70 70 46  DISL2	DB	$70,$70,$70
0051D5  1  00 30 70 70  
0051D9  1  06 70 08 70  
0051ED  1               	DB	$46
0051ED  1               	DW	ST3000
0051ED  1               	DB	$70
0051ED  1               	DB	$70,$06
0051ED  1               	DB	$70,$08
0051ED  1               	DB	$70
0051ED  1               	DB	$70,$06
0051ED  1               	DB	$70,$08
0051ED  1               	DB	$70,$08
0051ED  1               	DB	$70,$08
0051ED  1               	DB	$70,$08
0051ED  1               	DB	$70,$70,$70
0051ED  1               	DB	$01
0051ED  1               	DW	DISL3
0051ED  1               ;	SPACE	4,10
0051ED  1               ;**	DISL3 - Display List for Exit Text
0051ED  1               
0051ED  1               
0051ED  1  A0 40 42 F5  DISL3	DB	$A0,$40
0051F1  1  51 01 83 00  
0051F5  1               	DB	$42
0051F5  1               	DW	SMEM4
0051F5  1               	DB	$01
0051F5  1               	DW	STJMP
0051F5  1               ;	SPACE	4,10
0051F5  1               ;**	SMEM4 - "RESET OR HELP TO EXIT" Text
0051F5  1               
0051F5  1               
0051F5  1  00 00 00 00  SMEM4	DB	$00,$00,$00,$00,$00
0051F9  1  00 42 B2 A5  
0051FD  1  B3 A5 B4 56  
005215  1               	DB	$42
005215  1               	DB	$B2,$A5,$B3,$A5,$B4	;"RESET"
005215  1               	DB	$56
005215  1               	DB	$2F,$32			;"OR"
005215  1               	DB	$42
005215  1               	DB	$A8,$A5,$AC,$B0		;"HELP"
005215  1               	DB	$56
005215  1               	DB	$34,$2F			;"TO"
005215  1               	DB	$00
005215  1               	DB	$25,$38,$29,$34		;"EXIT"
005215  1               	DB	$00,$00,$00,$00,$00
005215  1               ;	SPACE	4,10
005215  1               ;**	DISL4 - Display List for Keyboard Test
005215  1               
005215  1               
005215  1  70 70 70 70  DISL4	DB	$70,$70,$70,$70
005219  1  46 00 30 70  
00521D  1  70 70 70 02  
005231  1               	DB	$46
005231  1               	DW	ST3000
005231  1               	DB	$70,$70,$70
005231  1               	DB	$70,$02
005231  1               	DB	$70
005231  1               	DB	$70,$02
005231  1               	DB	$70,$02
005231  1               	DB	$70,$02
005231  1               	DB	$70,$02
005231  1               	DB	$70,$02
005231  1               	DB	$70,$70
005231  1               	DB	$01
005231  1               	DW	DISL3
005231  1               ;	SPACE	4,10
005231  1               ;**	DISL5 - Display List for Audio-visual Test
005231  1               
005231  1               
005231  1  70 70 70 70  DISL5	DB	$70,$70,$70,$70
005235  1  46 71 52 70  
005239  1  06 70 70 4B  
005271  1               	DB	$46
005271  1               	DW	SMEM5
005271  1               	DB	$70,$06
005271  1               	DB	$70,$70
005271  1               	DB	$4B
005271  1               	DW	ST3100
005271  1               	DB	$0B,$0B,$0B,$0B,$0B,$0B,$0B,$0B
005271  1               	DB	$0B,$0B,$0B,$0B,$0B,$0B,$0B,$0B
005271  1               	DB	$0B,$0B,$0B,$0B,$0B,$0B,$0B,$0B
005271  1               	DB	$0B,$0B,$0B,$0B,$0B,$0B,$0B,$0B
005271  1               	DB	$0B,$0B,$0B,$0B,$0B,$0B,$0B,$0B
005271  1               	DB	$0B,$0B
005271  1               	DB	$70
005271  1               	DB	$46
005271  1               	DW	ST3000
005271  1               	DB	$70
005271  1               	DB	$01
005271  1               	DW	DISL3
005271  1               ;	SPACE	4,10
005271  1               ;**	SMEM5 - "AUDIO-VISUAL TEST" Text
005271  1               
005271  1               
005271  1  00 00 21 35  SMEM5	DB	$00,$00
005275  1  24 29 2F 0D  
005279  1  36 29 33 35  
005291  1               	DB	$21,$35,$24,$29,$2F		;"AUDIO"
005291  1               	DB	$0D				;"-"
005291  1               	DB	$36,$29,$33,$35,$21,$2C		;"VISUAL"
005291  1               	DB	$00,$00,$00,$00
005291  1               	DB	$00,$00,$00,$00
005291  1               	DB	$34,$25,$33,$34			;"TEST"
005291  1               	DB	$00,$00,$00,$00,$00,$00
005291  1               ;	SPACE	4,10
005291  1               ;**	STM - Self-test Memory
005291  1               ;*
005291  1               ;*	STM verifies ROM and RAM by verifying the ROM checksums and
005291  1               ;*	writing and reading all possible values to each byte of RAM.
005291  1               ;*
005291  1               ;*	ENTRY	JSR	STM
005291  1               ;*
005291  1               ;*	NOTES
005291  1               ;*		Problem: searches beyond end of TMNT.
005291  1               ;*
005291  1               ;*	MODS
005291  1               ;*		M. W. Colburn	10/26/82
005291  1               ;*		1. Bring closer to Coding Standard (object unchanged).
005291  1               ;*		   R. K. Nordin	11/01/83
005291  1               
005291  1               
005291  1               STM	=	*		;entry
005291  1               
005291  1               ;	Initialize.
005291  1               
005291  1  A2 D1        	LDX	#low DISL2	;memory test display list
005293  1  A0 51        	LDY	#high DISL2
005295  1  A9 00        	LDA	#0		;indicate not keyboard self-test
005297  1  20 9E 50     	JSR	SDL		;set up display list
00529A  1  A2 01        	LDX	#1		;memory test colors
00529C  1  20 73 57     	JSR	SUC		;set up colors
00529F  1  A2 00        	LDX	#0		;offset to "MEMORY TEST   ROM" test
0052A1  1  20 59 57     	JSR	SSM		;set screen memory
0052A4  1  A2 01        	LDX	#1		;offset to "RAM" text
0052A6  1  20 59 57     	JSR	SSM		;set screen memory
0052A9  1               
0052A9  1               ;	Test first 8K ROM.
0052A9  1               
0052A9  1  AD 20 30     STM1	LDA	ST3020
0052AC  1  C9 AA        	CMP	#$AA		;color 1 for failure
0052AE  1  F0 17        	BEQ	STM4		;if first 8K ROM already failed
0052B0  1               
0052B0  1  A9 55        	LDA	#$55		;color 0 for test
0052B2  1  20 8E 53     	JSR	DFS		;display first ROM status
0052B5  1  20 B1 53     	JSR	DMW		;delay a middling while
0052B8  1  20 73 FF     	JSR	VFR		;verify first 8K ROM
0052BB  1  B0 05        	BCS	STM2		;if ROM failed
0052BD  1               
0052BD  1  A9 FF        	LDA	#$FF		;color 2 for success
0052BF  1  4C C4 52     	JMP	STM3
0052C2  1               
0052C2  1  A9 AA        STM2	LDA	#$AA		;color 1 for failure
0052C4  1               
0052C4  1  20 8E 53     STM3	JSR	DFS		;display first ROM status
0052C7  1               
0052C7  1               ;	Test second 8K ROM.
0052C7  1               
0052C7  1  AD 24 30     STM4	LDA	ST3024
0052CA  1  C9 AA        	CMP	#$AA		;color 1 for failure
0052CC  1  F0 17        	BEQ	STM7		;if second 8K ROM already failed
0052CE  1               
0052CE  1  A9 55        	LDA	#$55		;color 0 for test
0052D0  1  20 99 53     	JSR	DSS		;display second ROM status
0052D3  1  20 B1 53     	JSR	DMW		;delay a middling while
0052D6  1  20 92 FF     	JSR	VSR		;verify second 8K ROM
0052D9  1  B0 05        	BCS	STM5		;if ROM failed
0052DB  1               
0052DB  1  A9 FF        	LDA	#$FF		;color 2 for success
0052DD  1  4C E2 52     	JMP	STM6
0052E0  1               
0052E0  1  A9 AA        STM5	LDA	#$AA		;color 1 for failure
0052E2  1               
0052E2  1  20 99 53     STM6	JSR	DSS		;display second ROM status
0052E5  1               
0052E5  1               ;	Test RAM.
0052E5  1               
0052E5  1  A9 C0        STM7	LDA	#$C0		;mask for left side of a screen byte
0052E7  1  85 8D        	STA	STSMM
0052E9  1  A9 04        	LDA	#$04		;initially select LED 1 off
0052EB  1  85 A4        	STA	STLM		;LED mask
0052ED  1  A9 00        	LDA	#0
0052EF  1  85 8E        	STA	STSMP		;initialize ???
0052F1  1  85 90        	STA	STPAG		;initialize current page
0052F3  1  85 91        	STA	STPAG+1
0052F5  1  85 8F        	STA	ST1K		;initialize current 1K to test
0052F7  1               
0052F7  1               ;	Test 1K of RAM.
0052F7  1               
0052F7  1  A6 8E        STM8	LDX	STSMP		;screen memory pointer
0052F9  1  BD 38 30     	LDA	ST3038,X
0052FC  1  25 8D        	AND	STSMM
0052FE  1  C9 80        	CMP	#$80
005300  1  F0 5C        	BEQ	STM17		;if already failed
005302  1               
005302  1  C9 08        	CMP	#$08
005304  1  F0 58        	BEQ	STM17		;if already failed
005306  1               
005306  1  A9 44        	LDA	#$44		;color 0 for test
005308  1  20 C3 53     	JSR	DRS		;display RAM block status
00530B  1  A5 A4        	LDA	STLM		;LED mask
00530D  1  20 A4 53     	JSR	SLD		;set LED's
005310  1  A5 A4        	LDA	STLM		;current LED mask
005312  1  49 0C        	EOR	#$0C		;complement LED's selected
005314  1  85 A4        	STA	STLM		;update LED mask
005316  1               
005316  1               ;	Check for memory not to test.
005316  1               
005316  1  A2 07        	LDX	#TMNTL-1+2	;2 bytes beyond last byte of table
005318  1               
005318  1  BD 4A 54     STM9	LDA	TMNT,X		;range to test
00531B  1  C5 91        	CMP	STPAG+1		;high current page
00531D  1  F0 37        	BEQ	STM15		;if not to test, indicate success
00531F  1               
00531F  1  CA           	DEX
005320  1  10 F6        	BPL	STM9		;if not done
005322  1               
005322  1               ;	Test 1K of RAM.
005322  1               
005322  1  A9 04        	LDA	#4		;number of pages to test
005324  1  85 92        	STA	STPC		;page count
005326  1               
005326  1               ;	Write initial list to page.
005326  1               
005326  1  A2 00        STM10	LDX	#0		;initial value to write
005328  1               
005328  1               ;	Write list to page.
005328  1               
005328  1  A0 00        STM11	LDY	#0		;offset to first byte of page
00532A  1               
00532A  1  8A           STM12	TXA
00532B  1  91 90        	STA	(STPAG),Y	;byte of page
00532D  1  E8           	INX
00532E  1  C8           	INY
00532F  1  D0 F9        	BNE	STM12		;if not done writing page
005331  1               
005331  1               ;	Verify list written to page.
005331  1               
005331  1  86 93        	STX	STMVAL		;first correct value to test
005333  1  A0 00        	LDY	#0		;offset to first byte of page
005335  1               
005335  1  B1 90        STM13	LDA	(STPAG),Y	;byte of page
005337  1  C5 93        	CMP	STMVAL		;correct value
005339  1  D0 10        	BNE	STM14		;if not correct value
00533B  1               
00533B  1  E6 93        	INC	STMVAL		;increment value to test
00533D  1  C8           	INY
00533E  1  D0 F5        	BNE	STM13		;if not done verifying page
005340  1               
005340  1               ;	Increment and test initial value to write.
005340  1               
005340  1  E8           	INX			;increment initial value to write
005341  1  D0 E5        	BNE	STM11		;if not done, write another list
005343  1               
005343  1               ;	Decrement and test page counter.
005343  1               
005343  1  E6 91        	INC	STPAG+1		;increment high current page
005345  1  C6 92        	DEC	STPC		;decrement page count
005347  1  D0 DD        	BNE	STM10		;if not done testing pages
005349  1               
005349  1  F0 0E        	BEQ	STM16		;indicate success
00534B  1               
00534B  1               ;	Display failure.
00534B  1               
00534B  1  20 B1 53     STM14	JSR	DMW		;delay a middling while
00534E  1  A9 88        	LDA	#$88		;color 1 for failure
005350  1  20 C3 53     	JSR	DRS		;display RAM block status
005353  1  4C 5E 53     	JMP	STM17
005356  1               
005356  1               ;	Delay for simulating test of memory not to test.
005356  1               
005356  1  20 B5 53     STM15	JSR	DLW		;delay a long while
005359  1               
005359  1               ;	Display success.
005359  1               
005359  1  A9 CC        STM16	LDA	#$CC		;color 2 for success
00535B  1  20 C3 53     	JSR	DRS		;display RAM block status
00535E  1               
00535E  1  A5 8D        STM17	LDA	STSMM
005360  1  30 26        	BMI	STM20
005362  1               
005362  1  A9 C0        	LDA	#$C0
005364  1  85 8D        	STA	STSMM
005366  1  E6 8E        	INC	STSMP		;increment screen memory pointer
005368  1               
005368  1  18           STM18	CLC
005369  1  A5 8F        	LDA	ST1K		;current 1K to test
00536B  1  69 04        	ADC	#high $0400	;add 1K
00536D  1  85 91        	STA	STPAG+1		;high current page
00536F  1  85 8F        	STA	ST1K		;update current 1K to test
005371  1  CD E4 02     	CMP	RAMSIZ		;RAM size
005374  1  D0 81        	BNE	STM8		;if not done testing RAM
005376  1               
005376  1               ;	Check for auto-mode.
005376  1               
005376  1  A5 82        	LDA	STAUT		;auto-mode flag
005378  1  D0 03        	BNE	STM19		;if auto-mode, perform audio-visual test
00537A  1               
00537A  1               ;	Test memory again.
00537A  1               
00537A  1  4C A9 52     	JMP	STM1		;test memory again
00537D  1               
00537D  1               ;	Process auto-mode.
00537D  1               
00537D  1  A9 0C        STM19	LDA	#$0C	;indicate LED 1 and 2 off
00537F  1  20 A4 53     	JSR	SLD	;set LED's
005382  1  20 B5 53     	JSR	DLW	;delay a long while
005385  1  4C 57 55     	JMP	STV	;self-test audio-visual
005388  1               
005388  1  A9 0C        STM20	LDA	#$0C
00538A  1  85 8D        	STA	STSMM
00538C  1  D0 DA        	BNE	STM18
00538E  1               ;	SPACE	4,10
00538E  1               ;**	DFS - Display First ROM Status
00538E  1               ;*
00538E  1               ;*	ENTRY	JSR	DFS
00538E  1               ;*
00538E  1               ;*	MODS
00538E  1               ;*		M. W. Colburn	10/26/82
00538E  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00538E  1               ;*		   R. K. Nordin	11/01/83
00538E  1               
00538E  1               
00538E  1               DFS	=	*		;entry
00538E  1  A2 04        	LDX	#1*4		;first 8K ROM display
005390  1  20 2A 57     	JSR	SVR		;set value in range
005393  1  29 FC        	AND	#$FC
005395  1  8D 23 30     	STA	ST3020+3
005398  1  60           	RTS			;return
005399  1               ;	SPACE	4,10
005399  1               ;**	DSS - Display Second ROM Status
005399  1               ;*
005399  1               ;*	ENTRY	JSR	DSS
005399  1               ;*
005399  1               ;*	MODS
005399  1               ;*		M. W. Colburn	10/26/82
005399  1               ;*		1. Bring closer to Coding Standard (object unchanged).
005399  1               ;*		   R. K. Nordin	11/01/83
005399  1               
005399  1               
005399  1               DSS	=	*		;entry
005399  1  A2 08        	LDX	#2*4		;second 8K ROM display
00539B  1  20 2A 57     	JSR	SVR		;set value in range
00539E  1  29 FC        	AND	#$FC
0053A0  1  8D 27 30     	STA	ST3024+3
0053A3  1  60           	RTS			;return
0053A4  1               ;	SPACE	4,10
0053A4  1               ;**	SLD - Set LED's
0053A4  1               ;*
0053A4  1               ;*	ENTRY	JSR	SLD
0053A4  1               ;*		A = LED mask (bit 3 - LED 2, bit 2 - LED 1)
0053A4  1               ;*
0053A4  1               ;*	MODS
0053A4  1               ;*		M. W. Colburn	10/26/82
0053A4  1               ;*		1. Bring closer to Coding Standard (object unchanged).
0053A4  1               ;*		   R. K. Nordin	11/01/83
0053A4  1               
0053A4  1               
0053A4  1               SLD	=	*		;entry
0053A4  1  85 A5        	STA	STTMP5		;save LED mask
0053A6  1  AD 01 D3     	LDA	PORTB
0053A9  1  29 F3        	AND	#$F3		;clear LED control
0053AB  1  05 A5        	ORA	STTMP5		;set LED control according to mask
0053AD  1  8D 01 D3     	STA	PORTB		;update port B memory control
0053B0  1  60           	RTS			;return
0053B1  1               ;	SPACE	4,10
0053B1  1               ;**	DMW - Delay a Middling While
0053B1  1               ;*
0053B1  1               ;*	ENTRY	JSR	DMW
0053B1  1               ;*
0053B1  1               ;*	MODS
0053B1  1               ;*		M. W. Colburn	10/26/82
0053B1  1               ;*		1. Bring closer to Coding Standard (object unchanged).
0053B1  1               ;*		   R. K. Nordin	11/01/83
0053B1  1               
0053B1  1               
0053B1  1               DMW	=	*		;entry
0053B1  1  A2 3C        	LDX	#60		;60-VBLANK delay
0053B3  1  D0 02        	BNE	DAW		;delay a while
0053B5  1               ;	SPACE	4,10
0053B5  1               ;**	DLW - Delay a Long While
0053B5  1               ;*
0053B5  1               ;*	ENTRY	JSR	DLW
0053B5  1               ;*
0053B5  1               ;*	MODS
0053B5  1               ;*		M. W. Colburn	10/26/82
0053B5  1               ;*		1. Bring closer to Coding Standard (object unchanged).
0053B5  1               ;*		   R. K. Nordin	11/01/83
0053B5  1               
0053B5  1               
0053B5  1               DLW	=	*		;entry
0053B5  1  A2 96        	LDX	#150		;150-VBLANK delay
0053B7  1               ;	JMP	DAW		;delay a while, return
0053B7  1               ;	SPACE	4,10
0053B7  1               ;**	DAW - Delay a While
0053B7  1               ;*
0053B7  1               ;*	ENTRY	JSR	DAW
0053B7  1               ;*
0053B7  1               ;*	MODS
0053B7  1               ;*		M. W. Colburn	10/26/82
0053B7  1               ;*		1. Bring closer to Coding Standard (object unchanged).
0053B7  1               ;*		   R. K. Nordin	11/01/83
0053B7  1               
0053B7  1               
0053B7  1               DAW	=	*		;entry
0053B7  1               
0053B7  1  A0 FF        DAW1	LDY	#$FF		;initialize inner loop counter
0053B9  1               
0053B9  1  8C 0A D4     DAW2	STY	WSYNC		;wait for HBLANK synchronization
0053BC  1  88           	DEY
0053BD  1  D0 FA        	BNE	DAW2		;if inner loop not done
0053BF  1               
0053BF  1  CA           	DEX
0053C0  1  D0 F5        	BNE	DAW1		;if outer loop not done
0053C2  1               
0053C2  1  60           	RTS			;return
0053C3  1               ;	SPACE	4,10
0053C3  1               ;**	DRS - Display RAM Block Status
0053C3  1               ;*
0053C3  1               ;*	ENTRY	JSR	DRS
0053C3  1               ;*
0053C3  1               ;*	MODS
0053C3  1               ;*		M. W. Colburn	10/26/82
0053C3  1               ;*		1. Bring closer to Coding Standard (object unchanged).
0053C3  1               ;*		   R. K. Nordin	11/01/83
0053C3  1               
0053C3  1               
0053C3  1               DRS	=	*		;entry
0053C3  1  48           	PHA			;save color
0053C4  1  A6 8E        	LDX	STSMP
0053C6  1  A5 8D        	LDA	STSMM
0053C8  1  49 FF        	EOR	#$FF		;complement
0053CA  1  3D 38 30     	AND	ST3038,X
0053CD  1  9D 38 30     	STA	ST3038,X
0053D0  1  68           	PLA			;saved color
0053D1  1  25 8D        	AND	STSMM
0053D3  1  1D 38 30     	ORA	ST3038,X
0053D6  1  9D 38 30     	STA	ST3038,X
0053D9  1  60           	RTS			;return
0053DA  1               ;	SPACE	4,10
0053DA  1               ;**	POD - Process Other DLI's
0053DA  1               ;*
0053DA  1               ;*	POD turns the last line on the screen into white on black,
0053DA  1               ;*	handles keyboard self-test display of console switches, handles
0053DA  1               ;*	HELP key for exit, and ensures no attract-mode.
0053DA  1               ;*
0053DA  1               ;*	ENTRY	JMP	POD
0053DA  1               ;*
0053DA  1               ;*	EXIT
0053DA  1               ;*		Exits via RTI
0053DA  1               ;*
0053DA  1               ;*	MODS
0053DA  1               ;*		M. W. Colburn	10/26/82
0053DA  1               ;*		1. Bring closer to Coding Standard (object unchanged).
0053DA  1               ;*		   R. K. Nordin	11/01/83
0053DA  1               
0053DA  1               
0053DA  1               POD	=	*	;entry
0053DA  1               
0053DA  1               ;	Initialize.
0053DA  1               
0053DA  1  48           	PHA		;save A
0053DB  1               
0053DB  1               ;	Select colors.
0053DB  1               
0053DB  1  A9 0C        	LDA	#$0C	;white color
0053DD  1  8D 17 D0     	STA	COLPF1	;playfield 1 color
0053E0  1  AD C8 02     	LDA	COLOR4	;background color
0053E3  1  8D 18 D0     	STA	COLPF2	;playfield 2 color
0053E6  1               
0053E6  1               ;	Ensure no attract-mode.
0053E6  1               
0053E6  1  A9 00        	LDA	#0	;no attract-mode
0053E8  1  85 4D        	STA	ATRACT	;attract-mode timer/flag
0053EA  1               
0053EA  1               ;	Check HELP key.
0053EA  1               
0053EA  1  AD DC 02     	LDA	HELPFG	;HELP key flag
0053ED  1  F0 0E        	BEQ	POD1	;if HELP not pressed
0053EF  1               
0053EF  1               ;	Process HELP key.
0053EF  1               
0053EF  1  A9 00        	LDA	#0	;HELP key not pressed indicator
0053F1  1  8D DC 02     	STA	HELPFG	;HELP key flag
0053F4  1  A9 0C        	LDA	#$0C	;LED's off
0053F6  1  20 A4 53     	JSR	SLD	;set LED's
0053F9  1  58           	CLI
0053FA  1  4C 0C 50     	JMP	SEL	;start over with main screen
0053FD  1               
0053FD  1               ;	Check for keyboard self-test.
0053FD  1               
0053FD  1  A5 8A        POD1	LDA	STKST	;keyboard self-test flag
0053FF  1  F0 47        	BEQ	POD10	;if not keyboard self-test, exit
005401  1               
005401  1               ;	Set display of console switches pressed.
005401  1               
005401  1  AD 1F D0     	LDA	CONSOL	;console switches
005404  1  29 01        	AND	#$01	;START key indicator
005406  1  F0 04        	BEQ	POD2	;if START key pressed
005408  1               
005408  1  A9 B3        	LDA	#$B3
00540A  1  D0 02        	BNE	POD3	;set display
00540C  1               
00540C  1  A9 33        POD2	LDA	#$33
00540E  1               
00540E  1  8D 1C 30     POD3	STA	ST301C	;set START key display
005411  1               
005411  1  AD 1F D0     	LDA	CONSOL	;console switches
005414  1  29 02        	AND	#$02	;SELECT key indicator
005416  1  F0 04        	BEQ	POD4	;if SELECT key pressed
005418  1               
005418  1  A9 F3        	LDA	#$F3
00541A  1  D0 02        	BNE	POD5	;set display
00541C  1               
00541C  1  A9 73        POD4	LDA	#$73
00541E  1               
00541E  1  8D 1E 30     POD5	STA	ST301E	;set SELECT key display
005421  1               
005421  1  AD 1F D0     	LDA	CONSOL	;console switches
005424  1  29 04        	AND	#$04	;OPTION key indicator
005426  1  F0 04        	BEQ	POD6	;if OPTION key pressed
005428  1               
005428  1  A9 AF        	LDA	#$AF
00542A  1  D0 02        	BNE	POD7	;set display
00542C  1               
00542C  1  A9 2F        POD6	LDA	#$2F
00542E  1               
00542E  1  8D 20 30     POD7	STA	ST3020	;set OPTION key display
005431  1               
005431  1               ;	Sound tone if console switches pressed.
005431  1               
005431  1  AD 1F D0     	LDA	CONSOL	;console switches
005434  1  29 07        	AND	#$07	;key indicators
005436  1  C9 07        	CMP	#$07	;no keys pressed
005438  1  F0 09        	BEQ	POD8	;if no keys pressed
00543A  1               
00543A  1  A9 64        	LDA	#100	;frequency
00543C  1  8D 02 D2     	STA	AUDF2	;set frequency of voice 2
00543F  1  A9 A8        	LDA	#$A8	;pure tone, half volume
005441  1  D0 02        	BNE	POD9	;set control of voice 2
005443  1               
005443  1  A9 00        POD8	LDA	#0	;zero volume
005445  1               
005445  1  8D 03 D2     POD9	STA	AUDC2	;set control of voice 2
005448  1               
005448  1               ;	Exit.
005448  1               
005448  1  68           POD10	PLA		;restore A
005449  1  40           	RTI		;return
00544A  1               ;	SPACE	4,10
00544A  1               ;**	TMNT - Table of Memory Not to Test
00544A  1               ;*
00544A  1               ;*	NOTES
00544A  1               ;*		Problem: bytes wasted by redundant entries.
00544A  1               
00544A  1               
00544A  1  00 50 54 30  TMNT	DB	high $0000	;$0000 - $03FF, zero page and stack
00544E  1  30 30        
005450  1               	DB	high $5000	;$5000 - $53FF, self-test ROM
005450  1               	DB	high $5400	;$5400 - $57FF, self-test ROM
005450  1               	DB	high ST3000	;ST3000 - ST3000+$03FF, screen memory
005450  1               	DB	high ST3000	;ST3000 - ST3000+$03FF, screen memory
005450  1               	DB	high ST3000	;ST3000 - ST3000+$03FF, screen memory
005450  1               
005450  1               TMNTL	=	*-TMNT	;length
005450  1               ;	SPACE	4,10
005450  1               ;**	STK - Self-test Keyboard
005450  1               ;*
005450  1               ;*	STK verifies the operation of the keyboard by displaying
005450  1               ;*	keys as they are pressed.  In auto-mode, the verification
005450  1               ;*	is simulated.
005450  1               ;*
005450  1               ;*	ENTRY	JSR	STK
005450  1               ;*
005450  1               ;*	NOTES
005450  1               ;*		Problem: one too many bytes taken from TSKP table.
005450  1               ;*		Problem: wasted bytes for extra LDA CH.
005450  1               ;*		Problem: logic is convoluted (due to SBT and SAS
005450  1               ;*		subroutines appearing in the middle of STK).
005450  1               ;*
005450  1               ;*	MODS
005450  1               ;*		M. W. Colburn	10/26/82
005450  1               ;*		1. Bring closer to Coding Standard (object unchanged).
005450  1               ;*		   R. K. Nordin	11/01/83
005450  1               
005450  1               
005450  1               STK	=	*		;entry
005450  1               
005450  1               ;	Initialize.
005450  1               
005450  1  A2 00        	LDX	#0
005452  1  86 94        	STX	STSKP		;initialize simulated keypress index
005454  1  A2 03        	LDX	#3		;keyboard test colors
005456  1  20 73 57     	JSR	SUC		;set up colors
005459  1  A2 15        	LDX	#low DISL4	;keyboard display list
00545B  1  A0 52        	LDY	#high DISL4
00545D  1  A9 FF        	LDA	#$FF		;indicate keyboard self-test
00545F  1  20 9E 50     	JSR	SDL		;set up display list
005462  1               
005462  1               ;	Test keyboard.
005462  1               
005462  1  A2 02        STK1	LDX	#2		;offset to "KEYBOARD TEST" text
005464  1  20 59 57     	JSR	SSM		;set screen memory
005467  1  A2 07        	LDX	#7		;offset to keyboard text
005469  1  20 59 57     	JSR	SSM		;set screen memory
00546C  1               
00546C  1               ;	Check auto-mode.
00546C  1               
00546C  1  A5 82        	LDA	STAUT		;auto-mode flag
00546E  1  F0 13        	BEQ	STK3		;if not auto-mode
005470  1               
005470  1               ;	Simulate keypress.
005470  1               
005470  1  A6 94        STK2	LDX	STSKP		;offset to next simulated keypress
005472  1  BD 45 55     	LDA	TSKP,X		;simulated keypress
005475  1  E6 94        	INC	STSKP		;advance offset to simulated keypress
005477  1  A6 94        	LDX	STSKP		;offset to simulated keypress
005479  1  E0 13        	CPX	#TSKPL+1	;last offset+1+1
00547B  1  D0 14        	BNE	STK4		;if last keypress not processed
00547D  1               
00547D  1               ;	Self-test memory.
00547D  1               
00547D  1  20 B5 53     	JSR	DLW		;delay a long while
005480  1  4C 91 52     	JMP	STM		;self-test memory
005483  1               
005483  1               ;	Get a keypress.
005483  1               
005483  1  AD FC 02     STK3	LDA	CH		;key code
005486  1  C9 FF        	CMP	#$FF		;clear code indicator
005488  1  F0 F9        	BEQ	STK3		;if no key pressed
00548A  1               
00548A  1  C9 C0        	CMP	#$C0
00548C  1  B0 F5        	BCS	STK3		;if ???
00548E  1               
00548E  1  AD FC 02     	LDA	CH		;key code
005491  1               
005491  1               ;	Process keypress.
005491  1               
005491  1  A2 FF        STK4	LDX	#$FF		;clear code indicator
005493  1  8E FC 02     	STX	CH		;key code
005496  1  48           	PHA			;save key code
005497  1  29 80        	AND	#$80
005499  1  F0 05        	BEQ	STK5		;if not CTRL
00549B  1               
00549B  1  A2 08        	LDX	#8		;offset to control key text
00549D  1  20 59 57     	JSR	SSM		;set screen memory
0054A0  1               
0054A0  1               ;	Check for shift key.
0054A0  1               
0054A0  1  68           STK5	PLA			;saved key code
0054A1  1  48           	PHA			;save key code
0054A2  1  29 40        	AND	#$40
0054A4  1  F0 0A        	BEQ	STK6		;if not shift key
0054A6  1               
0054A6  1               ;	Process keyboard shift key display.
0054A6  1               
0054A6  1  A2 05        	LDX	#5		;offset to "SH"
0054A8  1  20 59 57     	JSR	SSM		;set screen memory
0054AB  1  A2 04        	LDX	#4		;offset to "SH"
0054AD  1  20 59 57     	JSR	SSM		;set screen memory
0054B0  1               
0054B0  1               ;	Check for special keys.
0054B0  1               
0054B0  1  68           STK6	PLA			;saved key code
0054B1  1  29 3F        	AND	#$3F
0054B3  1  C9 21        	CMP	#$21
0054B5  1  F0 68        	BEQ	KSB		;if space bar, process display
0054B7  1               
0054B7  1  C9 2C        	CMP	#$2C
0054B9  1  F0 74        	BEQ	KTK		;if tab key, process display
0054BB  1               
0054BB  1  C9 34        	CMP	#$34
0054BD  1  F0 68        	BEQ	KBK		;if backspace key, process display
0054BF  1               
0054BF  1  C9 0C        	CMP	#$0C
0054C1  1  F0 76        	BEQ	KRK		;if return key, process display
0054C3  1               
0054C3  1               ;	Process other key displays.
0054C3  1               
0054C3  1  AA           	TAX			;key code
0054C4  1  BD 9C 57     	LDA	TSMC,X		;display character
0054C7  1  48           	PHA			;save display character
0054C8  1               
0054C8  1  A9 21        	LDA	#low ST3021
0054CA  1  85 95        	STA	STTMP1		;screen pointer
0054CC  1  A9 30        	LDA	#high ST3021
0054CE  1  85 96        	STA	STTMP1+1
0054D0  1               
0054D0  1               ;	Find display character in screen memory.
0054D0  1               
0054D0  1  68           	PLA			;saved display character
0054D1  1  A0 FF        	LDY	#$FF		;preset offset
0054D3  1               
0054D3  1  C8           STK7	INY
0054D4  1  D1 95        	CMP	(STTMP1),Y
0054D6  1  D0 FB        	BNE	STK7		;if not found
0054D8  1               
0054D8  1               ;	Display inverse video.
0054D8  1               
0054D8  1  B1 95        	LDA	(STTMP1),Y
0054DA  1  49 80        	EOR	#$80		;invert video
0054DC  1  91 95        	STA	(STTMP1),Y
0054DE  1               
0054DE  1               ;	Check auto-mode.
0054DE  1               
0054DE  1  A5 82        STK8	LDA	STAUT		;auto-mode flag
0054E0  1  F0 13        	BEQ	STK9		;if not auto-mode
0054E2  1               
0054E2  1               ;	Process auto-mode.
0054E2  1               
0054E2  1  20 05 55     	JSR	SBT		;sound beep tone
0054E5  1  A2 14        	LDX	#20		;20-VBLANK delay
0054E7  1  20 B7 53     	JSR	DAW		;delay a while
0054EA  1  20 10 55     	JSR	SAS		;silence all sounds
0054ED  1  A2 0A        	LDX	#10		;10-VBLANK delay
0054EF  1  20 B7 53     	JSR	DAW		;delay a while
0054F2  1  4C 62 54     	JMP	STK1		;get next simulated keypress
0054F5  1               
0054F5  1               ;	Process manual mode.
0054F5  1               
0054F5  1  20 05 55     STK9	JSR	SBT		;sound beep tone
0054F8  1               
0054F8  1  AD 0F D2     STK10	LDA	SKSTAT
0054FB  1  29 04        	AND	#$04
0054FD  1  F0 F9        	BEQ	STK10
0054FF  1               
0054FF  1  20 10 55     	JSR	SAS		;silence all sounds
005502  1  4C 62 54     	JMP	STK1		;get next keypress
005505  1               ;	SPACE	4,10
005505  1               ;**	SBT - Sound Beep Tone
005505  1               ;*
005505  1               ;*	ENTRY	JSR	SBT
005505  1               ;*
005505  1               ;*	MODS
005505  1               ;*		M. W. Colburn	10/26/82
005505  1               ;*		1. Bring closer to Coding Standard (object unchanged).
005505  1               ;*		   R. K. Nordin	11/01/83
005505  1               
005505  1               
005505  1               SBT	=	*	;entry
005505  1  A9 64        	LDA	#$64	;frequency
005507  1  8D 00 D2     	STA	AUDF1	;set frequency
00550A  1  A9 A8        	LDA	#$A8	;pure tone, half volume
00550C  1  8D 01 D2     	STA	AUDC1	;set control
00550F  1  60           	RTS		;return
005510  1               ;	SPACE	4,10
005510  1               ;**	SAS - Silence All Sounds
005510  1               ;*
005510  1               ;*	ENTRY	JSR	SAS
005510  1               ;*
005510  1               ;*	MODS
005510  1               ;*		M. W. Colburn	10/26/82
005510  1               ;*		1. Bring closer to Coding Standard (object unchanged).
005510  1               ;*		   R. K. Nordin	11/01/83
005510  1               
005510  1               
005510  1               SAS	=	*	;entry
005510  1  A9 00        	LDA	#0	;volume 0
005512  1  8D 01 D2     	STA	AUDC1	;silence voice 1
005515  1  8D 03 D2     	STA	AUDC2	;silence voice 2
005518  1  8D 05 D2     	STA	AUDC3	;silence voice 3
00551B  1  8D 07 D2     	STA	AUDC4	;silence voice 4
00551E  1  60           	RTS		;return
00551F  1               ;	SPACE	4,10
00551F  1               ;**	KSB - Process Keyboard Space Bar Display
00551F  1               ;*
00551F  1               ;*	ENTRY	JSR	KSB
00551F  1               ;*
00551F  1               ;*	MODS
00551F  1               ;*		M. W. Colburn	10/26/82
00551F  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00551F  1               ;*		   R. K. Nordin	11/01/83
00551F  1               
00551F  1               
00551F  1               KSB	=	*	;entry
00551F  1  A2 03        	LDX	#3	;offset to "S P A C E   B A R" text
005521  1  20 59 57     	JSR	SSM	;set screen memory
005524  1  4C DE 54     	JMP	STK8	;continue
005527  1               ;	SPACE	4,10
005527  1               ;**	KBK - Process Keyboard Backspace Key Display
005527  1               ;*
005527  1               ;*	ENTRY	JSR	KBK
005527  1               ;*
005527  1               ;*	MODS
005527  1               ;*		M. W. Colburn	10/26/82
005527  1               ;*		1. Bring closer to Coding Standard (object unchanged).
005527  1               ;*		   R. K. Nordin	11/01/83
005527  1               
005527  1               
005527  1               KBK	=	*	;entry
005527  1  A2 06        	LDX	#6	;offset to "B S" text
005529  1  20 59 57     	JSR	SSM	;set screen memory
00552C  1  4C DE 54     	JMP	STK8	;continue
00552F  1               ;	SPACE	4,10
00552F  1               ;**	KTK - Process Keyboard Tab Key Display
00552F  1               ;*
00552F  1               ;*	ENTRY	JSR	KTK
00552F  1               ;*
00552F  1               ;*	MODS
00552F  1               ;*		M. W. Colburn	10/26/82
00552F  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00552F  1               ;*		   R. K. Nordin	11/01/83
00552F  1               
00552F  1               
00552F  1               KTK	=	*	;entry
00552F  1  A9 7F        	LDA	#$7F
005531  1  8D 52 30     	STA	ST3052
005534  1  8D 53 30     	STA	ST3052+1
005537  1  D0 A5        	BNE	STK8	;continue
005539  1               ;	SPACE	4,10
005539  1               ;**	KRK - Process Keyboard Return Key Display
005539  1               ;*
005539  1               ;*	ENTRY	JSR	KRK
005539  1               ;*
005539  1               ;*	MODS
005539  1               ;*		M. W. Colburn	10/26/82
005539  1               ;*		1. Bring closer to Coding Standard (object unchanged).
005539  1               ;*		   R. K. Nordin	11/01/83
005539  1               
005539  1               
005539  1               KRK	=	*	;entry
005539  1  A9 32        	LDA	#$32
00553B  1  8D 6D 30     	STA	ST306D
00553E  1  A9 34        	LDA	#$34
005540  1  8D 6E 30     	STA	ST306D+1
005543  1  D0 99        	BNE	STK8	;continue
005545  1               ;	SPACE	4,10
005545  1               ;**	TSKP - Table of Simulated Keypresses
005545  1               
005545  1               
005545  1  52 08 0A 2B  TSKP	DB	$52,$08,$0A,$2B,$28,$0D,$3D,$39,$2D	;"Copyright"
005549  1  28 0D 3D 39  
00554D  1  2D 1F 30 35  
005557  1               	DB	$1F,$30,$35,$1A				;"1983"
005557  1               	DB	$7F,$2D,$3F,$28,$0D			;"Atari"
005557  1               
005557  1               TSKPL	=	*-TSKP	;length
005557  1               ;	SPACE	4,10
005557  1               ;**	STV - Self-test Audio-visual
005557  1               ;*
005557  1               ;*	STV verifies the operation of the display and voices by
005557  1               ;*	displaying and playing a tune.
005557  1               ;*
005557  1               ;*	ENTRY	JSR	STV
005557  1               ;*
005557  1               ;*	MODS	M. W. Colburn	10/26/82
005557  1               ;*		1. Bring closer to Coding Standard (object unchanged).
005557  1               ;*		   R. K. Nordin	11/01/83
005557  1               
005557  1               
005557  1               STV	=	*		;entry
005557  1               
005557  1               ;	Initialize.
005557  1               
005557  1  A2 02        	LDX	#2		;audio-visual test colors
005559  1  20 73 57     	JSR	SUC		;set up colors
00555C  1               
00555C  1               ;	Test audio-visual.
00555C  1               
00555C  1  A9 00        STV1	LDA	#0
00555E  1  85 97        	STA	STVOC		;initialize voice indicator
005560  1               
005560  1               ;	Test voice.
005560  1               
005560  1  A9 00        STV2	LDA	#0
005562  1  85 98        	STA	STNOT		;initialize note counter
005564  1  A2 31        	LDX	#low DISL5	;audio-visual display list
005566  1  A0 52        	LDY	#high DISL5
005568  1  A9 00        	LDA	#0		;indicate not keyboard self-test
00556A  1  20 9E 50     	JSR	SDL		;set up display list
00556D  1               
00556D  1               ;	Display voice number.
00556D  1               
00556D  1  A2 09        	LDX	#9		;offset to "VOICE #" text
00556F  1  20 59 57     	JSR	SSM		;set screen memory
005572  1  A5 97        	LDA	STVOC		;voice indicator
005574  1  4A           	LSR	A		;voice number
005575  1  18           	CLC
005576  1  69 11        	ADC	#$11		;adjust for screen memory
005578  1  8D 0B 30     	STA	ST300B		;voice number display
00557B  1               
00557B  1               ;	Display staff.
00557B  1               
00557B  1  A2 0F        	LDX	#$0F		;offset to last byte of staff lines
00557D  1               
00557D  1  A9 FF        STV3	LDA	#$FF		;color 2
00557F  1  9D 50 31     	STA	ST3150,X	;byte of first line of staff
005582  1  9D B0 31     	STA	ST31B0,X	;byte of second line of staff
005585  1  9D 10 32     	STA	ST3210,X	;byte of third line of staff
005588  1  9D 70 32     	STA	ST3270,X	;byte of fourth line of staff
00558B  1  9D D0 32     	STA	ST32D0,X	;byte of fifth line of staff
00558E  1  CA           	DEX
00558F  1  10 EC        	BPL	STV3		;if not done
005591  1               
005591  1               ;	Display cleft.
005591  1               
005591  1  A9 00        	LDA	#0		;offset to first cleft display address
005593  1  85 99        	STA	STCDI		;cleft display pointer
005595  1  A9 0C        	LDA	#2*6
005597  1  85 9A        	STA	STCDA		;cleft data pointer
005599  1               
005599  1  A6 99        STV4	LDX	STCDI		;cleft display pointer
00559B  1  BD 17 57     	LDA	TCDA+1,X	;high address of cleft display
00559E  1  A8           	TAY
00559F  1  BD 16 57     	LDA	TCDA,X		;low address of cleft display
0055A2  1  AA           	TAX
0055A3  1  A5 9A        	LDA	STCDA		;cleft data pointer
0055A5  1  20 85 56     	JSR	DVN		;display ???
0055A8  1  18           	CLC
0055A9  1  A5 9A        	LDA	STCDA		;cleft data pointer
0055AB  1  69 06        	ADC	#6
0055AD  1  85 9A        	STA	STCDA		;update cleft data pointer
0055AF  1  E6 99        	INC	STCDI		;increment cleft display pointer
0055B1  1  E6 99        	INC	STCDI
0055B3  1  A5 99        	LDA	STCDI		;cleft display pointer
0055B5  1  C9 14        	CMP	#TCDAL		;length of cleft display table
0055B7  1  D0 E0        	BNE	STV4		;if not done
0055B9  1               
0055B9  1               ;	Delay.
0055B9  1               
0055B9  1  20 B1 53     	JSR	DMW		;delay a middling while
0055BC  1               
0055BC  1               ;	Display and play first note.
0055BC  1               
0055BC  1  A2 54        	LDX	#low ST3154
0055BE  1  A0 31        	LDY	#high ST3154
0055C0  1  A9 00        	LDA	#0*6
0055C2  1  20 85 56     	JSR	DVN
0055C5  1               
0055C5  1  A9 51        	LDA	#$51		;first note frequency
0055C7  1  20 6C 56     	JSR	SVN
0055CA  1               
0055CA  1               ;	Display and play second note.
0055CA  1               
0055CA  1  A2 86        	LDX	#low ST3186
0055CC  1  A0 31        	LDY	#high ST3186
0055CE  1  A9 00        	LDA	#0*6
0055D0  1  20 85 56     	JSR	DVN
0055D3  1               
0055D3  1  A9 5B        	LDA	#$5B		;second note frequency
0055D5  1  20 6C 56     	JSR	SVN
0055D8  1               
0055D8  1               ;	Display and play third note.
0055D8  1               
0055D8  1  A2 F8        	LDX	#low ST30F8
0055DA  1  A0 30        	LDY	#high ST30F8
0055DC  1  A9 48        	LDA	#12*6
0055DE  1  20 85 56     	JSR	DVN
0055E1  1  A2 C7        	LDX	#low ST30C7
0055E3  1  A0 30        	LDY	#high ST30C7
0055E5  1  A9 54        	LDA	#14*6
0055E7  1  20 85 56     	JSR	DVN
0055EA  1  A2 48        	LDX	#low ST3248
0055EC  1  A0 32        	LDY	#high ST3248
0055EE  1  A9 4E        	LDA	#13*6
0055F0  1  20 85 56     	JSR	DVN
0055F3  1               
0055F3  1  A9 44        	LDA	#$44		;third note frequency
0055F5  1  20 6C 56     	JSR	SVN
0055F8  1               
0055F8  1               ;	Display and play fourth note.
0055F8  1               
0055F8  1  A2 CA        	LDX	#low ST30CA
0055FA  1  A0 30        	LDY	#high ST30CA
0055FC  1  A9 48        	LDA	#12*6
0055FE  1  20 85 56     	JSR	DVN
005601  1  A2 1A        	LDX	#low ST321A
005603  1  A0 32        	LDY	#high ST321A
005605  1  A9 4E        	LDA	#13*6
005607  1  20 85 56     	JSR	DVN
00560A  1  A2 CA        	LDX	#low ST31CA
00560C  1  A0 31        	LDY	#high ST31CA
00560E  1  A9 06        	LDA	#1*6
005610  1  20 85 56     	JSR	DVN
005613  1               
005613  1  A9 3C        	LDA	#$3C		;fourth note frequency
005615  1  20 6C 56     	JSR	SVN
005618  1               
005618  1               ;	Display and play fifth note.
005618  1               
005618  1  A2 3C        	LDX	#low ST303C
00561A  1  A0 30        	LDY	#high ST303C
00561C  1  A9 48        	LDA	#12*6
00561E  1  20 85 56     	JSR	DVN
005621  1  A2 8C        	LDX	#low ST318C
005623  1  A0 31        	LDY	#high ST318C
005625  1  A9 4E        	LDA	#13*6
005627  1  20 85 56     	JSR	DVN
00562A  1  A2 3C        	LDX	#low ST313C
00562C  1  A0 31        	LDY	#high ST313C
00562E  1  A9 06        	LDA	#1*6
005630  1  20 85 56     	JSR	DVN
005633  1               
005633  1  A9 2D        	LDA	#$2D		;fifth note frequency
005635  1  20 6C 56     	JSR	SVN
005638  1               
005638  1               ;	Display and play sixth note.
005638  1               
005638  1  A2 9E        	LDX	#low ST309E
00563A  1  A0 30        	LDY	#high ST309E
00563C  1  A9 48        	LDA	#12*6
00563E  1  20 85 56     	JSR	DVN
005641  1  A2 EE        	LDX	#low ST31EE
005643  1  A0 31        	LDY	#high ST31EE
005645  1  A9 4E        	LDA	#13*6
005647  1  20 85 56     	JSR	DVN
00564A  1               
00564A  1  A9 35        	LDA	#$35		;sixth note frequency
00564C  1  20 6C 56     	JSR	SVN
00564F  1               
00564F  1               ;	Delay.
00564F  1               
00564F  1  20 B5 53     	JSR	DLW		;delay a long while
005652  1               
005652  1               ;	Advance to next voice.
005652  1               
005652  1  E6 97        	INC	STVOC		;increment voice indicator
005654  1  E6 97        	INC	STVOC
005656  1  A5 97        	LDA	STVOC		;voice indicator
005658  1  C9 08        	CMP	#8		;last voice indicator
00565A  1  D0 07        	BNE	STV5		;if all voices not processed
00565C  1               
00565C  1               ;	Process test completion.
00565C  1               
00565C  1  A5 82        	LDA	STAUT		;auto-mode flag
00565E  1  D0 06        	BNE	STV6		;if auto-mode, perform keyboard test
005660  1               
005660  1  4C 5C 55     	JMP	STV1		;repeat audio-visual test
005663  1               
005663  1               ;	Test next voice.
005663  1               
005663  1  4C 60 55     STV5	JMP	STV2		;test next voice
005666  1               
005666  1               ;	Self-test keyboard.
005666  1               
005666  1  20 B5 53     STV6	JSR	DLW		;delay a long while
005669  1  4C 50 54     	JMP	STK		;self-test keyboard
00566C  1               ;	SPACE	4,10
00566C  1               ;**	SVN - Sound Tone
00566C  1               ;*
00566C  1               ;*	ENTRY	JSR	SVN
00566C  1               ;*
00566C  1               ;*	MODS
00566C  1               ;*		M. W. Colburn	10/26/82
00566C  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00566C  1               ;*		   R. K. Nordin	11/01/83
00566C  1               
00566C  1               
00566C  1               SVN	=	*		;entry
00566C  1               
00566C  1               ;	Sound note.
00566C  1               
00566C  1  A4 97        	LDY	STVOC		;current voice indicator
00566E  1  99 00 D2     	STA	AUDF1,Y		;set frequency
005671  1  A9 A8        	LDA	#$A8		;pure tone, half volume
005673  1  99 01 D2     	STA	AUDC1,Y		;set control
005676  1               
005676  1               ;	Delay a while.
005676  1               
005676  1  A6 98        	LDX	STNOT		;current note
005678  1  BD B6 56     	LDA	TNDD,X		;delay time
00567B  1  AA           	TAX
00567C  1  20 B7 53     	JSR	DAW		;delay a while
00567F  1               
00567F  1               ;	Increment note counter.
00567F  1               
00567F  1  E6 98        	INC	STNOT		;increment note counter
005681  1               
005681  1               ;	Exit.
005681  1               
005681  1  20 10 55     	JSR	SAS		;silence all sounds
005684  1  60           	RTS			;return
005685  1               ;	SPACE	4,10
005685  1               ;**	DVN - Display
005685  1               ;*
005685  1               ;*	ENTRY	JSR	DVN
005685  1               ;*
005685  1               ;*	MODS
005685  1               ;*		M. W. Colburn	10/26/82
005685  1               ;*		1. Bring closer to Coding Standard (object unchanged).
005685  1               ;*		   R. K. Nordin	11/01/83
005685  1               
005685  1               
005685  1               DVN	=	*		;entry
005685  1  86 9B        	STX	STTMP2
005687  1  84 9C        	STY	STTMP2+1
005689  1  AA           	TAX
00568A  1  A0 00        	LDY	#0
00568C  1  A9 10        	LDA	#16
00568E  1  85 9D        	STA	STTMP3
005690  1  A9 06        	LDA	#6
005692  1  85 A3        	STA	STTMP4
005694  1               
005694  1  BD BC 56     DVN1	LDA	TAVD,X
005697  1  11 9B        	ORA	(STTMP2),Y
005699  1  91 9B        	STA	(STTMP2),Y
00569B  1  20 AA 56     	JSR	AST		;add 16
00569E  1  C6 9D        	DEC	STTMP3
0056A0  1  D0 F2        	BNE	DVN1
0056A2  1               
0056A2  1  E6 9D        	INC	STTMP3
0056A4  1  E8           	INX
0056A5  1  C6 A3        	DEC	STTMP4
0056A7  1  D0 EB        	BNE	DVN1
0056A9  1               
0056A9  1  60           	RTS			;return
0056AA  1               ;	SPACE	4,10
0056AA  1               ;**	AST - Add Sixteen
0056AA  1               ;*
0056AA  1               ;*	ENTRY	JSR	AST
0056AA  1               ;*
0056AA  1               ;*	MODS
0056AA  1               ;*		M. W. Colburn	10/26/82
0056AA  1               ;*		1. Bring closer to Coding Standard (object unchanged).
0056AA  1               ;*		   R. K. Nordin	11/01/83
0056AA  1               
0056AA  1               
0056AA  1               AST	=	*		;entry
0056AA  1  18           	CLC
0056AB  1  A5 9B        	LDA	STTMP2		;current low value
0056AD  1  69 10        	ADC	#16		;add 16
0056AF  1  85 9B        	STA	STTMP2		;new low value
0056B1  1  90 02        	BCC	AST1		;if no carry
0056B3  1               
0056B3  1  E6 9C        	INC	STTMP2+1	;adjust high value
0056B5  1               
0056B5  1  60           AST1	RTS			;return
0056B6  1               ;	SPACE	4,10
0056B6  1               ;**	TNDD - Table of Note Duration Delays
0056B6  1               
0056B6  1               
0056B6  1  20 20 20 10  TNDD	DB	32	;0 - first note
0056BA  1  10 20        
0056BC  1               	DB	32	;1 - second note
0056BC  1               	DB	32	;2 - third note
0056BC  1               	DB	16	;3 - fourth note
0056BC  1               	DB	16	;4 - fifth note
0056BC  1               	DB	32	;5 - sixth note
0056BC  1               ;	SPACE	4,10
0056BC  1               ;**	TAVD - Table of Audio-visual Test Display Data
0056BC  1               
0056BC  1               
0056BC  1  01 1F 3F 7F  TAVD	DB	$01,$1F,$3F,$7F,$3E,$1C		;0
0056C0  1  3E 1C 00 41  
0056C4  1  42 4C 70 40  
005716  1               	DB	$00,$41,$42,$4C,$70,$40		;1
005716  1               	DB	$00,$01,$02,$04,$08,$10		;2
005716  1               	DB	$00,$43,$44,$48,$48,$48		;3
005716  1               	DB	$00,$44,$22,$10,$08,$07		;4
005716  1               	DB	$00,$04,$08,$05,$02,$00		;5
005716  1               	DB	$00,$30,$48,$88,$84,$84		;6
005716  1               	DB	$00,$88,$88,$90,$A0,$C0		;7
005716  1               	DB	$00,$F0,$88,$84,$82,$82		;8
005716  1               	DB	$00,$82,$82,$84,$88,$F0		;9
005716  1               	DB	$00,$00,$00,$00,$00,$80		;10
005716  1               	DB	$80,$80,$80,$80,$80,$80		;11
005716  1               	DB	$00,$1C,$3E,$7F,$7E,$7C		;12
005716  1               	DB	$40,$00,$00,$00,$00,$00		;13
005716  1               	DB	$00,$04,$04,$06,$05,$06		;14
005716  1               ;	SPACE	4,10
005716  1               ;**	TCDA - Table of Cleft Display Addresses
005716  1               
005716  1               
005716  1  C1 30 21 31  TCDA	DW	ST30C1	;0
00571A  1  81 31 F1 31  
00571E  1  02 30 62 30  
00572A  1               	DW	ST3121	;1
00572A  1               	DW	ST3181	;2
00572A  1               	DW	ST31F1	;3
00572A  1               	DW	ST3002	;4
00572A  1               	DW	ST3062	;5
00572A  1               	DW	ST3122	;6
00572A  1               	DW	ST3182	;7
00572A  1               	DW	ST30C2	;8
00572A  1               	DW	ST31C2	;9
00572A  1               
00572A  1               TCDAL	=	*-TCDA		;length
00572A  1               ;	SPACE	4,10
00572A  1               ;**	SVR - Set Value in Range
00572A  1               ;*
00572A  1               ;*	ENTRY	JSR	SVR
00572A  1               ;*		A = value to set
00572A  1               ;*		X = offset to TARS range
00572A  1               ;*
00572A  1               ;*	EXIT
00572A  1               ;*		A = value set
00572A  1               ;*
00572A  1               ;*	MODS
00572A  1               ;*		M. W. Colburn	10/26/82
00572A  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00572A  1               ;*		   R. K. Nordin	11/01/83
00572A  1               
00572A  1               
00572A  1               SVR	=	*		;entry
00572A  1               
00572A  1               ;	Initialize.
00572A  1               
00572A  1  48           	PHA			;save value
00572B  1               
00572B  1               ;	Set address range.
00572B  1               
00572B  1  BD DC 57     	LDA	TARS,X		;start of range
00572E  1  85 9E        	STA	STADR1
005730  1  BD DD 57     	LDA	TARS+1,X
005733  1  85 9F        	STA	STADR1+1
005735  1  BD DE 57     	LDA	TARS+2,X	;end of range
005738  1  85 A0        	STA	STADR2
00573A  1  BD DF 57     	LDA	TARS+3,X
00573D  1  85 A1        	STA	STADR2+1
00573F  1               
00573F  1               ;	Set value in range.
00573F  1               
00573F  1  A0 00        	LDY	#0		;offset to first byte
005741  1               
005741  1  68           SVR1	PLA			;saved value
005742  1  91 9E        	STA	(STADR1),Y	;byte of range
005744  1  E6 9E        	INC	STADR1		;increment low address
005746  1  D0 02        	BNE	SVR2		;if no carry
005748  1               
005748  1  E6 9F        	INC	STADR1+1	;adjust high address
00574A  1               
00574A  1  48           SVR2	PHA			;save value
00574B  1  A5 9E        	LDA	STADR1		;low current address
00574D  1  C5 A0        	CMP	STADR2		;low end of range
00574F  1  D0 F0        	BNE	SVR1		;if definitely not done
005751  1               
005751  1  A5 9F        	LDA	STADR1+1	;high current address
005753  1  C5 A1        	CMP	STADR2+1	;high end of range
005755  1  D0 EA        	BNE	SVR1		;if not done
005757  1               
005757  1               ;	Exit.
005757  1               
005757  1  68           	PLA			;restore value
005758  1  60           	RTS			;return
005759  1               ;	SPACE	4,10
005759  1               ;**	SSM - Set Screen Memory
005759  1               ;*
005759  1               ;*	ENTRY	JSR	SSM
005759  1               ;*
005759  1               ;*	MODS
005759  1               ;*		M. W. Colburn	10/26/82
005759  1               ;*		1. Bring closer to Coding Standard (object unchanged).
005759  1               ;*		   R. K. Nordin	11/01/83
005759  1               
005759  1               
005759  1               SSM	=	*		;entry
005759  1  BD 57 CA     	LDA	TSTO,X		;offset to source
00575C  1  A8           	TAY
00575D  1  BD EC 57     	LDA	TSTL,X		;length of source
005760  1  85 9E        	STA	STADR1		;length
005762  1  BD F6 57     	LDA	TSTD,X		;offset to destination
005765  1  AA           	TAX
005766  1               
005766  1  B9 61 CA     SSM1	LDA	TTXT,Y		;byte of source
005769  1  9D 00 30     	STA	ST3000,X	;byte of destination
00576C  1  C8           	INY
00576D  1  E8           	INX
00576E  1  C6 9E        	DEC	STADR1		;decrement length
005770  1  D0 F4        	BNE	SSM1		;if not done
005772  1               
005772  1  60           	RTS			;return
005773  1               ;	SPACE	4,10
005773  1               ;**	SUC - Set Up Colors
005773  1               ;*
005773  1               ;*	ENTRY	JSR	SUC
005773  1               ;*		X = 0, if main screen colors
005773  1               ;*		  = 1, if memory test colors
005773  1               ;*		  = 2, if keyboard test colors
005773  1               ;*		  = 3, if audio-visual test colors
005773  1               ;*
005773  1               ;*	EXIT
005773  1               ;*		COLOR0, COLOR1, COLOR2 and COLOR4 set.
005773  1               ;*
005773  1               ;*	CHANGES
005773  1               ;*		A
005773  1               ;*
005773  1               ;*	CALLS
005773  1               ;*		-none-
005773  1               ;*
005773  1               ;*	MODS
005773  1               ;*		M. W. Colburn	10/26/82
005773  1               ;*		1. Bring closer to Coding Standard (object unchanged).
005773  1               ;*		   R. K. Nordin	11/01/83
005773  1               
005773  1               
005773  1               SUC	=	*		;entry
005773  1               
005773  1  BD 8C 57     	LDA	SUCA,X
005776  1  8D C4 02     	STA	COLOR0	;playfield 0 color
005779  1               
005779  1  BD 90 57     	LDA	SUCB,X
00577C  1  8D C5 02     	STA	COLOR1	;playfield 1 color
00577F  1               
00577F  1  BD 94 57     	LDA	SUCC,X
005782  1  8D C6 02     	STA	COLOR2	;playfield 2 color
005785  1               
005785  1  BD 98 57     	LDA	SUCD,X
005788  1  8D C8 02     	STA	COLOR4	;background color
00578B  1               
00578B  1  60           	RTS		;return
00578C  1               
00578C  1               
00578C  1  2C 0C 2A 18  SUCA	DB	$2C	;0 - main screen playfield 0 color
005790  1               	DB	$0C	;1 - memory test playfield 0 color
005790  1               	DB	$2A	;2 - keyboard test playfield 0 color
005790  1               	DB	$18	;3 - audio-visual test playfield 0 color
005790  1               
005790  1  0F 32 0C 0E  SUCB	DB	$0F	;0 - main screen playfield 1 color
005794  1               	DB	$32	;1 - memory test playfield 1 color
005794  1               	DB	$0C	;2 - keyboard test playfield 1 color
005794  1               	DB	$0E	;3 - audio-visual test playfield 1 color
005794  1               
005794  1  D2 D6 00 B4  SUCC	DB	$D2	;0 - main screen playfield 2 color
005798  1               	DB	$D6	;1 - memory test playfield 2 color
005798  1               	DB	$00	;2 - keyboard test playfield 2 color
005798  1               	DB	$B4	;3 - audio-visual test playfield 2 color
005798  1               
005798  1  D2 A0 30 B4  SUCD	DB	$D2	;0 - main screen background color
00579C  1               	DB	$A0	;1 - memory test background color
00579C  1               	DB	$30	;2 - keyboard test background color
00579C  1               	DB	$B4	;3 - audio-visual test background color
00579C  1               ;	SPACE	4,10
00579C  1               ;**	TSMC - Table of Screen Memory Character Codes
00579C  1               ;*
00579C  1               ;*	Entry n is the screen memory character code for key code n.
00579C  1               
00579C  1               
00579C  1  2C 2A 1B 91  TSMC	DB	$2C	;$00 - L key
0057A0  1  92 2B 0B 0A  
0057A4  1  2F 00 30 35  
0057AC  1               	DB	$2A	;$01 - J key
0057AC  1               	DB	$1B	;$02 - semicolon key
0057AC  1               	DB	$91	;$03
0057AC  1               	DB	$92	;$04
0057AC  1               	DB	$2B	;$05 - K key
0057AC  1               	DB	$0B	;$06 - plus key
0057AC  1               	DB	$0A	;$07 - asterisk key
0057AC  1               	DB	$2F	;$08 - O key
0057AC  1               	DB	$00	;$09
0057AC  1               	DB	$30	;$0A - P key
0057AC  1               	DB	$35	;$0B - U key
0057AC  1               	DB	$B2	;$0C - RETURN key
0057AC  1               	DB	$29	;$0D - I key
0057AC  1               	DB	$0D	;$0E - minus key
0057AC  1               	DB	$1D	;$0F - = key
0057AC  1               
0057AC  1  36 A8 23 93  	DB	$36	;$10 - V key
0057B0  1  94 22 38 3A  
0057B4  1  14 00 13 16  
0057BC  1               	DB	$A8	;$11
0057BC  1               	DB	$23	;$12 - C key
0057BC  1               	DB	$93	;$13
0057BC  1               	DB	$94	;$14
0057BC  1               	DB	$22	;$15 - B key
0057BC  1               	DB	$38	;$16 - X key
0057BC  1               	DB	$3A	;$17 - Z key
0057BC  1               	DB	$14	;$18 - 4 key
0057BC  1               	DB	$00	;$19
0057BC  1               	DB	$13	;$1A - 3 key
0057BC  1               	DB	$16	;$1B - 6 key
0057BC  1               	DB	$5B	;$1C - ESC key
0057BC  1               	DB	$15	;$1D - 5 key
0057BC  1               	DB	$12	;$1E - 2 key
0057BC  1               	DB	$11	;$1F - 1 key
0057BC  1               
0057BC  1  0C 00 0E 2E  	DB	$0C	;$20 - comma key
0057C0  1  00 2D 0F A1  
0057C4  1  32 00 25 39  
0057CC  1               	DB	$00	;$21 - space key
0057CC  1               	DB	$0E	;$22 - period key
0057CC  1               	DB	$2E	;$23 - N key
0057CC  1               	DB	$00	;$24
0057CC  1               	DB	$2D	;$25 - M key
0057CC  1               	DB	$0F	;$26 - / key
0057CC  1               	DB	$A1	;$27 - inverse video key
0057CC  1               	DB	$32	;$28 - R key
0057CC  1               	DB	$00	;$29
0057CC  1               	DB	$25	;$2A - E key
0057CC  1               	DB	$39	;$2B - Y key
0057CC  1               	DB	$FF	;$2C - TAB key
0057CC  1               	DB	$34	;$2D - T key
0057CC  1               	DB	$37	;$2E - W key
0057CC  1               	DB	$31	;$2F - Q key
0057CC  1               
0057CC  1  19 00 10 17  	DB	$19	;$30 - 9 key
0057D0  1  A2 18 1C 1E  
0057D4  1  26 28 24 00  
0057DC  1               	DB	$00	;$31
0057DC  1               	DB	$10	;$32 - 0 key
0057DC  1               	DB	$17	;$33 - 7 key
0057DC  1               	DB	$A2	;$34 - backspace key
0057DC  1               	DB	$18	;$35 - 8 key
0057DC  1               	DB	$1C	;$36 - < key
0057DC  1               	DB	$1E	;$37 - > key
0057DC  1               	DB	$26	;$38 - F key
0057DC  1               	DB	$28	;$39 - H key
0057DC  1               	DB	$24	;$3A - D key
0057DC  1               	DB	$00	;$3B
0057DC  1               	DB	$A3	;$3C - CAPS key
0057DC  1               	DB	$27	;$3D - G key
0057DC  1               	DB	$33	;$3E - S key
0057DC  1               	DB	$21	;$3F - A key
0057DC  1               ;	SPACE	4,10
0057DC  1               ;**	TARS - Table of Address Ranges to Set
0057DC  1               
0057DC  1               
0057DC  1  00 30 FF 3E  TARS	DW	ST3000,ST3000+$0EFF	;0 - screen memory
0057E0  1  20 30 24 30  
0057E4  1  24 30 28 30  
0057EC  1               	DW	ST3020,ST3020+4		;1 - memory test first 8K ROM
0057EC  1               	DW	ST3024,ST3024+4		;2 - memory test second 8K ROM
0057EC  1               	DW	ST3000,ST3000+32	;3 - main screen bold lines
0057EC  1               ;	SPACE	4,10
0057EC  1               ;**	TSTL - Table of Self-test Text Lengths
0057EC  1               
0057EC  1               
0057EC  1  13 03 13 13  TSTL	DB	TXT0L	;0 - length of "MEMORY TEST   ROM" text
0057F0  1  04 04 03 A8  
0057F4  1  03 07        
0057F6  1               	DB	TXT1L	;1 - length of "RAM" text
0057F6  1               	DB	TXT2L	;2 - length of "KEYBOARD TEST" text
0057F6  1               	DB	TXT3L	;3 - length of "S P A C E   B A R" text
0057F6  1               	DB	TXT4L	;4 - length of "SH" text
0057F6  1               	DB	TXT5L	;5 - length of "SH" text
0057F6  1               	DB	TXT6L	;6 - length of "B S" text
0057F6  1               	DB	TXT7L	;7 - length of keyboard text
0057F6  1               	DB	TXT8L	;8 - length of control key text
0057F6  1               	DB	TXT9L	;9 - length of "VOICE #" text
0057F6  1               ;	SPACE	4,10
0057F6  1               ;**	TSTD - Table of Self-test Text Destination Offsets
0057F6  1               
0057F6  1               
0057F6  1  00 28 00 B7  TSTD	DB	ST3000-ST3000	;0 - offset to "MEMORY TEST   ROM" text
0057FA  1  92 AB 4C 22  
0057FE  1  72 04        
005800  1               	DB	ST3028-ST3000	;1 - offset to "RAM" text
005800  1               	DB	ST3000-ST3000	;2 - offset to "KEYBOARD TEST" text
005800  1               	DB	ST30B7-ST3000	;3 - offset to "S P A C E   B A R" text
005800  1               	DB	ST3092-ST3000	;4 - offset to "SH" text
005800  1               	DB	ST30AB-ST3000	;5 - offset to "SH" text
005800  1               	DB	ST304C-ST3000	;6 - offset to "B S" text
005800  1               	DB	ST3022-ST3000	;7 - offset to keyboard text
005800  1               	DB	ST3072-ST3000	;8 - offset to control key text
005800  1               	DB	ST3004-ST3000	;9 - offset to "VOICE #" text
005800  1               ;	SUBTTL	'Floating Point Package'
005800  1               ;	SPACE	4,10
005800  1               ;***	(C) Copyright 1978 Shepardson Microsystems, Inc.
005800  1               ;	SPACE	4,10
005800  1               	FIX	$5800
00D800  1               	ORG	$D800
00D800  1               ;	SPACE	4,10
00D800  1               ;***	FPP - Floating Point Package
00D800  1               ;*
00D800  1               ;*	FPP is a collection of routines for floating point
00D800  1               ;*	computations.  A floating point number is represented
00D800  1               ;*	in 6 bytes:
00D800  1               ;*
00D800  1               ;*	Byte 0
00D800  1               ;*		Bit 7		Sign of mantissa
00D800  1               ;*		Bits 0 - 6	BCD exponent, biased by $40
00D800  1               ;*
00D800  1               ;*	Bytes 1 - 5		BCD mantissa
00D800  1               ;*
00D800  1               ;*	MODS
00D800  1               ;*		Shepardson Microsystems
00D800  1               ;*
00D800  1               ;*		Produce 2K version.
00D800  1               ;*		M. Lorenzen	09/06/81
00D800  1               ;	SPACE	4,10
00D800  1               	FIX	AFP
00D800  1               ;	SPACE	4,10
00D800  1               ;**	AFP - Convert ASCII to Floating Point
00D800  1               ;*
00D800  1               ;*	ENTRY	JSR	AFP
00D800  1               ;*		INBUFF = line buffer pointer
00D800  1               ;*		CIX = offset to first byte of number
00D800  1               ;*
00D800  1               ;*	EXIT
00D800  1               ;*		C clear, if valid number
00D800  1               ;*		C set, if invalid number
00D800  1               ;*
00D800  1               ;*	NOTES
00D800  1               ;*		Problem: bytes wasted by check for "-", near AFP7.
00D800  1               ;*
00D800  1               ;*	MODS
00D800  1               ;*		Original Author Unknown
00D800  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00D800  1               ;*		   R. K. Nordin	11/01/83
00D800  1               
00D800  1               
00D800  1               ;AFP	=	*		;entry
00D800  1               
00D800  1               ;	Initialize.
00D800  1               
00D800  1  20 A1 DB     	JSR	SLB	;skip leading blanks
00D803  1               
00D803  1               ;	Check for number.
00D803  1               
00D803  1  20 BB DB     	JSR	TVN	;test for valid number character
00D806  1  B0 39        	BCS	AFP5	;if not number character
00D808  1               
00D808  1               ;	Set initial values.
00D808  1               
00D808  1  A2 ED        	LDX	#EEXP	;exponent
00D80A  1  A0 04        	LDY	#4	;indicate 4 bytes to clear
00D80C  1  20 48 DA     	JSR	ZXLY
00D80F  1  A2 FF        	LDX	#$FF
00D811  1  86 F1        	STX	DIGRT	;number of digits after decimal point
00D813  1  20 44 DA     	JSR	ZFR0	;zero FR0
00D816  1  F0 04        	BEQ	AFP2	;get first character
00D818  1               
00D818  1               ;	Indicate not first character.
00D818  1               
00D818  1  A9 FF        AFP1	LDA	#$FF	;indicate not first character
00D81A  1  85 F0        	STA	FCHFLG	;first character flag
00D81C  1               
00D81C  1               ;	Get next character.
00D81C  1               
00D81C  1  20 94 DB     AFP2	JSR	GNC	;get next character
00D81F  1  B0 21        	BCS	AFP6	;if character not numeric
00D821  1               
00D821  1               ;	Process numeric character.
00D821  1               
00D821  1  48           	PHA			;save digit
00D822  1  A6 D5        	LDX	FR0M		;first byte
00D824  1  D0 11        	BNE	AFP3		;if not zero
00D826  1               
00D826  1  20 EB DB     	JSR	S0L		;shift FR0 left 1 digit
00D829  1  68           	PLA			;saved digit
00D82A  1  05 D9        	ORA	FR0M+FMPREC-1	;insert into last byte
00D82C  1  85 D9        	STA	FR0M+FMPREC-1	;update last byte
00D82E  1               
00D82E  1               ;	Check for decimal point.
00D82E  1               
00D82E  1  A6 F1        	LDX	DIGRT	;number of digits after decimal point
00D830  1  30 E6        	BMI	AFP1	;if no decimal point, process next character
00D832  1               
00D832  1               ;	Increment number of digits after decimal point.
00D832  1               
00D832  1  E8           	INX		;increment number of digits
00D833  1  86 F1        	STX	DIGRT	;number of digits after decimal point
00D835  1  D0 E1        	BNE	AFP1	;process next character
00D837  1               
00D837  1               ;	Increment exponent, if necessary.
00D837  1               
00D837  1  68           AFP3	PLA		;clean stack
00D838  1  A6 F1        	LDX	DIGRT	;number of digits after decimal point
00D83A  1  10 02        	BPL	AFP4	;if already have decimal point
00D83C  1               
00D83C  1  E6 ED        	INC	EEXP	;increment number of digits more than 9
00D83E  1               
00D83E  1               ;	Process next character.
00D83E  1               
00D83E  1  4C 18 D8     AFP4	JMP	AFP1	;process next character
00D841  1               
00D841  1               ;	Exit.
00D841  1               
00D841  1  60           AFP5	RTS		;return
00D842  1               
00D842  1               ;	Process non-numeric character.
00D842  1               
00D842  1  C9 2E        AFP6	CMP	#'.'
00D844  1  F0 14        	BEQ	AFP8	;if ".", process decimal point
00D846  1               
00D846  1  C9 45        	CMP	#'E'
00D848  1  F0 19        	BEQ	AFP9	;if "E", process exponent
00D84A  1               
00D84A  1  A6 F0        	LDX	FCHFLG	;first character flag
00D84C  1  D0 68        	BNE	AFP16	;if not first character, process end of input
00D84E  1               
00D84E  1  C9 2B        	CMP	#'+'
00D850  1  F0 C6        	BEQ	AFP1	;if "+", process next character
00D852  1               
00D852  1  C9 2D        	CMP	#'-'
00D854  1  F0 00        	BEQ	AFP7	;if "-", process negative sign
00D856  1               
00D856  1               ;	Process negative sign.
00D856  1               
00D856  1  85 EE        AFP7	STA	NSIGN	;sign of number
00D858  1  F0 BE        	BEQ	AFP1	;process next character
00D85A  1               
00D85A  1               ;	Process decimal point.
00D85A  1               
00D85A  1  A6 F1        AFP8	LDX	DIGRT	;number of digits after decimal point
00D85C  1  10 58        	BPL	AFP16	;if already have decimal point
00D85E  1               
00D85E  1  E8           	INX		;zero
00D85F  1  86 F1        	STX	DIGRT	;number of digits after decimal point
00D861  1  F0 B5        	BEQ	AFP1	;process next character
00D863  1               
00D863  1               ;	Process exponent.
00D863  1               
00D863  1  A5 F2        AFP9	LDA	CIX	;offset to character
00D865  1  85 EC        	STA	FRX	;save offset to character
00D867  1  20 94 DB     	JSR	GNC	;get next character
00D86A  1  B0 37        	BCS	AFP13	;if not numeric
00D86C  1               
00D86C  1               ;	Process numeric character in exponent.
00D86C  1               
00D86C  1  AA           AFP10	TAX		;first character of exponent
00D86D  1  A5 ED        	LDA	EEXP	;number of digits more than 9
00D86F  1  48           	PHA		;save number of digits more than 9
00D870  1  86 ED        	STX	EEXP	;first character of exponent
00D872  1               
00D872  1               ;	Process second character of exponent.
00D872  1               
00D872  1  20 94 DB     	JSR	GNC	;get next character
00D875  1  B0 17        	BCS	AFP11	;if not numeric, no second digit
00D877  1               
00D877  1  48           	PHA		;save second digit
00D878  1  A5 ED        	LDA	EEXP	;first digit
00D87A  1  0A           	ASL	A	;2 times first digit
00D87B  1  85 ED        	STA	EEXP	;2 times first digit
00D87D  1  0A           	ASL	A	;4 times first digit
00D87E  1  0A           	ASL	A	;8 times first digit
00D87F  1  65 ED        	ADC	EEXP	;add 2 times first digit
00D881  1  85 ED        	STA	EEXP	;save 10 times first digit
00D883  1  68           	PLA		;saved second digit
00D884  1  18           	CLC
00D885  1  65 ED        	ADC	EEXP	;insert in exponent
00D887  1  85 ED        	STA	EEXP	;update exponent
00D889  1               
00D889  1               ;	Process third character of exponent???
00D889  1               
00D889  1  A4 F2        	LDY	CIX	;offset to third character
00D88B  1  20 9D DB     	JSR	ICX	;increment offset
00D88E  1               
00D88E  1  A5 EF        AFP11	LDA	ESIGN	;sign of exponent
00D890  1  F0 09        	BEQ	AFP12	;if no sign on exponent
00D892  1               
00D892  1               ;	Process negative exponent.
00D892  1               
00D892  1  A5 ED        	LDA	EEXP	;exponent
00D894  1  49 FF        	EOR	#$FF	;complement exponent
00D896  1  18           	CLC
00D897  1  69 01        	ADC	#1	;add 1 for 2's complement
00D899  1  85 ED        	STA	EEXP	;update exponent
00D89B  1               
00D89B  1               ;	Add in number of digits more than 9.
00D89B  1               
00D89B  1  68           AFP12	PLA		;saved number of digits more than 9
00D89C  1  18           	CLC
00D89D  1  65 ED        	ADC	EEXP	;add exponent
00D89F  1  85 ED        	STA	EEXP	;update exponent
00D8A1  1  D0 13        	BNE	AFP16	;process end of input
00D8A3  1               
00D8A3  1               ;	Process non-numeric in exponent.
00D8A3  1               
00D8A3  1  C9 2B        AFP13	CMP	#'+'
00D8A5  1  F0 06        	BEQ	AFP14	;if "+", process next character
00D8A7  1               
00D8A7  1  C9 2D        	CMP	#'-'
00D8A9  1  D0 07        	BNE	AFP15	;if not "-", ???
00D8AB  1               
00D8AB  1  85 EF        	STA	ESIGN	;save sign of exponent
00D8AD  1               
00D8AD  1               ;	Process next character.
00D8AD  1               
00D8AD  1  20 94 DB     AFP14	JSR	GNC	;get next character
00D8B0  1  90 BA        	BCC	AFP10	;if numeric, process numeric character
00D8B2  1               
00D8B2  1               ;	Process other non-numeric in exponent.
00D8B2  1               
00D8B2  1  A5 EC        AFP15	LDA	FRX	;saved offset
00D8B4  1  85 F2        	STA	CIX	;restore offset
00D8B6  1               
00D8B6  1               ;	Process end of input.
00D8B6  1               
00D8B6  1  C6 F2        AFP16	DEC	CIX	;decrement offset
00D8B8  1  A5 ED        	LDA	EEXP	;exponent
00D8BA  1  A6 F1        	LDX	DIGRT	;number of digits after decimal point
00D8BC  1  30 05        	BMI	AFP17	;if no decimal point
00D8BE  1               
00D8BE  1  F0 03        	BEQ	AFP17	;if no digits after decimal point
00D8C0  1               
00D8C0  1  38           	SEC
00D8C1  1  E5 F1        	SBC	DIGRT	;subtract number of digits after decimal point
00D8C3  1               
00D8C3  1  48           AFP17	PHA		;save adjusted exponent
00D8C4  1  2A           	ROL	A	;set C with sign of exponent
00D8C5  1  68           	PLA		;saved adjusted exponent
00D8C6  1  6A           	ROR	A	;shift right
00D8C7  1  85 ED        	STA	EEXP	;save power of 100
00D8C9  1  90 03        	BCC	AFP18	;if no carry, process even number
00D8CB  1               
00D8CB  1  20 EB DB     	JSR	S0L	;shift FR0 left 1 digit
00D8CE  1               
00D8CE  1  A5 ED        AFP18	LDA	EEXP	;exponent
00D8D0  1  18           	CLC
00D8D1  1  69 44        	ADC	#$40+4	;add bias plus 4 for normalization
00D8D3  1  85 D4        	STA	FR0	;save exponent
00D8D5  1               
00D8D5  1  20 00 DC     	JSR	NORM	;normalize number
00D8D8  1  B0 0B        	BCS	AFP20	;if error
00D8DA  1               
00D8DA  1               ;	Check sign of number.
00D8DA  1               
00D8DA  1  A6 EE        	LDX	NSIGN	;sign of number
00D8DC  1  F0 06        	BEQ	AFP19	;if sign of number not negative
00D8DE  1               
00D8DE  1               ;	Process negative number.
00D8DE  1               
00D8DE  1  A5 D4        	LDA	FR0	;first byte of mantissa
00D8E0  1  09 80        	ORA	#$80	;indicate negative
00D8E2  1  85 D4        	STA	FR0	;update first byte of mantissa
00D8E4  1               
00D8E4  1               ;	Exit.
00D8E4  1               
00D8E4  1  18           AFP19	CLC		;indicate valid number
00D8E5  1               
00D8E5  1  60           AFP20	RTS		;return
00D8E6  1               ;	SPACE	4,10
00D8E6  1               	FIX	FASC
00D8E6  1               ;	SPACE	4,10
00D8E6  1               ;**	FASC - Convert Floating Point Number to ASCII
00D8E6  1               ;*
00D8E6  1               ;*	ENTRY	JSR	FASC
00D8E6  1               ;*		FR0 - FR0+5 = number to convert
00D8E6  1               ;*
00D8E6  1               ;*	EXIT
00D8E6  1               ;*		INBUFF = pointer to start of number
00D8E6  1               ;*		High order bit of last charecter set
00D8E6  1               ;*
00D8E6  1               ;*	MODS
00D8E6  1               ;*		Original Author Unknown
00D8E6  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00D8E6  1               ;*		   R. K. Nordin	11/01/83
00D8E6  1               
00D8E6  1               
00D8E6  1               ;FASC	=	*	;entry
00D8E6  1               
00D8E6  1               ;	Initialize.
00D8E6  1               
00D8E6  1  20 51 DA     	JSR	ILP	;initialize line buffer pointer
00D8E9  1  A9 30        	LDA	#'0'
00D8EB  1  8D 7F 05     	STA	LBPR2	;put "0" in front of line buffer
00D8EE  1               
00D8EE  1               ;	Check for E format required.
00D8EE  1               
00D8EE  1  A5 D4        	LDA	FR0	;exponent
00D8F0  1  F0 28        	BEQ	FASC2	;if exponent zero, number zero
00D8F2  1               
00D8F2  1  29 7F        	AND	#$7F	;clear sign
00D8F4  1  C9 3F        	CMP	#$40-1	;bias-1
00D8F6  1  90 28        	BCC	FASC3	;if exponent < bias-1, E format required
00D8F8  1               
00D8F8  1  C9 45        	CMP	#$40+5	;bias+5
00D8FA  1  B0 24        	BCS	FASC3	;if >= bias+5, E format required
00D8FC  1               
00D8FC  1               ;	Process E format not required.
00D8FC  1               
00D8FC  1  38           	SEC
00D8FD  1  E9 3F        	SBC	#$40-1	;subtract bias-1, yielding decimal position
00D8FF  1  20 70 DC     	JSR	C0A	;convert FR0 to ASCII
00D902  1  20 A4 DC     	JSR	FNZ	;find last non-zero character
00D905  1  09 80        	ORA	#$80	;set high order bit
00D907  1  9D 80 05     	STA	LBUFF,X	;update last character
00D90A  1  AD 80 05     	LDA	LBUFF	;first character
00D90D  1  C9 2E        	CMP	#'.'
00D90F  1  F0 03        	BEQ	FASC1	;if decimal point
00D911  1               
00D911  1  4C 88 D9     	JMP	FASC10
00D914  1               
00D914  1  20 C1 DC     FASC1	JSR	DLP	;decrement line buffer pointer
00D917  1  4C 9C D9     	JMP	FASC11	;perform final adjustment
00D91A  1               
00D91A  1               ;	Process zero.
00D91A  1               
00D91A  1  A9 B0        FASC2	LDA	#$80+'0'	;"0" with high order bit set
00D91C  1  8D 80 05     	STA	LBUFF		;put zero character in line buffer
00D91F  1  60           	RTS			;return
00D920  1               
00D920  1               ;	Process E format required.
00D920  1               
00D920  1  A9 01        FASC3	LDA	#1	;GET DECIMAL POSITION???
00D922  1  20 70 DC     	JSR	C0A	;convert FR0 to ASCII
00D925  1  20 A4 DC     	JSR	FNZ	;find last non-zero character
00D928  1  E8           	INX		;increment offset to last character
00D929  1  86 F2        	STX	CIX	;save offset to last character
00D92B  1               
00D92B  1               ;	Adjust exponent.
00D92B  1               
00D92B  1  A5 D4        	LDA	FR0	;exponent
00D92D  1  0A           	ASL	A	;double exponent
00D92E  1  38           	SEC
00D92F  1  E9 80        	SBC	#$40*2	;subtract 2 times bias
00D931  1               
00D931  1               ;	Check first character for "0".
00D931  1               
00D931  1  AE 80 05     	LDX	LBUFF	;first character
00D934  1  E0 30        	CPX	#'0'
00D936  1  F0 17        	BEQ	FASC5	;if "0"
00D938  1               
00D938  1               ;	Put decimal after first character.
00D938  1               
00D938  1  AE 81 05     	LDX	LBUFF+1	;second character
00D93B  1  AC 82 05     	LDY	LBUFF+2	;decimal point
00D93E  1  8E 82 05     	STX	LBUFF+2	;decimal point
00D941  1  8C 81 05     	STY	LBUFF+1	;third character
00D944  1  A6 F2        	LDX	CIX	;offset
00D946  1  E0 02        	CPX	#2	;former offset to decimal point
00D948  1  D0 02        	BNE	FASC4	;if offset pointed to second character
00D94A  1               
00D94A  1  E6 F2        	INC	CIX	;increment offset
00D94C  1               
00D94C  1  18           FASC4	CLC
00D94D  1  69 01        	ADC	#1	;adjust exponent for movement of decimal point
00D94F  1               
00D94F  1               ;	Convert exponent to ASCII.
00D94F  1               
00D94F  1  85 ED        FASC5	STA	EEXP	;exponent
00D951  1  A9 45        	LDA	#'E'
00D953  1  A4 F2        	LDY	CIX	;offset
00D955  1  20 9F DC     	JSR	SAL	;store ASCII character in line buffer
00D958  1  84 F2        	STY	CIX	;save offset
00D95A  1  A5 ED        	LDA	EEXP	;exponent
00D95C  1  10 0B        	BPL	FASC6	;if exponent positive
00D95E  1               
00D95E  1  A9 00        	LDA	#0
00D960  1  38           	SEC
00D961  1  E5 ED        	SBC	EEXP	;complement exponent
00D963  1  85 ED        	STA	EEXP	;update exponent
00D965  1  A9 2D        	LDA	#'-'
00D967  1  D0 02        	BNE	FASC7	;store "-"
00D969  1               
00D969  1  A9 2B        FASC6	LDA	#'+'
00D96B  1               
00D96B  1  20 9F DC     FASC7	JSR	SAL	;store ASCII character in line buffer
00D96E  1  A2 00        	LDX	#0	;initial number of 10's
00D970  1  A5 ED        	LDA	EEXP	;exponent
00D972  1               
00D972  1  38           FASC8	SEC
00D973  1  E9 0A        	SBC	#10	;subtract 10
00D975  1  90 03        	BCC	FASC9	;if < 0, done
00D977  1               
00D977  1  E8           	INX		;increment number of 10's
00D978  1  D0 F8        	BNE	FASC8	;continue
00D97A  1               
00D97A  1  18           FASC9	CLC
00D97B  1  69 0A        	ADC	#10	;add back 10
00D97D  1  48           	PHA		;save remainder
00D97E  1  8A           	TXA		;number of 10's
00D97F  1  20 9D DC     	JSR	SNL	;store number in line buffer
00D982  1  68           	PLA		;saved remainder
00D983  1  09 80        	ORA	#$80	;set high order bit
00D985  1  20 9D DC     	JSR	SNL	;store number in line buffer
00D988  1               
00D988  1               ;	Perform final adjustment.
00D988  1               
00D988  1  AD 80 05     FASC10	LDA	LBUFF	;first character
00D98B  1  C9 30        	CMP	#'0'
00D98D  1  D0 0D        	BNE	FASC11	;if not "0", ???
00D98F  1               
00D98F  1               ;	Increment pointer to point to non-zero character.
00D98F  1               
00D98F  1  18           	CLC
00D990  1  A5 F3        	LDA	INBUFF		;line buffer pointer
00D992  1  69 01        	ADC	#1		;add 1
00D994  1  85 F3        	STA	INBUFF		;update line buffer pointer
00D996  1  A5 F4        	LDA	INBUFF+1
00D998  1  69 00        	ADC	#0
00D99A  1  85 F4        	STA	INBUFF+1
00D99C  1               
00D99C  1               ;	Check for positive exponent.
00D99C  1               
00D99C  1  A5 D4        FASC11	LDA	FR0		;exponent
00D99E  1  10 09        	BPL	FASC12		;if exponent positive, exit
00D9A0  1               
00D9A0  1               ;	Process negative exponent.
00D9A0  1               
00D9A0  1  20 C1 DC     	JSR	DLP		;decrement line buffer pointer
00D9A3  1  A0 00        	LDY	#0		;offset to first character
00D9A5  1  A9 2D        	LDA	#'-'
00D9A7  1  91 F3        	STA	(INBUFF),Y	;put "-" in line buffer
00D9A9  1               
00D9A9  1               ;	Exit.
00D9A9  1               
00D9A9  1  60           FASC12	RTS			;return
00D9AA  1               ;	SPACE	4,10
00D9AA  1               	FIX	IFP
00D9AA  1               ;	SPACE	4,10
00D9AA  1               ;**	IFP - Convert Integer to Floating Point Number
00D9AA  1               ;*
00D9AA  1               ;*	ENTRY	JSR	IFP
00D9AA  1               ;*		FR0 - FR0+1 = integer to convert
00D9AA  1               ;*
00D9AA  1               ;*	EXIT
00D9AA  1               ;*		FR0 - FR0+5 = floating point number
00D9AA  1               ;*
00D9AA  1               ;*	MODS
00D9AA  1               ;*		Original Author Unknown
00D9AA  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00D9AA  1               ;*		   R. K. Nordin	11/01/83
00D9AA  1               
00D9AA  1               
00D9AA  1               ;IFP	=	*	;entry
00D9AA  1               
00D9AA  1               ;	Initialize.
00D9AA  1               
00D9AA  1  A5 D4        	LDA	FR0		;low integer
00D9AC  1  85 F8        	STA	ZTEMP4+1	;save low integer
00D9AE  1  A5 D5        	LDA	FR0+1		;high integer
00D9B0  1  85 F7        	STA	ZTEMP4		;save high integer
00D9B2  1  20 44 DA     	JSR	ZFR0		;zero FR0
00D9B5  1               
00D9B5  1               ;	Convert to floating point.
00D9B5  1               
00D9B5  1  F8           	SED
00D9B6  1  A0 10        	LDY	#16		;number of bits in integer
00D9B8  1               
00D9B8  1  06 F8        IFP1	ASL	ZTEMP4+1	;shift integer
00D9BA  1  26 F7        	ROL	ZTEMP4		;shift integer, setting C if bit present
00D9BC  1               
00D9BC  1  A2 03        	LDX	#3		;offset to last possible byte of number
00D9BE  1               
00D9BE  1  B5 D4        IFP2	LDA	FR0,X		;byte of number
00D9C0  1  75 D4        	ADC	FR0,X		;double byte, adding in carry
00D9C2  1  95 D4        	STA	FR0,X		;update byte of number
00D9C4  1  CA           	DEX
00D9C5  1  D0 F7        	BNE	IFP2		;if not done
00D9C7  1               
00D9C7  1  88           	DEY			;decrement count of integer bits
00D9C8  1  D0 EE        	BNE	IFP1		;if not done
00D9CA  1               
00D9CA  1  D8           	CLD
00D9CB  1               
00D9CB  1               ;	Set exponent.
00D9CB  1               
00D9CB  1  A9 42        	LDA	#$40+2		;indicate decimal after last digit
00D9CD  1  85 D4        	STA	FR0		;exponent
00D9CF  1               
00D9CF  1               ;	Exit.
00D9CF  1               
00D9CF  1  4C 00 DC     	JMP	NORM		;normalize, return
00D9D2  1               ;	SPACE	4,10
00D9D2  1               	FIX	FPI
00D9D2  1               ;	SPACE	4,10
00D9D2  1               ;**	FPI - Convert Floating Point Number to Integer
00D9D2  1               ;*
00D9D2  1               ;*	ENTRY	JSR	FPI
00D9D2  1               ;*		FR0 - FR0+5 = floating point number
00D9D2  1               ;*
00D9D2  1               ;*	EXIT
00D9D2  1               ;*		C set, if error
00D9D2  1               ;*		C clear, if no error
00D9D2  1               ;*		FR0 - FR0+1 = integer
00D9D2  1               ;*
00D9D2  1               ;*	MODS
00D9D2  1               ;*		Original Author Unknown
00D9D2  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00D9D2  1               ;*		   R. K. Nordin	11/01/83
00D9D2  1               
00D9D2  1               
00D9D2  1               ;FPI	=	*		;entry
00D9D2  1               
00D9D2  1               ;	Initialize.
00D9D2  1               
00D9D2  1  A9 00        	LDA	#0
00D9D4  1  85 F7        	STA	ZTEMP4		;zero integer
00D9D6  1  85 F8        	STA	ZTEMP4+1
00D9D8  1               
00D9D8  1               ;	Check exponent.
00D9D8  1               
00D9D8  1  A5 D4        	LDA	FR0		;exponent
00D9DA  1  30 66        	BMI	FPI4		;if sign of exponent is negative, error
00D9DC  1               
00D9DC  1  C9 43        	CMP	#$40+3		;bias+3
00D9DE  1  B0 62        	BCS	FPI4		;if number too big, error
00D9E0  1               
00D9E0  1  38           	SEC
00D9E1  1  E9 40        	SBC	#$40		;subtract bias
00D9E3  1  90 3F        	BCC	FPI2		;if number less than 1, test for round
00D9E5  1               
00D9E5  1               ;	Compute number of digits to convert.
00D9E5  1               
00D9E5  1  69 00        	ADC	#0		;add carry
00D9E7  1  0A           	ASL	A		;2 times exponent-$40+1
00D9E8  1  85 F5        	STA	ZTEMP1		;number of digits to convert
00D9EA  1               
00D9EA  1               ;	Convert.
00D9EA  1               
00D9EA  1  20 5A DA     FPI1	JSR	SIL		;shift integer left
00D9ED  1  B0 53        	BCS	FPI4		;if number too big, error
00D9EF  1               
00D9EF  1  A5 F7        	LDA	ZTEMP4		;2 times integer
00D9F1  1  85 F9        	STA	ZTEMP3		;save 2 times integer
00D9F3  1  A5 F8        	LDA	ZTEMP4+1
00D9F5  1  85 FA        	STA	ZTEMP3+1
00D9F7  1  20 5A DA     	JSR	SIL		;shift integer left
00D9FA  1  B0 46        	BCS	FPI4		;if number too big, error
00D9FC  1               
00D9FC  1  20 5A DA     	JSR	SIL		;shift integer left
00D9FF  1  B0 41        	BCS	FPI4		;if number too big, error
00DA01  1               
00DA01  1  18           	CLC
00DA02  1  A5 F8        	LDA	ZTEMP4+1	;8 times integer
00DA04  1  65 FA        	ADC	ZTEMP3+1	;add 2 times integer
00DA06  1  85 F8        	STA	ZTEMP4+1	;10 times integer
00DA08  1  A5 F7        	LDA	ZTEMP4
00DA0A  1  65 F9        	ADC	ZTEMP3
00DA0C  1  85 F7        	STA	ZTEMP4
00DA0E  1  B0 32        	BCS	FPI4		;if overflow???, error
00DA10  1               
00DA10  1  20 B9 DC     	JSR	GND		;get next digit
00DA13  1  18           	CLC
00DA14  1  65 F8        	ADC	ZTEMP4+1	;insert digit in ???
00DA16  1  85 F8        	STA	ZTEMP4+1	;update ???
00DA18  1  A5 F7        	LDA	ZTEMP4		;???
00DA1A  1  69 00        	ADC	#0		;add carry
00DA1C  1  B0 24        	BCS	FPI4		;if overflow, error
00DA1E  1               
00DA1E  1  85 F7        	STA	ZTEMP4		;update ???
00DA20  1  C6 F5        	DEC	ZTEMP1		;decrement count of digits to convert
00DA22  1  D0 C6        	BNE	FPI1		;if not done
00DA24  1               
00DA24  1               ;	Check for round required.
00DA24  1               
00DA24  1  20 B9 DC     FPI2	JSR	GND		;get next digit
00DA27  1  C9 05        	CMP	#5
00DA29  1  90 0D        	BCC	FPI3		;if digit less than 5, do not round
00DA2B  1               
00DA2B  1               ;	Round.
00DA2B  1               
00DA2B  1  18           	CLC
00DA2C  1  A5 F8        	LDA	ZTEMP4+1
00DA2E  1  69 01        	ADC	#1		;add 1 to round
00DA30  1  85 F8        	STA	ZTEMP4+1
00DA32  1  A5 F7        	LDA	ZTEMP4
00DA34  1  69 00        	ADC	#0
00DA36  1  85 F7        	STA	ZTEMP4
00DA38  1               
00DA38  1               ;	Return integer.
00DA38  1               
00DA38  1  A5 F8        FPI3	LDA	ZTEMP4+1	;low integer
00DA3A  1  85 D4        	STA	FR0		;low integer result
00DA3C  1  A5 F7        	LDA	ZTEMP4		;high integer
00DA3E  1  85 D5        	STA	FR0+1		;high integer result
00DA40  1  18           	CLC			;indicate success
00DA41  1  60           	RTS			;return
00DA42  1               
00DA42  1               ;	Return error.
00DA42  1               
00DA42  1  38           FPI4	SEC			;indicate error
00DA43  1  60           	RTS			;return
00DA44  1               ;	SPACE	4,10
00DA44  1               	FIX	ZFR0
00DA44  1               ;	SPACE	4,10
00DA44  1               ;**	ZFR0 - Zero FR0
00DA44  1               ;*
00DA44  1               ;*	ENTRY	JSR	ZFR0
00DA44  1               ;*
00DA44  1               ;*	MODS
00DA44  1               ;*		Original Author Unknown
00DA44  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DA44  1               ;*		   R. K. Nordin	11/01/83
00DA44  1               
00DA44  1               
00DA44  1               ;ZFR0	=	*	;entry
00DA44  1               
00DA44  1  A2 D4        	LDX	#FR0	;indicate zero FR0
00DA46  1               ;	JMP	ZF1	;zero floating point number, return
00DA46  1               ;	SPACE	4,10
00DA46  1               	FIX	ZF1
00DA46  1               ;	SPACE	4,10
00DA46  1               ;**	ZF1 - Zero Floating Point Number
00DA46  1               ;*
00DA46  1               ;*	ENTRY	JSR	ZF1
00DA46  1               ;*		X = offset to register
00DA46  1               ;*
00DA46  1               ;*	MODS
00DA46  1               ;*		Original Author Unknown
00DA46  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DA46  1               ;*		   R. K. Nordin	11/01/83
00DA46  1               
00DA46  1               
00DA46  1               ;ZF1	=	*	;entry
00DA46  1               
00DA46  1  A0 06        	LDY	#6	;number of bytes to zero
00DA48  1               ;	JMP	ZXLY	;zero bytes, return
00DA48  1               ;	SPACE	4,10
00DA48  1               ;**	ZXLY - Zero Page Zero Location X for Length Y
00DA48  1               ;*
00DA48  1               ;*	ENTRY	JSR	ZXLY
00DA48  1               ;*		X = offset
00DA48  1               ;*		Y = length
00DA48  1               ;*
00DA48  1               ;*	MODS
00DA48  1               ;*		Original Author Unknown
00DA48  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DA48  1               ;*		   R. K. Nordin	11/01/83
00DA48  1               
00DA48  1               
00DA48  1               ZXLY	=	*	;entry
00DA48  1               
00DA48  1  A9 00        	LDA	#0
00DA4A  1               
00DA4A  1  95 00        ZXLY1	STA	$0000,X	;zero byte
00DA4C  1  E8           	INX
00DA4D  1  88           	DEY
00DA4E  1  D0 FA        	BNE	ZXLY1	;if not done
00DA50  1               
00DA50  1  60           	RTS		;return
00DA51  1               ;	SPACE	4,10
00DA51  1               ;**	ILP - Initialize Line Buffer Pointer
00DA51  1               ;*
00DA51  1               ;*	ENTRY	JSR	ILP
00DA51  1               ;*
00DA51  1               ;*	EXIT
00DA51  1               ;*		INBUFF - INBUFF+1 = line buffer address
00DA51  1               ;*
00DA51  1               ;*	MODS
00DA51  1               ;*		Original Author Unknown
00DA51  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DA51  1               ;*		   R. K. Nordin	11/01/83
00DA51  1               
00DA51  1               
00DA51  1               ILP	=	*		;entry
00DA51  1  A9 05        	LDA	#high LBUFF	;high buffer address
00DA53  1  85 F4        	STA	INBUFF+1	;high line buffer pointer
00DA55  1  A9 80        	LDA	#low LBUFF	;low buffer address
00DA57  1  85 F3        	STA	INBUFF		;low line buffer pointer
00DA59  1  60           	RTS			;return
00DA5A  1               ;	SPACE	4,10
00DA5A  1               ;**	SIL - Shift Integer Left
00DA5A  1               ;*
00DA5A  1               ;*	ENTRY	JSR	SIL
00DA5A  1               ;*		ZTEMP4 - ZTEMP4+1 = number (high, low) to shift
00DA5A  1               ;*
00DA5A  1               ;*	EXIT
00DA5A  1               ;*		ZTEMP4 - ZTEMP4+1 shifted left 1
00DA5A  1               ;*
00DA5A  1               ;*	MODS
00DA5A  1               ;*		Original Author Unknown
00DA5A  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DA5A  1               ;*		   R. K. Nordin	11/01/83
00DA5A  1               
00DA5A  1               
00DA5A  1               SIL	=	*		;entry
00DA5A  1  18           	CLC
00DA5B  1  26 F8        	ROL	ZTEMP4+1	;shift low
00DA5D  1  26 F7        	ROL	ZTEMP4		;shift high
00DA5F  1  60           	RTS			;return
00DA60  1               ;	SPACE	4,10
00DA60  1               	FIX	FSUB
00DA60  1               ;	SPACE	4,10
00DA60  1               ;**	FSUB - Perform Floating Point Subtract
00DA60  1               ;*
00DA60  1               ;*	FSUB subtracts FR1 from FR0.
00DA60  1               ;*
00DA60  1               ;*	ENTRY	JSR	FSUB
00DA60  1               ;*		FR0 - FR0+5 = minuend
00DA60  1               ;*		FR1 - FR1+5 = subtrahend
00DA60  1               ;*
00DA60  1               ;*	EXIT
00DA60  1               ;*		C set, if error
00DA60  1               ;*		C clear, if no error
00DA60  1               ;*		FR0 - FR0+5 = difference
00DA60  1               ;*
00DA60  1               ;*	MODS
00DA60  1               ;*		Original Author Unknown
00DA60  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DA60  1               ;*		   R. K. Nordin	11/01/83
00DA60  1               
00DA60  1               
00DA60  1               ;FSUB	=	*	;entry
00DA60  1               
00DA60  1               ;	Complement sign of subtrahend and add.
00DA60  1               
00DA60  1  A5 E0        	LDA	FR1	;subtrahend exponent
00DA62  1  49 80        	EOR	#$80	;complement sign of subtrahend
00DA64  1  85 E0        	STA	FR1	;update subtrahend exponent
00DA66  1               ;	JMP	FADD	;perform add, return
00DA66  1               ;	SPACE	4,10
00DA66  1               	FIX	FADD
00DA66  1               ;	SPACE	4,10
00DA66  1               ;**	FADD - Perform Floating Point Add
00DA66  1               ;*
00DA66  1               ;*	ENTRY	JSR	FADD
00DA66  1               ;*		FR0 - FR0+5 = augend
00DA66  1               ;*		FR1 - FR1+5 = addend
00DA66  1               ;*
00DA66  1               ;*	EXIT
00DA66  1               ;*		C set, if error
00DA66  1               ;*		C clear, if no error
00DA66  1               ;*		FR0 - FR0+5 = sum
00DA66  1               ;*
00DA66  1               ;*	MODS
00DA66  1               ;*		Original Author Unknown
00DA66  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DA66  1               ;*		   R. K. Nordin	11/01/83
00DA66  1               
00DA66  1               
00DA66  1               ;FADD	=	*	;entry
00DA66  1               
00DA66  1               ;	Initialize.
00DA66  1               
00DA66  1  A5 E0        FADD1	LDA	FR1	;exponent of addend
00DA68  1  29 7F        	AND	#$7F	;clear sign of addend mantissa
00DA6A  1  85 F7        	STA	ZTEMP4	;save addend exponent
00DA6C  1  A5 D4        	LDA	FR0	;exponent of augend
00DA6E  1  29 7F        	AND	#$7F	;clear sign of augend mantissa
00DA70  1  38           	SEC
00DA71  1  E5 F7        	SBC	ZTEMP4	;subtract addend exponent
00DA73  1  10 10        	BPL	FADD3	;if augend exponent >= addend exponent
00DA75  1               
00DA75  1               ;	Swap augend and addend.
00DA75  1               
00DA75  1  A2 05        	LDX	#FPREC-1	;offset to last byte
00DA77  1               
00DA77  1  B5 D4        FADD2	LDA	FR0,X		;byte of augend
00DA79  1  B4 E0        	LDY	FR1,X		;byte of addend
00DA7B  1  95 E0        	STA	FR1,X		;move byte of augend to addend
00DA7D  1  98           	TYA
00DA7E  1  95 D4        	STA	FR0,X		;move byte of addend to augend
00DA80  1  CA           	DEX
00DA81  1  10 F4        	BPL	FADD2		;if not done
00DA83  1               
00DA83  1  30 E1        	BMI	FADD1		;re-initialize
00DA85  1               
00DA85  1               ;	Check alignment.
00DA85  1               
00DA85  1  F0 07        FADD3	BEQ	FADD4	;if exponent difference zero, already aligned
00DA87  1               
00DA87  1  C9 05        	CMP	#FMPREC	;mantissa precision
00DA89  1  B0 19        	BCS	FADD6	;if exponent difference < mantissa precision
00DA8B  1               
00DA8B  1               ;	Align.
00DA8B  1               
00DA8B  1  20 3E DC     	JSR	S1R	;shift FR1 right
00DA8E  1               
00DA8E  1               ;	Check for like signs of mantissas.
00DA8E  1               
00DA8E  1  F8           FADD4	SED
00DA8F  1  A5 D4        	LDA	FR0	;augend exponent
00DA91  1  45 E0        	EOR	FR1	;EOR with addend exponent
00DA93  1  30 1E        	BMI	FADD8	;if signs differ, subtract
00DA95  1               
00DA95  1               ;	Add.
00DA95  1               
00DA95  1  A2 04        	LDX	#FMPREC-1	;offset to last byte of mantissa
00DA97  1  18           	CLC
00DA98  1               
00DA98  1  B5 D5        FADD5	LDA	FR0M,X		;byte of augend mantissa
00DA9A  1  75 E1        	ADC	FR1M,X		;add byte of addend mantissa
00DA9C  1  95 D5        	STA	FR0M,X		;update byte of result mantissa
00DA9E  1  CA           	DEX
00DA9F  1  10 F7        	BPL	FADD5		;if not done
00DAA1  1               
00DAA1  1  D8           	CLD
00DAA2  1  B0 03        	BCS	FADD7		;if carry, process carry
00DAA4  1               
00DAA4  1               ;	Exit.
00DAA4  1               
00DAA4  1  4C 00 DC     FADD6	JMP	NORM		;normalize, return
00DAA7  1               
00DAA7  1               ;	Process carry.
00DAA7  1               
00DAA7  1  A9 01        FADD7	LDA	#1		;indicate shift 1
00DAA9  1  20 3A DC     	JSR	S0R		;shift FR0 right
00DAAC  1  A9 01        	LDA	#1		;carry
00DAAE  1  85 D5        	STA	FR0M		;set carry in result
00DAB0  1               
00DAB0  1               ;	Exit.
00DAB0  1               
00DAB0  1  4C 00 DC     	JMP	NORM		;normalize, return
00DAB3  1               
00DAB3  1               ;	Subtract.
00DAB3  1               
00DAB3  1  A2 04        FADD8	LDX	#FMPREC-1	;offset to last byte of mantissa
00DAB5  1  38           	SEC
00DAB6  1               
00DAB6  1  B5 D5        FADD9	LDA	FR0M,X		;byte of augend mantissa
00DAB8  1  F5 E1        	SBC	FR1M,X		;subtract byte of addend mantissa
00DABA  1  95 D5        	STA	FR0M,X		;update byte of result mantissa
00DABC  1  CA           	DEX
00DABD  1  10 F7        	BPL	FADD9		;if not done
00DABF  1               
00DABF  1  90 04        	BCC	FADD10		;if borrow, process borrow
00DAC1  1               
00DAC1  1               ;	Exit.
00DAC1  1               
00DAC1  1  D8           	CLD
00DAC2  1  4C 00 DC     	JMP	NORM		;normalize ???, return
00DAC5  1               
00DAC5  1               ;	Process borrow.
00DAC5  1               
00DAC5  1  A5 D4        FADD10	LDA	FR0		;result exponent
00DAC7  1  49 80        	EOR	#$80		;complement sign of result
00DAC9  1  85 D4        	STA	FR0		;update result exponent
00DACB  1               
00DACB  1  38           	SEC
00DACC  1  A2 04        	LDX	#FMPREC-1	;offset to last byte of mantissa
00DACE  1               
00DACE  1  A9 00        FADD11	LDA	#0
00DAD0  1  F5 D5        	SBC	FR0M,X		;complement byte of result mantissa
00DAD2  1  95 D5        	STA	FR0M,X		;update byte of result mantissa
00DAD4  1  CA           	DEX
00DAD5  1  10 F7        	BPL	FADD11		;if not done
00DAD7  1               
00DAD7  1               ;	Exit.
00DAD7  1               
00DAD7  1  D8           	CLD
00DAD8  1  4C 00 DC     	JMP	NORM		;normalize ???, return
00DADB  1               ;	SPACE	4,10
00DADB  1               	FIX	FMUL
00DADB  1               ;	SPACE	4,10
00DADB  1               ;**	FMUL - Perform Floating Point Multiply
00DADB  1               ;*
00DADB  1               ;*	ENTRY	JSR	FMUL
00DADB  1               ;*		FR0 - FR0+5 = multiplicand
00DADB  1               ;*		FR1 - FR1+5 = multiplier
00DADB  1               ;*
00DADB  1               ;*	EXIT
00DADB  1               ;*		C set, if error
00DADB  1               ;*		C clear, if no error
00DADB  1               ;*		FR0 - FR0+5 = product
00DADB  1               ;*
00DADB  1               ;*	MODS
00DADB  1               ;*		Original Author Unknown
00DADB  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DADB  1               ;*		   R. K. Nordin	11/01/83
00DADB  1               
00DADB  1               
00DADB  1               ;FMUL	=	*	;entry
00DADB  1               
00DADB  1               ;	Check for zero multiplicand.
00DADB  1               
00DADB  1  A5 D4        	LDA	FR0	;multiplicand exponent
00DADD  1  F0 45        	BEQ	FMUL8	;if multiplicand exponent zero, result is zero
00DADF  1               
00DADF  1               ;	Check for zero multiplier.
00DADF  1               
00DADF  1  A5 E0        	LDA	FR1	;multiplier exponent
00DAE1  1  F0 3E        	BEQ	FMUL7	;if multiplier exponent zero, result is zero
00DAE3  1               
00DAE3  1  20 CF DC     	JSR	SUE	;set up exponent
00DAE6  1  38           	SEC
00DAE7  1  E9 40        	SBC	#$40	;subtract bias
00DAE9  1  38           	SEC		;add 1
00DAEA  1  65 E0        	ADC	FR1	;add multiplier exponent
00DAEC  1  30 38        	BMI	FMUL9	;if overflow, error
00DAEE  1               
00DAEE  1               ;	Set up.
00DAEE  1               
00DAEE  1  20 E0 DC     	JSR	SUP	;set up
00DAF1  1               
00DAF1  1               ;	Compute number of times to add multiplicand.
00DAF1  1               
00DAF1  1  A5 DF        FMUL1	LDA	FRE+FPREC-1	;last byte of FRE
00DAF3  1  29 0F        	AND	#$0F		;extract low order digit
00DAF5  1  85 F6        	STA	ZTEMP1+1
00DAF7  1               
00DAF7  1               ;	Check for completion.
00DAF7  1               
00DAF7  1  C6 F6        FMUL2	DEC	ZTEMP1+1	;decrement counter
00DAF9  1  30 06        	BMI	FMUL3		;if done
00DAFB  1               
00DAFB  1  20 01 DD     	JSR	FRA10		;add FR1 to FR0
00DAFE  1  4C F7 DA     	JMP	FMUL2		;continue
00DB01  1               
00DB01  1               ;	Compute number of times to add 10 times multiplicand.
00DB01  1               
00DB01  1  A5 DF        FMUL3	LDA	FRE+FPREC-1	;last byte of FRE
00DB03  1  4A           	LSR	A
00DB04  1  4A           	LSR	A
00DB05  1  4A           	LSR	A
00DB06  1  4A           	LSR	A		;high order digit
00DB07  1  85 F6        	STA	ZTEMP1+1
00DB09  1               
00DB09  1               ;	Check for completion.
00DB09  1               
00DB09  1  C6 F6        FMUL4	DEC	ZTEMP1+1	;decrement counter
00DB0B  1  30 06        	BMI	FMUL5		;if done
00DB0D  1               
00DB0D  1  20 05 DD     	JSR	FRA20		;add FR2 to FR0
00DB10  1  4C 09 DB     	JMP	FMUL4		;continue
00DB13  1               
00DB13  1               ;	Set up for next set of adds.
00DB13  1               
00DB13  1  20 62 DC     FMUL5	JSR	S0ER		;shift FR0/FRE right
00DB16  1               
00DB16  1               ;	Decrement counter and test for completion.
00DB16  1               
00DB16  1  C6 F5        	DEC	ZTEMP1		;decrement
00DB18  1  D0 D7        	BNE	FMUL1		;if not done
00DB1A  1               
00DB1A  1               ;	Set exponent.
00DB1A  1               
00DB1A  1  A5 ED        FMUL6	LDA	EEXP		;exponent
00DB1C  1  85 D4        	STA	FR0		;result exponent
00DB1E  1  4C 04 DC     	JMP	N0E		;normalize, return
00DB21  1               
00DB21  1               ;	Return zero result.
00DB21  1               
00DB21  1  20 44 DA     FMUL7	JSR	ZFR0		;zero FR0
00DB24  1               
00DB24  1               ;	Return no error.
00DB24  1               
00DB24  1  18           FMUL8	CLC			;indicate no error
00DB25  1  60           	RTS			;return
00DB26  1               
00DB26  1               ;	Return error.
00DB26  1               
00DB26  1  38           FMUL9	SEC			;indicate error
00DB27  1  60           	RTS			;return
00DB28  1               ;	SPACE	4,10
00DB28  1               	FIX	FDIV
00DB28  1               ;	SPACE	4,10
00DB28  1               ;**	FDIV - Perform Floating Point Divide
00DB28  1               ;*
00DB28  1               ;*	ENTRY	JSR	FDIV
00DB28  1               ;*		FR0 - FR0+5 = dividend
00DB28  1               ;*		FR1 - FR1+5 = divisor
00DB28  1               ;*
00DB28  1               ;*	EXIT
00DB28  1               ;*		C clear, if no error
00DB28  1               ;*		C set, if error
00DB28  1               ;*		FR0 - FR0+5 = quotient
00DB28  1               ;*
00DB28  1               ;*	MODS
00DB28  1               ;*		Original Author Unknown
00DB28  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DB28  1               ;*		   R. K. Nordin	11/01/83
00DB28  1               
00DB28  1               
00DB28  1               ;FDIV	=	*	;entry
00DB28  1               
00DB28  1               ;	Check for zero divisor.
00DB28  1               
00DB28  1  A5 E0        	LDA	FR1	;divisor exponent
00DB2A  1  F0 FA        	BEQ	FMUL9	;if divisor exponent zero, error
00DB2C  1               
00DB2C  1               ;	Check for zero dividend.
00DB2C  1               
00DB2C  1  A5 D4        	LDA	FR0	;dividend exponent
00DB2E  1  F0 F4        	BEQ	FMUL8	;if dividend exponent zero, result is zero
00DB30  1               
00DB30  1  20 CF DC     	JSR	SUE	;set up exponent
00DB33  1  38           	SEC
00DB34  1  E5 E0        	SBC	FR1	;subtract divisor exponent
00DB36  1  18           	CLC
00DB37  1  69 40        	ADC	#$40	;add bias
00DB39  1  30 EB        	BMI	FMUL9	;if overflow, error
00DB3B  1               
00DB3B  1  20 E0 DC     	JSR	SUP	;set up
00DB3E  1  E6 F5        	INC	ZTEMP1	;divide requires extra pass
00DB40  1  4C 4E DB     	JMP	FDIV3	;skip shift
00DB43  1               
00DB43  1               ;	Shift FR0/FRE left one byte.
00DB43  1               
00DB43  1  A2 00        FDIV1	LDX	#0		;offset to first byte to shift
00DB45  1               
00DB45  1  B5 D5        FDIV2	LDA	FR0+1,X		;byte to shift
00DB47  1  95 D4        	STA	FR0,X		;byte of destination
00DB49  1  E8           	INX
00DB4A  1  E0 0C        	CPX	#FMPREC*2+2	;number of bytes to shift
00DB4C  1  D0 F7        	BNE	FDIV2		;if not done
00DB4E  1               
00DB4E  1               ;	Subtract 2 times divisor from dividend.
00DB4E  1               
00DB4E  1  A0 05        FDIV3	LDY	#FPREC-1	;offset to last byte
00DB50  1  38           	SEC
00DB51  1  F8           	SED
00DB52  1               
00DB52  1  B9 DA 00     FDIV4	LDA	FRE,Y		;byte of dividend
00DB55  1  F9 E6 00     	SBC	FR2,Y		;subtract byte of 2*divisor
00DB58  1  99 DA 00     	STA	FRE,Y		;update byte of dividend
00DB5B  1  88           	DEY
00DB5C  1  10 F4        	BPL	FDIV4		;if not done
00DB5E  1               
00DB5E  1  D8           	CLD
00DB5F  1  90 04        	BCC	FDIV5		;if difference < 0
00DB61  1               
00DB61  1  E6 D9        	INC	QTEMP		;increment
00DB63  1  D0 E9        	BNE	FDIV3		;continue
00DB65  1               
00DB65  1               ;	Adjust.
00DB65  1               
00DB65  1  20 0F DD     FDIV5	JSR	FRA2E	;add FR2 to FR0
00DB68  1               
00DB68  1               ;	Shift last byte of quotient left one digit.
00DB68  1               
00DB68  1  06 D9        	ASL	QTEMP
00DB6A  1  06 D9        	ASL	QTEMP
00DB6C  1  06 D9        	ASL	QTEMP
00DB6E  1  06 D9        	ASL	QTEMP
00DB70  1               
00DB70  1               ;	Subtract divisor from dividend.
00DB70  1               
00DB70  1  A0 05        FDIV6	LDY	#FPREC-1	;offset to last byte
00DB72  1  38           	SEC
00DB73  1  F8           	SED
00DB74  1               
00DB74  1  B9 DA 00     FDIV7	LDA	FRE,Y		;byte of dividend
00DB77  1  F9 E0 00     	SBC	FR1,Y		;subtract byte of divisor
00DB7A  1  99 DA 00     	STA	FRE,Y		;update byte of dividend
00DB7D  1  88           	DEY
00DB7E  1  10 F4        	BPL	FDIV7		;if not done
00DB80  1               
00DB80  1  D8           	CLD
00DB81  1  90 04        	BCC	FDIV8		;if difference < 0
00DB83  1               
00DB83  1  E6 D9        	INC	QTEMP		;increment
00DB85  1  D0 E9        	BNE	FDIV6		;continue
00DB87  1               
00DB87  1               ;	Adjust.
00DB87  1               
00DB87  1  20 09 DD     FDIV8	JSR	FRA1E	;add FR1 to FR0
00DB8A  1  C6 F5        	DEC	ZTEMP1	;decrement
00DB8C  1  D0 B5        	BNE	FDIV1	;if not done
00DB8E  1               
00DB8E  1               ;	Clear exponent.
00DB8E  1               
00DB8E  1  20 62 DC     	JSR	S0ER	;shift  FR0/FRE right
00DB91  1               
00DB91  1               ;	Exit.
00DB91  1               
00DB91  1  4C 1A DB     	JMP	FMUL6
00DB94  1               ;	SPACE	4,10
00DB94  1               ;**	GNC - Get Next Character
00DB94  1               ;*
00DB94  1               ;*	ENTRY	JSR	GNC
00DB94  1               ;*		INBUFF - INBUFF+1 = line buffer pointer
00DB94  1               ;*		CIX = offset to character
00DB94  1               ;*
00DB94  1               ;*	EXIT
00DB94  1               ;*		C set, if character not numeric
00DB94  1               ;*		A = non-numeric character
00DB94  1               ;*		C clear, if character numeric
00DB94  1               ;*		CIX = offset to next character
00DB94  1               ;*
00DB94  1               ;*	MODS
00DB94  1               ;*		Original Author Unknown
00DB94  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DB94  1               ;*		   R. K. Nordin	11/01/83
00DB94  1               
00DB94  1               
00DB94  1               GNC	=	*		;entry
00DB94  1  20 AF DB     	JSR	TNC		;test for numeric character
00DB97  1  A4 F2        	LDY	CIX		;offset
00DB99  1  90 02        	BCC	ICX		;if numeric, increment offset, return
00DB9B  1               
00DB9B  1  B1 F3        	LDA	(INBUFF),Y	;character
00DB9D  1               ;	JMP	ICX		;increment offset, return
00DB9D  1               ;	SPACE	4,10
00DB9D  1               ;**	ICX - Increment Character Offset
00DB9D  1               ;*
00DB9D  1               ;*	ENTRY	JSR	ICX
00DB9D  1               ;*		Y = offset
00DB9D  1               ;*
00DB9D  1               ;*	EXIT
00DB9D  1               ;*		CIX = offset to next character
00DB9D  1               ;*
00DB9D  1               ;*	MODS
00DB9D  1               ;*		Original Author Unknown
00DB9D  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DB9D  1               ;*		   R. K. Nordin	11/01/83
00DB9D  1               
00DB9D  1               
00DB9D  1               ICX	=	*	;entry
00DB9D  1  C8           	INY		;increment offset
00DB9E  1  84 F2        	STY	CIX	;offset
00DBA0  1  60           	RTS		;return
00DBA1  1               ;	SPACE	4,10
00DBA1  1               ;**	SLB - Skip Leading Blanks
00DBA1  1               ;*
00DBA1  1               ;*	ENTRY	JSR	SLB
00DBA1  1               ;*		INBUFF - INBUFF+1 = line buffer pointer
00DBA1  1               ;*		CIX = offset
00DBA1  1               ;*
00DBA1  1               ;*	EXIT
00DBA1  1               ;*		CIX = offset to first non-blank character
00DBA1  1               ;*
00DBA1  1               ;*	MODS
00DBA1  1               ;*		Original Author Unknown
00DBA1  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DBA1  1               ;*		   R. K. Nordin	11/01/83
00DBA1  1               
00DBA1  1               
00DBA1  1               SLB	=	*		;entry
00DBA1  1               
00DBA1  1               ;	Initialize.
00DBA1  1               
00DBA1  1  A4 F2        	LDY	CIX		;offset to character
00DBA3  1  A9 20        	LDA	#' '
00DBA5  1               
00DBA5  1               ;	Search for first non-blank character.
00DBA5  1               
00DBA5  1  D1 F3        SLB1	CMP	(INBUFF),Y	;character
00DBA7  1  D0 03        	BNE	SLB2		;if non-blank character
00DBA9  1               
00DBA9  1  C8           	INY
00DBAA  1  D0 F9        	BNE	SLB1		;if not done
00DBAC  1               
00DBAC  1               ;	Exit.
00DBAC  1               
00DBAC  1  84 F2        SLB2	STY	CIX		;offset to first non-blank character
00DBAE  1  60           	RTS			;return
00DBAF  1               ;	SPACE	4,10
00DBAF  1               ;**	TNC - Test for Numeric Character
00DBAF  1               ;*
00DBAF  1               ;*	ENTRY	JSR	TNC
00DBAF  1               ;*		INBUFF - INBUFF+1 = line buffer pointer
00DBAF  1               ;*		CIX = offset
00DBAF  1               ;*
00DBAF  1               ;*	EXIT
00DBAF  1               ;*		C set, if numeric
00DBAF  1               ;*		C clear if non-numeric
00DBAF  1               ;*
00DBAF  1               ;*	MODS
00DBAF  1               ;*		Original Author Unknown
00DBAF  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DBAF  1               ;*		   R. K. Nordin	11/01/83
00DBAF  1               
00DBAF  1               
00DBAF  1               TNC	=	*		;entry
00DBAF  1  A4 F2        	LDY	CIX		;offset
00DBB1  1  B1 F3        	LDA	(INBUFF),Y	;character
00DBB3  1  38           	SEC
00DBB4  1  E9 30        	SBC	#'0'
00DBB6  1  90 18        	BCC	TVN2		;if < "0", return failure
00DBB8  1               
00DBB8  1  C9 0A        	CMP	#'9'-'0'+1	;return success or failure
00DBBA  1  60           	RTS			;return
00DBBB  1               ;	SPACE	4,10
00DBBB  1               ;**	TVN - Test for Valid Number Character
00DBBB  1               ;*
00DBBB  1               ;*	ENTRY	JSR	TVN
00DBBB  1               ;*
00DBBB  1               ;*	EXIT
00DBBB  1               ;*		C set, if not number
00DBBB  1               ;*		C clear, if number
00DBBB  1               ;*
00DBBB  1               ;*	NOTES
00DBBB  1               ;*		Problem: bytes wasted by BCC TVN5.
00DBBB  1               ;*
00DBBB  1               ;*	MODS
00DBBB  1               ;*		Original Author Unknown
00DBBB  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DBBB  1               ;*		   R. K. Nordin	11/01/83
00DBBB  1               
00DBBB  1               
00DBBB  1               TVN	=	*	;entry
00DBBB  1               
00DBBB  1               ;	Initialize.
00DBBB  1               
00DBBB  1  A5 F2        	LDA	CIX	;offset
00DBBD  1  48           	PHA		;save offset
00DBBE  1               
00DBBE  1               ;	Check next character.
00DBBE  1               
00DBBE  1  20 94 DB     	JSR	GNC	;get next character
00DBC1  1  90 1F        	BCC	TVN5	;if numeric, return success
00DBC3  1               
00DBC3  1  C9 2E        	CMP	#'.'
00DBC5  1  F0 14        	BEQ	TVN4	;if ".", check next character
00DBC7  1               
00DBC7  1  C9 2B        	CMP	#'+'
00DBC9  1  F0 07        	BEQ	TVN3	;if "+", check next character
00DBCB  1               
00DBCB  1  C9 2D        	CMP	#'-'
00DBCD  1  F0 03        	BEQ	TVN3	;if "-", check next character
00DBCF  1               
00DBCF  1               ;	Clean stack.
00DBCF  1               
00DBCF  1  68           TVN1	PLA		;clean stack
00DBD0  1               
00DBD0  1               ;	Return failure.
00DBD0  1               
00DBD0  1  38           TVN2	SEC		;indicate failure
00DBD1  1  60           	RTS		;return
00DBD2  1               
00DBD2  1               ;	Check character after "+" or "-".
00DBD2  1               
00DBD2  1  20 94 DB     TVN3	JSR	GNC	;get next character
00DBD5  1  90 0B        	BCC	TVN5	;if numeric, return success
00DBD7  1               
00DBD7  1  C9 2E        	CMP	#'.'
00DBD9  1  D0 F4        	BNE	TVN1	;if not ".", return failure
00DBDB  1               
00DBDB  1               ;	Check character after ".".
00DBDB  1               
00DBDB  1  20 94 DB     TVN4	JSR	GNC	;get next character
00DBDE  1  90 02        	BCC	TVN5	;if numeric, return success
00DBE0  1               
00DBE0  1  B0 ED        	BCS	TVN1	;return failure
00DBE2  1               
00DBE2  1               ;	Return success.
00DBE2  1               
00DBE2  1  68           TVN5	PLA		;saved offset
00DBE3  1  85 F2        	STA	CIX	;restore offset
00DBE5  1  18           	CLC		;indicate success
00DBE6  1  60           	RTS		;return
00DBE7  1               ;	SPACE	4,10
00DBE7  1               ;**	S2L - Shift FR2 Left One Digit
00DBE7  1               ;*
00DBE7  1               ;*	ENTRY	JSR	S2L
00DBE7  1               ;*
00DBE7  1               ;*	MODS
00DBE7  1               ;*		Original Author Unknown
00DBE7  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DBE7  1               ;*		   R. K. Nordin	11/01/83
00DBE7  1               
00DBE7  1               
00DBE7  1               S2L	=	*	;entry
00DBE7  1  A2 E7        	LDX	#FR2+1	;indicate shift of FR2 mantissa
00DBE9  1  D0 02        	BNE	SML	;shift mantissa left 1 digit, return
00DBEB  1               ;	SPACE	4,10
00DBEB  1               ;**	S0L - Shift FR0 Left One Digit
00DBEB  1               ;*
00DBEB  1               ;*	ENTRY	JSR	S0L
00DBEB  1               ;*
00DBEB  1               ;*	MODS
00DBEB  1               ;*		Original Author Unknown
00DBEB  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DBEB  1               ;*		   R. K. Nordin	11/01/83
00DBEB  1               
00DBEB  1               
00DBEB  1               S0L	=	*	;entry
00DBEB  1  A2 D5        	LDX	#FR0M	;indicate shift of FR0 mantissa
00DBED  1               ;	JMP	SML	;shift mantissa left 1 digit, return
00DBED  1               ;	SPACE	4,10
00DBED  1               ;**	SML - Shift Mantissa Left One Digit
00DBED  1               ;*
00DBED  1               ;*	ENTRY	JSR	SML
00DBED  1               ;*
00DBED  1               ;*	EXIT
00DBED  1               ;*		FRX = excess digit
00DBED  1               ;*
00DBED  1               ;*	MODS
00DBED  1               ;*		Original Author Unknown
00DBED  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DBED  1               ;*		   R. K. Nordin	11/01/83
00DBED  1               
00DBED  1               
00DBED  1               SML	=	*	;entry
00DBED  1  A0 04        	LDY	#4	;number of bits to shift
00DBEF  1               
00DBEF  1  18           SML2	CLC
00DBF0  1  36 04        	ROL	$0004,X	;shift 5th byte left 1 bit
00DBF2  1  36 03        	ROL	$0003,X	;shift 4th byte left 1 bit
00DBF4  1  36 02        	ROL	$0002,X	;shift 3rd byte left 1 bit
00DBF6  1  36 01        	ROL	$0001,X	;shift 2nd byte left 1 bit
00DBF8  1  36 00        	ROL	$0000,X	;shift 1st byte left 1 bit
00DBFA  1  26 EC        	ROL	FRX	;shift excess digit left 1 bit
00DBFC  1  88           	DEY
00DBFD  1  D0 F0        	BNE	SML2	;if not done
00DBFF  1               
00DBFF  1  60           	RTS		;return
00DC00  1               ;	SPACE	4,10
00DC00  1               ;**	NORM - Normalize FR0
00DC00  1               ;*
00DC00  1               ;*	ENTRY	JSR	NORM
00DC00  1               ;*
00DC00  1               ;*	MODS
00DC00  1               ;*		Original Author Unknown
00DC00  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DC00  1               ;*		   R. K. Nordin	11/01/83
00DC00  1               
00DC00  1               
00DC00  1               NORM	=	*		;entry
00DC00  1  A2 00        	LDX	#0
00DC02  1  86 DA        	STX	FRE		;byte to shift in
00DC04  1               ;	JMP	N0E		;normalize FR0/FRE, return
00DC04  1               ;	SPACE	4,10
00DC04  1               ;**	N0E - Normalize FR0/FRE
00DC04  1               ;*
00DC04  1               ;*	ENTRY	JSR	N0E
00DC04  1               ;*
00DC04  1               ;*	MODS
00DC04  1               ;*		Original Author Unknown
00DC04  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DC04  1               ;*		   R. K. Nordin	11/01/83
00DC04  1               
00DC04  1               
00DC04  1               N0E	=	*		;entry
00DC04  1  A2 04        	LDX	#FMPREC-1	;mantissa size
00DC06  1  A5 D4        	LDA	FR0		;exponent
00DC08  1  F0 2E        	BEQ	N0E5		;if exponent zero, number is zero
00DC0A  1               
00DC0A  1  A5 D5        N0E1	LDA	FR0M		;first byte of mantissa
00DC0C  1  D0 1A        	BNE	N0E3		;if not zero, no shift
00DC0E  1               
00DC0E  1               ;	Shift mantissa left 1 byte.
00DC0E  1               
00DC0E  1  A0 00        	LDY	#0		;offset to first byte of mantissa
00DC10  1               
00DC10  1  B9 D6 00     N0E2	LDA	FR0M+1,Y	;byte to shift
00DC13  1  99 D5 00     	STA	FR0M,Y		;byte of destination
00DC16  1  C8           	INY
00DC17  1  C0 05        	CPY	#FMPREC		;size of mantissa
00DC19  1  90 F5        	BCC	N0E2		;if not done
00DC1B  1               
00DC1B  1               ;	Decrement exponent and check for completion.
00DC1B  1               
00DC1B  1  C6 D4        	DEC	FR0		;decrement exponent
00DC1D  1  CA           	DEX
00DC1E  1  D0 EA        	BNE	N0E1		;if not done
00DC20  1               
00DC20  1               ;	Check first byte of mantissa.
00DC20  1               
00DC20  1  A5 D5        	LDA	FR0M	;first byte of mantissa
00DC22  1  D0 04        	BNE	N0E3	;if mantissa not zero
00DC24  1               
00DC24  1               ;	Zero exponent.
00DC24  1               
00DC24  1  85 D4        	STA	FR0	;zero exponent
00DC26  1  18           	CLC
00DC27  1  60           	RTS		;return
00DC28  1               
00DC28  1               ;	Check for overflow.
00DC28  1               
00DC28  1  A5 D4        N0E3	LDA	FR0	;exponent
00DC2A  1  29 7F        	AND	#$7F	;clear sign
00DC2C  1  C9 71        	CMP	#$40+49	;bias+49
00DC2E  1  90 01        	BCC	N0E4	;if exponent < 49, no overflow
00DC30  1               
00DC30  1               ;	Return error.
00DC30  1               
00DC30  1               ;	SEC		;indicate error
00DC30  1  60           	RTS		;return
00DC31  1               
00DC31  1               ;	Check for underflow.
00DC31  1               
00DC31  1  C9 0F        N0E4	CMP	#$40-49
00DC33  1  B0 03        	BCS	N0E5	;if exponent >= -49, no underflow
00DC35  1               
00DC35  1               ;	Zero result.
00DC35  1               
00DC35  1  20 44 DA     	JSR	ZFR0	;zero FR0
00DC38  1               
00DC38  1               ;	Exit.
00DC38  1               
00DC38  1  18           N0E5	CLC		;indicate no error
00DC39  1  60           	RTS		;return
00DC3A  1               ;	SPACE	4,10
00DC3A  1               ;**	S0R - Shift FR0 Right
00DC3A  1               ;*
00DC3A  1               ;*	ENTRY	JSR	S0R
00DC3A  1               ;*		A = shift count
00DC3A  1               ;*
00DC3A  1               ;*	MODS
00DC3A  1               ;*		Original Author Unknown
00DC3A  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DC3A  1               ;*		   R. K. Nordin	11/01/83
00DC3A  1               
00DC3A  1               
00DC3A  1               S0R	=	*	;entry
00DC3A  1  A2 D4        	LDX	#FR0	;indicate shift of FR0
00DC3C  1  D0 02        	BNE	SRR	;shift register right, return
00DC3E  1               ;	SPACE	4,10
00DC3E  1               ;**	S1R - Shift FR1 Right
00DC3E  1               ;*
00DC3E  1               ;*	ENTRY	JSR	S1R
00DC3E  1               ;*		A = shift count
00DC3E  1               ;*
00DC3E  1               ;*	MODS
00DC3E  1               ;*		Original Author Unknown
00DC3E  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DC3E  1               ;*		   R. K. Nordin	11/01/83
00DC3E  1               
00DC3E  1               
00DC3E  1               S1R	=	*	;entry
00DC3E  1  A2 E0        	LDX	#FR1	;indicate shift of FR1
00DC40  1               ;	JMP	SRR	;shift register right, return
00DC40  1               ;	SPACE	4,10
00DC40  1               ;**	SRR - Shift Register Right
00DC40  1               ;*
00DC40  1               ;*	ENTRY	JSR	SRR
00DC40  1               ;*		X = offset to register
00DC40  1               ;*		A = shift count
00DC40  1               ;*
00DC40  1               ;*	MODS
00DC40  1               ;*		Original Author Unknown
00DC40  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DC40  1               ;*		   R. K. Nordin	11/01/83
00DC40  1               
00DC40  1               
00DC40  1               SRR	=	*		;entry
00DC40  1  86 F9        	STX	ZTEMP3		;register
00DC42  1  85 F7        	STA	ZTEMP4		;shift count
00DC44  1  85 F8        	STA	ZTEMP4+1	;save shift count
00DC46  1               
00DC46  1  A0 04        SRR1	LDY	#FMPREC-1	;mantissa size-1
00DC48  1               
00DC48  1  B5 04        SRR2	LDA	$0004,X		;byte to shift
00DC4A  1  95 05        	STA	$0005,X		;byte of destination
00DC4C  1  CA           	DEX
00DC4D  1  88           	DEY
00DC4E  1  D0 F8        	BNE	SRR2		;if not done
00DC50  1               
00DC50  1  A9 00        	LDA	#0
00DC52  1  95 05        	STA	$0005,X		;first byte of mantissa
00DC54  1  A6 F9        	LDX	ZTEMP3		;register
00DC56  1  C6 F7        	DEC	ZTEMP4		;decrement shift count
00DC58  1  D0 EC        	BNE	SRR1		;if not done
00DC5A  1               
00DC5A  1               ;	Adjust exponent.
00DC5A  1               
00DC5A  1  B5 00        	LDA	$0000,X		;exponent
00DC5C  1  18           	CLC
00DC5D  1  65 F8        	ADC	ZTEMP4+1	;subtract shift count
00DC5F  1  95 00        	STA	$0000,X		;update exponent
00DC61  1  60           	RTS			;return
00DC62  1               ;	SPACE	4,10
00DC62  1               ;**	S0ER - Shift FR0/FRE Right
00DC62  1               ;*
00DC62  1               ;*	ENTRY	JSR	S0ER
00DC62  1               ;*
00DC62  1               ;*	MODS
00DC62  1               ;*		Original Author Unknown
00DC62  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DC62  1               ;*		   R. K. Nordin	11/01/83
00DC62  1               
00DC62  1               
00DC62  1               S0ER	=	*		;entry
00DC62  1  A2 0A        	LDX	#FMPREC*2	;number of bytes to shift
00DC64  1               
00DC64  1  B5 D4        S0ER1	LDA	FR0,X		;byte to shift
00DC66  1  95 D5        	STA	FR0+1,X		;byte of destination
00DC68  1  CA           	DEX
00DC69  1  10 F9        	BPL	S0ER1		;if not done
00DC6B  1               
00DC6B  1  A9 00        	LDA	#0
00DC6D  1  85 D4        	STA	FR0		;shift in 0
00DC6F  1  60           	RTS			;return
00DC70  1               ;	SPACE	4,10
00DC70  1               ;**	C0A - Convert FR0 to ASCII
00DC70  1               ;*
00DC70  1               ;*	ENTRY	JSR	C0A
00DC70  1               ;*		A = decimal point position
00DC70  1               ;*
00DC70  1               ;*	MODS
00DC70  1               ;*		Original Author Unknown
00DC70  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DC70  1               ;*		   R. K. Nordin	11/01/83
00DC70  1               
00DC70  1               
00DC70  1               C0A	=	*	;entry
00DC70  1               
00DC70  1               ;	Initialize.
00DC70  1               
00DC70  1  85 F7        	STA	ZTEMP4	;decimal point position counter
00DC72  1  A2 00        	LDX	#0	;offset to first byte of FR0M
00DC74  1  A0 00        	LDY	#0	;offset to first byte of LBUF
00DC76  1               
00DC76  1               ;	Convert next byte.
00DC76  1               
00DC76  1  20 93 DC     C0A1	JSR	TDP	;test for decimal point
00DC79  1  38           	SEC
00DC7A  1  E9 01        	SBC	#1	;decrement deciaml point position
00DC7C  1  85 F7        	STA	ZTEMP4	;update deciaml point position counter
00DC7E  1               
00DC7E  1               ;	Convert first digit of next byte.
00DC7E  1               
00DC7E  1  B5 D5        	LDA	FR0M,X	;byte
00DC80  1  4A           	LSR	A
00DC81  1  4A           	LSR	A
00DC82  1  4A           	LSR	A
00DC83  1  4A           	LSR	A	;first digit
00DC84  1  20 9D DC     	JSR	SNL	;store number in line buffer
00DC87  1               
00DC87  1               ;	Convert second digit of next byte.
00DC87  1               
00DC87  1  B5 D5        	LDA	FR0M,X	;byte
00DC89  1  29 0F        	AND	#$0F	;extract second digit
00DC8B  1  20 9D DC     	JSR	SNL	;store number in line buffer
00DC8E  1  E8           	INX
00DC8F  1  E0 05        	CPX	#FMPREC	;nuber of bytes
00DC91  1  90 E3        	BCC	C0A1	;if not done
00DC93  1               
00DC93  1               ;	Exit.
00DC93  1               
00DC93  1               ;	JMP	TDP	;test for decimal point, return
00DC93  1               ;	SPACE	4,10
00DC93  1               ;**	TDP - Test for Decimal Point
00DC93  1               ;*
00DC93  1               ;*	ENTRY	JSR	TDP
00DC93  1               ;*		ZTEMP4 = decimal point position counter
00DC93  1               ;*
00DC93  1               ;*	MODS
00DC93  1               ;*		Original Author Unknown
00DC93  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DC93  1               ;*		   R. K. Nordin	11/01/83
00DC93  1               
00DC93  1               
00DC93  1               TDP	=	*	;entry
00DC93  1               
00DC93  1               ;	Check decimal point position counter.
00DC93  1               
00DC93  1  A5 F7        	LDA	ZTEMP4	;decimal point position counter
00DC95  1  D0 05        	BNE	TDP1	;if not decimal point position, exit
00DC97  1               
00DC97  1               ;	Insert decimal point.
00DC97  1               
00DC97  1  A9 2E        	LDA	#'.'
00DC99  1  20 9F DC     	JSR	SAL	;store ASCII character in line buffer
00DC9C  1               
00DC9C  1               ;	Exit.
00DC9C  1               
00DC9C  1  60           TDP1	RTS		;return
00DC9D  1               ;	SPACE	4,10
00DC9D  1               ;**	SNL - Store Number in Line Buffer
00DC9D  1               ;*
00DC9D  1               ;*	ENTRY	JSR	SNL
00DC9D  1               ;*		A = digit to store
00DC9D  1               ;*		Y = offset
00DC9D  1               ;*
00DC9D  1               ;*	EXIT
00DC9D  1               ;*		ASCII digit placed in line buffer
00DC9D  1               ;*
00DC9D  1               ;*	MODS
00DC9D  1               ;*		Original Author Unknown
00DC9D  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DC9D  1               ;*		   R. K. Nordin	11/01/83
00DC9D  1               
00DC9D  1               
00DC9D  1               SNL	=	*	;entry
00DC9D  1  09 30        	ORA	#$30	;convert digit to ASCII
00DC9F  1               ;	JMP	SAL	;store ASCII character in line buffer, return
00DC9F  1               ;	SPACE	4,10
00DC9F  1               ;**	SAL - Store ASCII Character in Line Buffer
00DC9F  1               ;*
00DC9F  1               ;*	ENTRY	JSR	SAL
00DC9F  1               ;*		Y = offset
00DC9F  1               ;*		A = character
00DC9F  1               ;*
00DC9F  1               ;*	EXIT
00DC9F  1               ;*		Character placed in line buffer
00DC9F  1               ;*		Y = incremented offset
00DC9F  1               ;*
00DC9F  1               ;*	MODS
00DC9F  1               ;*		Original Author Unknown
00DC9F  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DC9F  1               ;*		   R. K. Nordin	11/01/83
00DC9F  1               
00DC9F  1               
00DC9F  1               SAL	=	*	;entry
00DC9F  1  99 80 05     	STA	LBUFF,Y	;store character in line buffer
00DCA2  1  C8           	INY		;increment offset
00DCA3  1  60           	RTS		;return
00DCA4  1               ;	SPACE	4,10
00DCA4  1               ;**	FNZ - Find Last Non-zero Character in Line Buffer
00DCA4  1               ;*
00DCA4  1               ;*	FNZ returns the last non-zero character.  If the last
00DCA4  1               ;*	non-zero character is ".", FNZ returns the character
00DCA4  1               ;*	preceding the ".".  If no other non-zero character is
00DCA4  1               ;*	encountered, FNZ returns the first character.
00DCA4  1               ;*
00DCA4  1               ;*	ENTRY	JSR	FNZ
00DCA4  1               ;*
00DCA4  1               ;*	EXIT
00DCA4  1               ;*		A = character
00DCA4  1               ;*		X = offset to character
00DCA4  1               ;*
00DCA4  1               ;*	MODS
00DCA4  1               ;*		Original Author Unknown
00DCA4  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DCA4  1               ;*		   R. K. Nordin	11/01/83
00DCA4  1               
00DCA4  1               
00DCA4  1               FNZ	=	*	;entry
00DCA4  1               
00DCA4  1               ;	Initialize.
00DCA4  1               
00DCA4  1  A2 0A        	LDX	#10	;offset to last possible character
00DCA6  1               
00DCA6  1               ;	Check next character.
00DCA6  1               
00DCA6  1  BD 80 05     FNZ1	LDA	LBUFF,X	;character
00DCA9  1  C9 2E        	CMP	#'.'
00DCAB  1  F0 07        	BEQ	FNZ2	;if ".", return preceding character
00DCAD  1               
00DCAD  1  C9 30        	CMP	#'0'
00DCAF  1  D0 07        	BNE	FNZ3	;if not "0", exit
00DCB1  1               
00DCB1  1               ;	Decrement offset and check for completion.
00DCB1  1               
00DCB1  1  CA           	DEX
00DCB2  1  D0 F2        	BNE	FNZ1	;if not done
00DCB4  1               
00DCB4  1               ;	Return character preceding "." or first character.
00DCB4  1               
00DCB4  1  CA           FNZ2	DEX		;offset to character
00DCB5  1  BD 80 05     	LDA	LBUFF,X	;character
00DCB8  1               
00DCB8  1               ;	Exit.
00DCB8  1               
00DCB8  1  60           FNZ3	RTS		;return
00DCB9  1               ;	SPACE	4,10
00DCB9  1               ;**	GND - Get Next Digit
00DCB9  1               ;*
00DCB9  1               ;*	ENTRY	JSR	GND
00DCB9  1               ;*		FR0 - FR0+5 = number
00DCB9  1               ;*
00DCB9  1               ;*	EXIT
00DCB9  1               ;*		A = digit
00DCB9  1               ;*
00DCB9  1               ;*	MODS
00DCB9  1               ;*		Original Author Unknown
00DCB9  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DCB9  1               ;*		   R. K. Nordin	11/01/83
00DCB9  1               
00DCB9  1               
00DCB9  1               GND	=	*	;entry
00DCB9  1  20 EB DB     	JSR	S0L	;shift FR0 left 1 digit
00DCBC  1  A5 EC        	LDA	FRX	;excess digit
00DCBE  1  29 0F        	AND	#$0F	;extract low order digit
00DCC0  1  60           	RTS		;return
00DCC1  1               ;	SPACE	4,10
00DCC1  1               ;**	DLP - Decrement Line Buffer Pointer
00DCC1  1               ;*
00DCC1  1               ;*	ENTRY	JSR	DLP
00DCC1  1               ;*		INBUFF - INBUFF+1 = line buffer pointer
00DCC1  1               ;*
00DCC1  1               ;*	EXIT
00DCC1  1               ;*		INBUFF - INBUFF+1 = incremented line buffer pointer
00DCC1  1               ;*
00DCC1  1               ;*	MODS
00DCC1  1               ;*		Original Author Unknown
00DCC1  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DCC1  1               ;*		   R. K. Nordin	11/01/83
00DCC1  1               
00DCC1  1               
00DCC1  1               DLP	=	*		;entry
00DCC1  1  38           	SEC
00DCC2  1  A5 F3        	LDA	INBUFF		;line buffer pointer
00DCC4  1  E9 01        	SBC	#1		;subtract 1
00DCC6  1  85 F3        	STA	INBUFF		;update line buffer pointer
00DCC8  1  A5 F4        	LDA	INBUFF+1
00DCCA  1  E9 00        	SBC	#0
00DCCC  1  85 F4        	STA	INBUFF+1
00DCCE  1  60           	RTS			;return
00DCCF  1               ;	SPACE	4,10
00DCCF  1               ;**	SUE - Set Up Exponent for Multiply or Divide
00DCCF  1               ;*
00DCCF  1               ;*	ENTRY	JSR	SUE
00DCCF  1               ;*
00DCCF  1               ;*	EXIT
00DCCF  1               ;*		A = FR0 exponent (without sign)
00DCCF  1               ;*		FR1 = FR1 exponent (without sign)
00DCCF  1               ;*		FRSIGN = sign of result
00DCCF  1               ;*
00DCCF  1               ;*	MODS
00DCCF  1               ;*		Original Author Unknown
00DCCF  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DCCF  1               ;*		   R. K. Nordin	11/01/83
00DCCF  1               
00DCCF  1               
00DCCF  1               SUE	=	*	;entry
00DCCF  1  A5 D4        	LDA	FR0	;FR0 exponent
00DCD1  1  45 E0        	EOR	FR1	;EOR with FR1 exponent
00DCD3  1  29 80        	AND	#$80	;extract sign
00DCD5  1  85 EE        	STA	FRSIGN	;sign of result
00DCD7  1  06 E0        	ASL	FR1	;shift out FR1 sign
00DCD9  1  46 E0        	LSR	FR1	;FR1 exponent without sign
00DCDB  1  A5 D4        	LDA	FR0	;FR0 exponent
00DCDD  1  29 7F        	AND	#$7F	;FR0 exponent without sign
00DCDF  1  60           	RTS		;return
00DCE0  1               ;	SPACE	4,10
00DCE0  1               ;**	SUP - Set Up for Multiply or Divide
00DCE0  1               ;*
00DCE0  1               ;*	ENTRY	JSR	SUP
00DCE0  1               ;*		A = exponent
00DCE0  1               ;*
00DCE0  1               ;*	MODS
00DCE0  1               ;*		Original Author Unknown
00DCE0  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DCE0  1               ;*		   R. K. Nordin	11/01/83
00DCE0  1               
00DCE0  1               
00DCE0  1               SUP	=	*	;entry
00DCE0  1  05 EE        	ORA	FRSIGN	;place sign in exponent
00DCE2  1  85 ED        	STA	EEXP	;exponent
00DCE4  1  A9 00        	LDA	#0
00DCE6  1  85 D4        	STA	FR0	;clear FR0 exponent
00DCE8  1  85 E0        	STA	FR1	;clear FR0 exponent
00DCEA  1  20 28 DD     	JSR	M12	;move FR1 to FR2
00DCED  1  20 E7 DB     	JSR	S2L	;shift FR2 left 1 digit
00DCF0  1  A5 EC        	LDA	FRX	;excess digit
00DCF2  1  29 0F        	AND	#$0F	;extract low order digit
00DCF4  1  85 E6        	STA	FR2	;shift in low order digit
00DCF6  1  A9 05        	LDA	#FMPREC	;mantissa size
00DCF8  1  85 F5        	STA	ZTEMP1	;mantissa size
00DCFA  1  20 34 DD     	JSR	M0E	;move FR0 to FRE
00DCFD  1  20 44 DA     	JSR	ZFR0	;zero FR0
00DD00  1  60           	RTS		;return
00DD01  1               ;	SPACE	4,10
00DD01  1               ;**	FRA10 - Add FR1 to FR0
00DD01  1               ;*
00DD01  1               ;*	ENTRY	JSR	FRA10
00DD01  1               ;*		FR0 - FR0+5 = augend
00DD01  1               ;*		FR1 - FR1+5 = addend
00DD01  1               ;*
00DD01  1               ;*	EXIT
00DD01  1               ;*		FR0 - FR0+5 = sum
00DD01  1               ;*
00DD01  1               ;*	MODS
00DD01  1               ;*		Original Author Unknown
00DD01  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DD01  1               ;*		   R. K. Nordin	11/01/83
00DD01  1               
00DD01  1               
00DD01  1               FRA10	=	*		;entry
00DD01  1  A2 D9        	LDX	#FR0+FPREC-1	;offset to last byte of FR0
00DD03  1  D0 06        	BNE	F1R
00DD05  1               ;	SPACE	4,10
00DD05  1               ;**	FRA20 - Add FR2 to FR0
00DD05  1               ;*
00DD05  1               ;*	ENTRY	JSR	FRA20
00DD05  1               ;*		FR0 - FR0+5 = augend
00DD05  1               ;*		FR2 - FR2+5 = addend
00DD05  1               ;*
00DD05  1               ;*	EXIT
00DD05  1               ;*		FR0 - FR0+5 = sum
00DD05  1               ;*
00DD05  1               ;*	MODS
00DD05  1               ;*		Original Author Unknown
00DD05  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DD05  1               ;*		   R. K. Nordin	11/01/83
00DD05  1               
00DD05  1               
00DD05  1               FRA20	=	*		;entry
00DD05  1  A2 D9        	LDX	#FR0+FPREC-1	;offset to last byte of FR0
00DD07  1  D0 08        	BNE	F2R
00DD09  1               ;	SPACE	4,10
00DD09  1               ;**	FRA1E - Add FR1 to FRE
00DD09  1               ;*
00DD09  1               ;*	ENTRY	JSR	FRA1E
00DD09  1               ;*		FRE - FRE+5 = augend
00DD09  1               ;*		FR1 - FR1+5 = addend
00DD09  1               ;*
00DD09  1               ;*	EXIT
00DD09  1               ;*		FRE - FRE+5 = sum
00DD09  1               ;*
00DD09  1               ;*	MODS
00DD09  1               ;*		Original Author Unknown
00DD09  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DD09  1               ;*		   R. K. Nordin	11/01/83
00DD09  1               
00DD09  1               
00DD09  1               FRA1E	=	*		;entry
00DD09  1  A2 DF        	LDX	#FRE+FPREC-1	;offset to last byte of FRE
00DD0B  1               ;	JMP	F1R		;add FR1 to register, return
00DD0B  1               ;	SPACE	4,10
00DD0B  1               ;**	F1R - Add FR1 to Register
00DD0B  1               ;*
00DD0B  1               ;*	ENTRY	JSR	F1R
00DD0B  1               ;*		X = offset to last byte of augend register
00DD0B  1               ;*		FR1 - FR1+5 = addend
00DD0B  1               ;*
00DD0B  1               ;*	EXIT
00DD0B  1               ;*		Sum in augend register
00DD0B  1               ;*
00DD0B  1               ;*	MODS
00DD0B  1               ;*		Original Author Unknown
00DD0B  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DD0B  1               ;*		   R. K. Nordin	11/01/83
00DD0B  1               
00DD0B  1               
00DD0B  1               F1R	=	*		;entry
00DD0B  1  A0 E5        	LDY	#FR1+FPREC-1	;offset to last byte of FR1
00DD0D  1  D0 04        	BNE	FARR
00DD0F  1               ;	SPACE	4,10
00DD0F  1               ;**	FRA2E - Add FR2 to FRE
00DD0F  1               ;*
00DD0F  1               ;*	ENTRY	JSR	FRA2E
00DD0F  1               ;*		FRE - FRE+5 = augend
00DD0F  1               ;*		FR2 - FR2+5 = addend
00DD0F  1               ;*
00DD0F  1               ;*	EXIT
00DD0F  1               ;*		FRE - FRE+5 = sum
00DD0F  1               ;*
00DD0F  1               ;*	MODS
00DD0F  1               ;*		Original Author Unknown
00DD0F  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DD0F  1               ;*		   R. K. Nordin	11/01/83
00DD0F  1               
00DD0F  1               
00DD0F  1               FRA2E	=	*		;entry
00DD0F  1  A2 DF        	LDX	#FRE+FPREC-1	;offset to last byte of FRE
00DD11  1               ;	JMP	F2R
00DD11  1               ;	SPACE	4,10
00DD11  1               ;**	F2R - Add FR2 to Register
00DD11  1               ;*
00DD11  1               ;*	ENTRY	JSR	F2R
00DD11  1               ;*		X = offset to last byte of augend register
00DD11  1               ;*		FR2 - FR2+5 = addend
00DD11  1               ;*
00DD11  1               ;*	EXIT
00DD11  1               ;*		Sum in augend register
00DD11  1               ;*
00DD11  1               ;*	MODS
00DD11  1               ;*		Original Author Unknown
00DD11  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DD11  1               ;*		   R. K. Nordin	11/01/83
00DD11  1               
00DD11  1               
00DD11  1               F2R	=	*		;entry
00DD11  1  A0 EB        	LDY	#FR2+FPREC-1	;offset to last byte of FR2
00DD13  1               ;	JMP	FARR
00DD13  1               ;	SPACE	4,10
00DD13  1               ;**	FARR - Add Register to Register
00DD13  1               ;*
00DD13  1               ;*	ENTRY	JSR	FARR
00DD13  1               ;*		X = offset to last byte of augend register
00DD13  1               ;*		Y = offset to last byte of addend register
00DD13  1               ;*
00DD13  1               ;*	EXIT
00DD13  1               ;*		Sum in augend register
00DD13  1               ;*
00DD13  1               ;*	MODS
00DD13  1               ;*		Original Author Unknown
00DD13  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DD13  1               ;*		   R. K. Nordin	11/01/83
00DD13  1               
00DD13  1               
00DD13  1               FARR	=	*		;entry
00DD13  1               
00DD13  1               ;	Initialize.
00DD13  1               
00DD13  1  A9 05        	LDA	#FPREC-1	;floating point number size-1
00DD15  1  85 F7        	STA	ZTEMP4		;byte count
00DD17  1  18           	CLC
00DD18  1  F8           	SED
00DD19  1               
00DD19  1               ;	Add.
00DD19  1               
00DD19  1  B5 00        FARR1	LDA	$0000,X		;byte of augend
00DD1B  1  79 00 00     	ADC	$0000,Y		;add byte of addend
00DD1E  1  95 00        	STA	$0000,X		;update byte of augend
00DD20  1  CA           	DEX
00DD21  1  88           	DEY
00DD22  1  C6 F7        	DEC	ZTEMP4		;decrement byte count
00DD24  1  10 F3        	BPL	FARR1		;if not done
00DD26  1               
00DD26  1               ;	Exit.
00DD26  1               
00DD26  1  D8           	CLD
00DD27  1  60           	RTS			;return
00DD28  1               ;	SPACE	4,10
00DD28  1               ;**	M12 - Move FR1 to FR2
00DD28  1               ;*
00DD28  1               ;*	ENTRY	JSR	M12
00DD28  1               ;*		FR1 - FR1+5 = number to move
00DD28  1               ;*
00DD28  1               ;*	EXIT
00DD28  1               ;*		FR2 - FR2+5 = moved number
00DD28  1               ;*
00DD28  1               ;*	MODS
00DD28  1               ;*		Original Author Unknown
00DD28  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DD28  1               ;*		   R. K. Nordin	11/01/83
00DD28  1               
00DD28  1               
00DD28  1               M12	=	*		;entry
00DD28  1  A0 05        	LDY	#FPREC-1	;offset to last byte
00DD2A  1               
00DD2A  1  B9 E0 00     M121	LDA	FR1,Y		;byte of source
00DD2D  1  99 E6 00     	STA	FR2,Y		;byte of destination
00DD30  1  88           	DEY
00DD31  1  10 F7        	BPL	M121		;if not done
00DD33  1               
00DD33  1  60           	RTS			;return
00DD34  1               ;	SPACE	4,10
00DD34  1               ;**	M0E - Move FR0 to FRE
00DD34  1               ;*
00DD34  1               ;*	ENTRY	JSR	M0E
00DD34  1               ;*		FR0 - FR0+5 = number to move
00DD34  1               ;*
00DD34  1               ;*	EXIT
00DD34  1               ;*		FRE - FRE+5 = moved number
00DD34  1               ;*
00DD34  1               ;*	MODS
00DD34  1               ;*		Original Author Unknown
00DD34  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DD34  1               ;*		   R. K. Nordin	11/01/83
00DD34  1               
00DD34  1               
00DD34  1               M0E	=	*		;entry
00DD34  1  A0 05        	LDY	#FPREC-1	;offset to last byte
00DD36  1               
00DD36  1  B9 D4 00     M0E1	LDA	FR0,Y		;byte of source
00DD39  1  99 DA 00     	STA	FRE,Y		;byte of destination
00DD3C  1  88           	DEY
00DD3D  1  10 F7        	BPL	M0E1		;if not done
00DD3F  1               
00DD3F  1  60           	RTS			;return
00DD40  1               ;	SPACE	4,10
00DD40  1               	FIX	PLYEVL
00DD40  1               ;	SPACE	4,10
00DD40  1               ;**	PLYEVL - Evaluate Polynomial
00DD40  1               ;*
00DD40  1               ;*	Y = A(0)+A(1)*X+A(2)*X^2+...+A(N)*X^N
00DD40  1               ;*
00DD40  1               ;*	ENTRY	JSR	PLYEVL
00DD40  1               ;*		X = low address of coefficient table
00DD40  1               ;*		Y = high address of coefficient table
00DD40  1               ;*		FR0 - FR0+5 = X argument
00DD40  1               ;*		A = N+1
00DD40  1               ;*
00DD40  1               ;*	EXIT
00DD40  1               ;*		FR0 - FR0+5 = Y result
00DD40  1               ;*
00DD40  1               ;*	MODS
00DD40  1               ;*		Original Author Unknown
00DD40  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DD40  1               ;*		   R. K. Nordin	11/01/83
00DD40  1               
00DD40  1               
00DD40  1               ;PLYEVL	=	*		;entry
00DD40  1               
00DD40  1  86 FE        	STX	FPTR2		;save pointer to coefficients
00DD42  1  84 FF        	STY	FPTR2+1
00DD44  1  85 EF        	STA	PLYCNT		;degree
00DD46  1  A2 E0        	LDX	#low PLYARG
00DD48  1  A0 05        	LDY	#high PLYARG
00DD4A  1  20 A7 DD     	JSR	FST0R		;save argument
00DD4D  1  20 B6 DD     	JSR	FMOVE		;move argument to FR1
00DD50  1  A6 FE        	LDX	FPTR2
00DD52  1  A4 FF        	LDY	FPTR2+1
00DD54  1  20 89 DD     	JSR	FLD0R		;initialize sum in FR0
00DD57  1  C6 EF        	DEC	PLYCNT		;decrement degree
00DD59  1  F0 2D        	BEQ	PLY3		;if complete, exit
00DD5B  1               
00DD5B  1  20 DB DA     PLY1	JSR	FMUL		;argument times current sum
00DD5E  1  B0 28        	BCS	PLY3		;if overflow
00DD60  1               
00DD60  1  18           	CLC
00DD61  1  A5 FE        	LDA	FPTR2		;current low coefficient address
00DD63  1  69 06        	ADC	#FPREC		;add floating point number size
00DD65  1  85 FE        	STA	FPTR2		;update low coefficient address
00DD67  1  90 06        	BCC	PLY2		;if no carry
00DD69  1               
00DD69  1  A5 FF        	LDA	FPTR2+1		;current high coefficceint address
00DD6B  1  69 00        	ADC	#0		;adjust high coefficient address
00DD6D  1  85 FF        	STA	FPTR2+1		;update high coefficient address
00DD6F  1               
00DD6F  1  A6 FE        PLY2	LDX	FPTR2		;low coefficient address
00DD71  1  A4 FF        	LDY	FPTR2+1		;high coefficient address
00DD73  1  20 98 DD     	JSR	FLD1R		;get next coefficient
00DD76  1  20 66 DA     	JSR	FADD		;add coefficient to argument times sum
00DD79  1  B0 0D        	BCS	PLY3		;if overflow
00DD7B  1               
00DD7B  1  C6 EF        	DEC	PLYCNT		;decrement degree
00DD7D  1  F0 09        	BEQ	PLY3		;if complete, exit
00DD7F  1               
00DD7F  1  A2 E0        	LDX	#low PLYARG	;low argument address
00DD81  1  A0 05        	LDY	#high PLYARG	;high argument address
00DD83  1  20 98 DD     	JSR	FLD1R		;get argument
00DD86  1  30 D3        	BMI	PLY1		;continue
00DD88  1               
00DD88  1  60           PLY3	RTS			;return
00DD89  1               ;	SPACE	4,10
00DD89  1               	FIX	FLD0R
00DD89  1               ;	SPACE	4,10
00DD89  1               ;**	FLD0R - ???
00DD89  1               ;*
00DD89  1               ;*	ENTRY	JSR	FLD0R
00DD89  1               ;*		X = low pointer
00DD89  1               ;*		Y = high pointer
00DD89  1               ;*
00DD89  1               ;*	EXIT
00DD89  1               ;*		FR0 loaded
00DD89  1               ;*
00DD89  1               ;*	MODS
00DD89  1               ;*		Original Author Unknown
00DD89  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DD89  1               ;*		   R. K. Nordin	11/01/83
00DD89  1               
00DD89  1               
00DD89  1               ;FLD0R	=	*		;entry
00DD89  1  86 FC        	STX	FLPTR		;low pointer
00DD8B  1  84 FD        	STY	FLPTR+1		;high pointer
00DD8D  1               ;	JMP	FLD0P		;load FR0, return
00DD8D  1               ;	SPACE	4,10
00DD8D  1               	FIX	FLD0P
00DD8D  1               ;	SPACE	4,10
00DD8D  1               ;**	FLD0P - Load FR0
00DD8D  1               ;*
00DD8D  1               ;*	ENTRY	JSR	FLD0P
00DD8D  1               ;*		FLPTR - FLPTR+1 = pointer
00DD8D  1               ;*
00DD8D  1               ;*	EXIT
00DD8D  1               ;*		FR0 loaded
00DD8D  1               ;*
00DD8D  1               ;*	MODS
00DD8D  1               ;*		Original Author Unknown
00DD8D  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DD8D  1               ;*		   R. K. Nordin	11/01/83
00DD8D  1               
00DD8D  1               
00DD8D  1               ;FLD0P	=	*		;entry
00DD8D  1               
00DD8D  1  A0 05        	LDY	#FPREC-1	;offset to last byte
00DD8F  1               
00DD8F  1  B1 FC        FLD01	LDA	(FLPTR),Y	;byte of source
00DD91  1  99 D4 00     	STA	FR0,Y		;byte of destination
00DD94  1  88           	DEY
00DD95  1  10 F8        	BPL	FLD01		;if not done
00DD97  1               
00DD97  1  60           	RTS			;return
00DD98  1               ;	SPACE	4,10
00DD98  1               	FIX	FLD1R
00DD98  1               ;	SPACE	4,10
00DD98  1               ;**	FLD1R - Load FR1
00DD98  1               ;*
00DD98  1               ;*	ENTRY	JSR	FLD1R
00DD98  1               ;*		X = low pointer
00DD98  1               ;*		Y = high pointer
00DD98  1               ;*
00DD98  1               ;*	EXIT
00DD98  1               ;*		FR1 loaded
00DD98  1               ;*
00DD98  1               ;*	MODS
00DD98  1               ;*		Original Author Unknown
00DD98  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DD98  1               ;*		   R. K. Nordin	11/01/83
00DD98  1               
00DD98  1               
00DD98  1               ;FLD1R	=	*		;entry
00DD98  1  86 FC        	STX	FLPTR		;low pointer
00DD9A  1  84 FD        	STY	FLPTR+1		;high pointer
00DD9C  1               ;	JMP	FLD1P		;load FR1, return
00DD9C  1               ;	SPACE	4,10
00DD9C  1               	FIX	FLD1P
00DD9C  1               ;	SPACE	4,10
00DD9C  1               ;**	FLD1P - Load FR1
00DD9C  1               ;*
00DD9C  1               ;*	ENTRY	JSR	FLD1P
00DD9C  1               ;*		FLPTR - FLPTR+1 = pointer
00DD9C  1               ;*
00DD9C  1               ;*	EXIT
00DD9C  1               ;*		FR1 loaded
00DD9C  1               ;*
00DD9C  1               ;*	MODS
00DD9C  1               ;*		Original Author Unknown
00DD9C  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DD9C  1               ;*		   R. K. Nordin	11/01/83
00DD9C  1               
00DD9C  1               
00DD9C  1               ;FLD1P	=	*		;entry
00DD9C  1               
00DD9C  1  A0 05        	LDY	#FPREC-1	;offset to last byte
00DD9E  1               
00DD9E  1  B1 FC        FLD11	LDA	(FLPTR),Y	;byte of source
00DDA0  1  99 E0 00     	STA	FR1,Y		;byte of destination
00DDA3  1  88           	DEY
00DDA4  1  10 F8        	BPL	FLD11		;if not done
00DDA6  1               
00DDA6  1  60           	RTS			;return
00DDA7  1               ;	SPACE	4,10
00DDA7  1               	FIX	FST0R
00DDA7  1               ;	SPACE	4,10
00DDA7  1               ;**	FST0R - Store FR0
00DDA7  1               ;*
00DDA7  1               ;*	ENTRY	JSR	FST0R
00DDA7  1               ;*		FR0 - FR0+5 = number
00DDA7  1               ;*		X = low pointer
00DDA7  1               ;*		Y = high pointer
00DDA7  1               ;*
00DDA7  1               ;*	EXIT
00DDA7  1               ;*		FR0 stored
00DDA7  1               ;*
00DDA7  1               ;*	MODS
00DDA7  1               ;*		Original Author Unknown
00DDA7  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DDA7  1               ;*		   R. K. Nordin	11/01/83
00DDA7  1               
00DDA7  1               
00DDA7  1               ;FST0R	=	*		;entry
00DDA7  1  86 FC        	STX	FLPTR		;low pointer
00DDA9  1  84 FD        	STY	FLPTR+1		;high pointer
00DDAB  1               ;	JMP	FST0P		;???, return
00DDAB  1               ;	SPACE	4,10
00DDAB  1               	FIX	FST0P
00DDAB  1               ;	SPACE	4,10
00DDAB  1               ;**	FST0P - Store FR0
00DDAB  1               ;*
00DDAB  1               ;*	ENTRY	JSR	FST0P
00DDAB  1               ;*		FR0 - FR0+5 = number
00DDAB  1               ;*		FLPTR - FLPTR+1 = pointer
00DDAB  1               ;*
00DDAB  1               ;*	EXIT
00DDAB  1               ;*		FR0 stored
00DDAB  1               ;*
00DDAB  1               ;*	MODS
00DDAB  1               ;*		Original Author Unknown
00DDAB  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DDAB  1               ;*		   R. K. Nordin	11/01/83
00DDAB  1               
00DDAB  1               
00DDAB  1               ;FST0P	=	*		;entry
00DDAB  1               
00DDAB  1  A0 05        	LDY	#FPREC-1	;offset to last byte
00DDAD  1               
00DDAD  1  B9 D4 00     FST01	LDA	FR0,Y		;byte of source
00DDB0  1  91 FC        	STA	(FLPTR),Y	;byte of destination
00DDB2  1  88           	DEY
00DDB3  1  10 F8        	BPL	FST01		;if not done
00DDB5  1               
00DDB5  1  60           	RTS			;return
00DDB6  1               ;	SPACE	4,10
00DDB6  1               	FIX	FMOVE
00DDB6  1               ;	SPACE	4,10
00DDB6  1               ;**	FMOVE - Move FR0 to FR1
00DDB6  1               ;*
00DDB6  1               ;*	ENTRY	JSR	FMOVE
00DDB6  1               ;*
00DDB6  1               ;*	MODS
00DDB6  1               ;*		Original Author Unknown
00DDB6  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DDB6  1               ;*		   R. K. Nordin	11/01/83
00DDB6  1               
00DDB6  1               
00DDB6  1               ;FMOVE	=	*		;entry
00DDB6  1               
00DDB6  1  A2 05        	LDX	#FPREC-1	;offset to last byte
00DDB8  1               
00DDB8  1  B5 D4        FMO1	LDA	FR0,X		;byte of source
00DDBA  1  95 E0        	STA	FR1,X		;byte of destination
00DDBC  1  CA           	DEX
00DDBD  1  10 F9        	BPL	FMO1		;if not done
00DDBF  1               
00DDBF  1  60           	RTS			;return
00DDC0  1               ;	SPACE	4,10
00DDC0  1               	FIX	EXP
00DDC0  1               ;	SPACE	4,10
00DDC0  1               ;**	EXP - Compute Power of e
00DDC0  1               ;*
00DDC0  1               ;*	ENTRY	JSR	EXP
00DDC0  1               ;*
00DDC0  1               ;*	MODS
00DDC0  1               ;*		Original Author Unknown
00DDC0  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DDC0  1               ;*		   R. K. Nordin	11/01/83
00DDC0  1               
00DDC0  1               
00DDC0  1               ;EXP	=	*		;entry
00DDC0  1               
00DDC0  1               ;	Initialize.
00DDC0  1               
00DDC0  1  A2 89        	LDX	#low LOG10E	;base 10 logarithm of e
00DDC2  1  A0 DE        	LDY	#high LOG10E
00DDC4  1  20 98 DD     	JSR	FLD1R		;load FR1
00DDC7  1               
00DDC7  1               ;	Compute X*LOG10(E).
00DDC7  1               
00DDC7  1  20 DB DA     	JSR	FMUL		;multiply
00DDCA  1  B0 7F        	BCS	EXP6		;if overflow, error
00DDCC  1               
00DDCC  1               ;	Compute result = 10^(X*LOG10(E)).
00DDCC  1               
00DDCC  1               ;	JMP	EXP10		;compute power of 10, return
00DDCC  1               ;	SPACE	4,10
00DDCC  1               	FIX	EXP10
00DDCC  1               ;	SPACE	4,10
00DDCC  1               ;**	EXP10 - Compute Power of 10
00DDCC  1               ;*
00DDCC  1               ;*	ENTRY	JSR	EXP10
00DDCC  1               ;*
00DDCC  1               ;*	MODS
00DDCC  1               ;*		Original Author Unknown
00DDCC  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DDCC  1               ;*		   R. K. Nordin	11/01/83
00DDCC  1               
00DDCC  1               
00DDCC  1               ;EXP10	=	*		;entry
00DDCC  1               
00DDCC  1               ;	Initialize.
00DDCC  1               
00DDCC  1  A9 00        	LDA	#0
00DDCE  1  85 F1        	STA	XFMFLG		;zero integer part
00DDD0  1  A5 D4        	LDA	FR0
00DDD2  1  85 F0        	STA	SGNFLG		;save argument sign
00DDD4  1  29 7F        	AND	#$7F		;extract absolute value
00DDD6  1  85 D4        	STA	FR0		;update argument
00DDD8  1               
00DDD8  1               ;	Check for argument less than 1.
00DDD8  1               
00DDD8  1  38           	SEC
00DDD9  1  E9 40        	SBC	#$40		;subtract bias
00DDDB  1  30 26        	BMI	EXP1		;if argument < 1
00DDDD  1               
00DDDD  1               ;	Extract integer and fractional parts of exponent.
00DDDD  1               
00DDDD  1  C9 04        	CMP	#FPREC-2
00DDDF  1  10 6A        	BPL	EXP6		;if argument too big, error
00DDE1  1               
00DDE1  1  A2 E6        	LDX	#low FPSCR
00DDE3  1  A0 05        	LDY	#high FPSCR
00DDE5  1  20 A7 DD     	JSR	FST0R		;save argument
00DDE8  1  20 D2 D9     	JSR	FPI		;convert argument to integer
00DDEB  1  A5 D4        	LDA	FR0
00DDED  1  85 F1        	STA	XFMFLG		;save interger part
00DDEF  1  A5 D5        	LDA	FR0+1		;most significant byte of integer part
00DDF1  1  D0 58        	BNE	EXP6		;if integer part too large, error
00DDF3  1               
00DDF3  1  20 AA D9     	JSR	IFP		;convert integer part to floating point
00DDF6  1  20 B6 DD     	JSR	FMOVE		;???
00DDF9  1  A2 E6        	LDX	#low FPSCR
00DDFB  1  A0 05        	LDY	#high FPSCR
00DDFD  1  20 89 DD     	JSR	FLD0R		;argument
00DE00  1  20 60 DA     	JSR	FSUB		;subtract to get fractional part
00DE03  1               
00DE03  1               ;	Compute 10 to fractional exponent.
00DE03  1               
00DE03  1  A9 0A        EXP1	LDA	#NPCOEF
00DE05  1  A2 4D        	LDX	#low P10COF
00DE07  1  A0 DE        	LDY	#high P10COF
00DE09  1  20 40 DD     	JSR	PLYEVL		;P(X)
00DE0C  1  20 B6 DD     	JSR	FMOVE
00DE0F  1  20 DB DA     	JSR	FMUL		;P(X)*P(X)
00DE12  1               
00DE12  1               ;	Check integer part.
00DE12  1               
00DE12  1  A5 F1        	LDA	XFMFLG		;integer part
00DE14  1  F0 23        	BEQ	EXP4		;if integer part zero
00DE16  1               
00DE16  1               ;	Compute 10 to integer part.
00DE16  1               
00DE16  1  18           	CLC
00DE17  1  6A           	ROR	A		;integer part divided by 2
00DE18  1  85 E0        	STA	FR1		;exponent
00DE1A  1  A9 01        	LDA	#1		;assume mantissa 1
00DE1C  1  90 02        	BCC	EXP2		;if integer part even
00DE1E  1               
00DE1E  1  A9 10        	LDA	#$10		;substitute mantissa 10
00DE20  1               
00DE20  1  85 E1        EXP2	STA	FR1M		;mantissa
00DE22  1  A2 04        	LDX	#FMPREC-1	;offset to last byte of mantissa
00DE24  1  A9 00        	LDA	#0
00DE26  1               
00DE26  1  95 E2        EXP3	STA	FR1M+1,X	;zero byte of mantissa
00DE28  1  CA           	DEX
00DE29  1  10 FB        	BPL	EXP3		;if not done
00DE2B  1               
00DE2B  1  A5 E0        	LDA	FR1		;exponent
00DE2D  1  18           	CLC
00DE2E  1  69 40        	ADC	#$40		;add bias
00DE30  1  B0 19        	BCS	EXP6		;if too big, error
00DE32  1               
00DE32  1  30 17        	BMI	EXP6		;if underflow, error
00DE34  1               
00DE34  1  85 E0        	STA	FR1		;10 to integer part
00DE36  1               
00DE36  1               ;	Compute product of 10 to integer part and 10 to fractional part.
00DE36  1               
00DE36  1  20 DB DA     	JSR	FMUL		;multiply to get result
00DE39  1               
00DE39  1               ;	Invert result if argument < 0.
00DE39  1               
00DE39  1  A5 F0        EXP4	LDA	SGNFLG		;argument sign
00DE3B  1  10 0D        	BPL	EXP5		;if argument >= 0
00DE3D  1               
00DE3D  1  20 B6 DD     	JSR	FMOVE
00DE40  1  A2 8F        	LDX	#low FONE
00DE42  1  A0 DE        	LDY	#high FONE
00DE44  1  20 89 DD     	JSR	FLD0R		;load FR0
00DE47  1  20 28 DB     	JSR	FDIV		;divide to get result
00DE4A  1               
00DE4A  1               ;	Exit.
00DE4A  1               
00DE4A  1  60           EXP5	RTS			;return
00DE4B  1               
00DE4B  1               ;	Return error.
00DE4B  1               
00DE4B  1  38           EXP6	SEC			;indicate error
00DE4C  1  60           	RTS			;return
00DE4D  1               ;	SPACE	4,10
00DE4D  1               ;**	P10COF - Power of 10 Coefficients
00DE4D  1               
00DE4D  1               
00DE4D  1  3D 17 94 19  P10COF	DB	$3D,$17,$94,$19,$00,$00	;0.0000179419
00DE51  1  00 00 3D 57  
00DE55  1  33 05 00 00  
00DE89  1               	DB	$3D,$57,$33,$05,$00,$00	;0.0000573305
00DE89  1               	DB	$3E,$05,$54,$76,$62,$00	;0.0005547662
00DE89  1               	DB	$3E,$32,$19,$62,$27,$00	;0.0032176227
00DE89  1               	DB	$3F,$01,$68,$60,$30,$36	;0.0168603036
00DE89  1               	DB	$3F,$07,$32,$03,$27,$41	;0.0732032741
00DE89  1               	DB	$3F,$25,$43,$34,$56,$75	;0.2543345675
00DE89  1               	DB	$3F,$66,$27,$37,$30,$50	;0.6627373050
00DE89  1               	DB	$40,$01,$15,$12,$92,$55	;1.15129255
00DE89  1               	DB	$3F,$99,$99,$99,$99,$99	;0.9999999999
00DE89  1               
00DE89  1               NPCOEF	=	(*-P10COF)/FPREC
00DE89  1               ;	SPACE	4,10
00DE89  1               ;**	LOG10E - Base 10 Logarithm of e
00DE89  1               
00DE89  1               
00DE89  1  3F 43 42 94  LOG10E	DB	$3F,$43,$42,$94,$48,$19	;base 10 logarithm of e
00DE8D  1  48 19        
00DE8F  1               ;	SPACE	4,10
00DE8F  1               ;**	FONE - 1.0
00DE8F  1               
00DE8F  1               
00DE8F  1  40 01 00 00  FONE	DB	$40,$01,$00,$00,$00,$00	;1.0
00DE93  1  00 00        
00DE95  1               ;	SPACE	4,10
00DE95  1               ;**	XFORM - Transform
00DE95  1               ;*
00DE95  1               ;*	Z = (X-C)/(X+C)
00DE95  1               ;*
00DE95  1               ;*	ENTRY	JSR	XFORM
00DE95  1               ;*
00DE95  1               ;*	MODS
00DE95  1               ;*		Original Author Unknown
00DE95  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DE95  1               ;*		   R. K. Nordin	11/01/83
00DE95  1               
00DE95  1               
00DE95  1               XFORM	=	*		;entry
00DE95  1  86 FE        	STX	FPTR2
00DE97  1  84 FF        	STY	FPTR2+1
00DE99  1  A2 E0        	LDX	#low PLYARG
00DE9B  1  A0 05        	LDY	#high PLYARG
00DE9D  1  20 A7 DD     	JSR	FST0R		;save argument
00DEA0  1  A6 FE        	LDX	FPTR2
00DEA2  1  A4 FF        	LDY	FPTR2+1
00DEA4  1  20 98 DD     	JSR	FLD1R		;load FR1
00DEA7  1  20 66 DA     	JSR	FADD		;X+C
00DEAA  1  A2 E6        	LDX	#low FPSCR
00DEAC  1  A0 05        	LDY	#high FPSCR
00DEAE  1  20 A7 DD     	JSR	FST0R		;store FR0
00DEB1  1  A2 E0        	LDX	#low PLYARG
00DEB3  1  A0 05        	LDY	#high PLYARG
00DEB5  1  20 89 DD     	JSR	FLD0R		;load FR0
00DEB8  1  A6 FE        	LDX	FPTR2
00DEBA  1  A4 FF        	LDY	FPTR2+1
00DEBC  1  20 98 DD     	JSR	FLD1R		;load FR1
00DEBF  1  20 60 DA     	JSR	FSUB		;X-C
00DEC2  1  A2 E6        	LDX	#low FPSCR
00DEC4  1  A0 05        	LDY	#high FPSCR
00DEC6  1  20 98 DD     	JSR	FLD1R		;load FR1
00DEC9  1  20 28 DB     	JSR	FDIV		;divide to get result
00DECC  1  60           	RTS			;return
00DECD  1               ;	SPACE	4,10
00DECD  1               	FIX	LOG
00DECD  1               ;	SPACE	4,10
00DECD  1               ;**	LOG - Compute Base e Logarithm
00DECD  1               ;*
00DECD  1               ;*	ENTRY	JSR	LOG
00DECD  1               ;*		FR0 - FR0+5 = argument
00DECD  1               ;*
00DECD  1               ;*	MODS
00DECD  1               ;*		Original Author Unknown
00DECD  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DECD  1               ;*		   R. K. Nordin	11/01/83
00DECD  1               
00DECD  1               
00DECD  1               ;LOG	=	*	;entry
00DECD  1               
00DECD  1  A9 01        	LDA	#1	;indicate base e logarithm
00DECF  1  D0 02        	BNE	LOGS	;compute logartihm, return
00DED1  1               ;	SPACE	4,10
00DED1  1               	FIX	LOG10
00DED1  1               ;	SPACE	4,10
00DED1  1               ;**	LOG10 - Compute Base 10 Logarithm
00DED1  1               ;*
00DED1  1               ;*	ENTRY	JSR	LOG10
00DED1  1               ;*		FR0 - FR0+5 = argument
00DED1  1               ;*
00DED1  1               ;*	MODS
00DED1  1               ;*		Original Author Unknown
00DED1  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DED1  1               ;*		   R. K. Nordin	11/01/83
00DED1  1               
00DED1  1               
00DED1  1               ;LOG10	=	*	;entry
00DED1  1               
00DED1  1  A9 00        	LDA	#0	;indicate base 10 logartihm
00DED3  1               ;	JMP	LOGS	;compute logarithm, return
00DED3  1               ;	SPACE	4,10
00DED3  1               ;**	LOGS - Compute Logarithm
00DED3  1               ;*
00DED3  1               ;*	ENTRY	JSR	LOGS
00DED3  1               ;*		A = 0, if base 10 logarithm
00DED3  1               ;*		  = 1, if base e logartihm
00DED3  1               ;*		FR0 - FR0+5 = argument
00DED3  1               ;*
00DED3  1               ;*	EXIT
00DED3  1               ;*		C set, if error
00DED3  1               ;*		C clear, if no error
00DED3  1               ;*		FR0 - FR0+5 = result
00DED3  1               ;*
00DED3  1               ;*	MODS
00DED3  1               ;*		Original Author Unknown
00DED3  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DED3  1               ;*		   R. K. Nordin	11/01/83
00DED3  1               
00DED3  1               
00DED3  1               LOGS	=	*	;entry
00DED3  1               
00DED3  1               ;	Initialize.
00DED3  1               
00DED3  1  85 F0        	STA	SGNFLG	;save logarithm base indicator
00DED5  1               
00DED5  1               ;	Check argument.
00DED5  1               
00DED5  1  A5 D4        	LDA	FR0	;argument exponent
00DED7  1  F0 05        	BEQ	LOGS1	;if argument zero, error
00DED9  1               
00DED9  1  30 03        	BMI	LOGS1	;if argument negative, error
00DEDB  1               
00DEDB  1               ;	X = F*(10^Y), 1<F<10
00DEDB  1               ;	10^Y HAS SAME EXP BYTE AS X
00DEDB  1               ;	& MANTISSA BYTE = 1 OR 10
00DEDB  1               
00DEDB  1  4C F6 DF     	JMP	LOGQ
00DEDE  1               
00DEDE  1               ;	Return error.
00DEDE  1               
00DEDE  1  38           LOGS1	SEC		;indicate error
00DEDF  1  60           	RTS		;return
00DEE0  1               ;	SPACE	4,10
00DEE0  1               ;**	LOGC - Complete Computation of Logarithm
00DEE0  1               ;*
00DEE0  1               ;*	ENTRY	JSR	LOGC
00DEE0  1               ;*		SGNFLG = 0, if base 10 logarithmr
00DEE0  1               ;*		       = 1, if base e logarithm
00DEE0  1               ;*
00DEE0  1               ;*	NOTES
00DEE0  1               ;*		Problem: logic is convoluted because LOGQ code
00DEE0  1               ;*		was moved.
00DEE0  1               ;*
00DEE0  1               ;*	MODS
00DEE0  1               ;*		Original Author Unknown
00DEE0  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DEE0  1               ;*		   R. K. Nordin	11/01/83
00DEE0  1               
00DEE0  1               
00DEE0  1               LOGC	=	*		;entry
00DEE0  1               
00DEE0  1               ;	Initialize.
00DEE0  1               
00DEE0  1  E9 40        	SBC	#$40
00DEE2  1  0A           	ASL	A
00DEE3  1  85 F1        	STA	XFMFLG		;save Y
00DEE5  1  A5 D5        	LDA	FR0+1
00DEE7  1  29 F0        	AND	#$F0
00DEE9  1  D0 04        	BNE	LOGC2
00DEEB  1               
00DEEB  1  A9 01        	LDA	#1		;mantissa is 1
00DEED  1  D0 04        	BNE	LOGC3		;set mantissa
00DEEF  1               
00DEEF  1  E6 F1        LOGC2	INC	XFMFLG		;increment Y
00DEF1  1  A9 10        	LDA	#$10		;mantissa is 10
00DEF3  1               
00DEF3  1  85 E1        LOGC3	STA	FR1M		;mantissa
00DEF5  1  A2 04        	LDX	#FMPREC-1	;offset to last byte of mantissa
00DEF7  1  A9 00        	LDA	#0
00DEF9  1               
00DEF9  1  95 E2        LOGC4	STA	FR1M+1,X	;zero byte of mantissa
00DEFB  1  CA           	DEX
00DEFC  1  10 FB        	BPL	LOGC4		;if not done
00DEFE  1               
00DEFE  1  20 28 DB     	JSR	FDIV		;X = X/(10^Y), S.B. IN (1,10)
00DF01  1               
00DF01  1               ;	Compute LOG10(X), 1 <= X <= 10.
00DF01  1               
00DF01  1  A2 66        	LDX	#low SQR10
00DF03  1  A0 DF        	LDY	#high SQR10
00DF05  1  20 95 DE     	JSR	XFORM		;Z = (X-C)/(X+C); C*C = 10
00DF08  1  A2 E6        	LDX	#low FPSCR
00DF0A  1  A0 05        	LDY	#high FPSCR
00DF0C  1  20 A7 DD     	JSR	FST0R		;SAVE Z
00DF0F  1  20 B6 DD     	JSR	FMOVE
00DF12  1  20 DB DA     	JSR	FMUL		;Z*Z
00DF15  1  A9 0A        	LDA	#NLCOEF
00DF17  1  A2 72        	LDX	#low LGCOEF
00DF19  1  A0 DF        	LDY	#high LGCOEF
00DF1B  1  20 40 DD     	JSR	PLYEVL		;P(Z*Z)
00DF1E  1  A2 E6        	LDX	#low FPSCR
00DF20  1  A0 05        	LDY	#high FPSCR
00DF22  1  20 98 DD     	JSR	FLD1R		;load FR1
00DF25  1  20 DB DA     	JSR	FMUL		;Z*P(Z*Z)
00DF28  1  A2 6C        	LDX	#low FHALF
00DF2A  1  A0 DF        	LDY	#high FHALF
00DF2C  1  20 98 DD     	JSR	FLD1R
00DF2F  1  20 66 DA     	JSR	FADD		;0.5 + Z*P(Z*Z)
00DF32  1  20 B6 DD     	JSR	FMOVE
00DF35  1  A9 00        	LDA	#0
00DF37  1  85 D5        	STA	FR0+1
00DF39  1  A5 F1        	LDA	XFMFLG
00DF3B  1  85 D4        	STA	FR0
00DF3D  1  10 07        	BPL	LOGC5
00DF3F  1               
00DF3F  1  49 FF        	EOR	#<-$01		;complement sign
00DF41  1  18           	CLC
00DF42  1  69 01        	ADC	#1
00DF44  1  85 D4        	STA	FR0
00DF46  1               
00DF46  1  20 AA D9     LOGC5	JSR	IFP		;convert integer to floating point
00DF49  1  24 F1        	BIT	XFMFLG
00DF4B  1  10 06        	BPL	LOGC6
00DF4D  1               
00DF4D  1  A9 80        	LDA	#$80
00DF4F  1  05 D4        	ORA	FR0
00DF51  1  85 D4        	STA	FR0		;update exponent
00DF53  1               
00DF53  1  20 66 DA     LOGC6	JSR	FADD		;LOG(X) = LOG(X)+Y
00DF56  1               
00DF56  1               ;	Check base of logarithm.
00DF56  1               
00DF56  1  A5 F0        	LDA	SGNFLG		;logarithm base indicator
00DF58  1  F0 0A        	BEQ	LOGC7		;if LOG10 (not LOG)
00DF5A  1               
00DF5A  1               ;	Compute base e logarithm.
00DF5A  1               
00DF5A  1  A2 89        	LDX	#low LOG10E	;base 10 logarithm of e
00DF5C  1  A0 DE        	LDY	#high LOG10E
00DF5E  1  20 98 DD     	JSR	FLD1R		;load FR1
00DF61  1  20 28 DB     	JSR	FDIV		;result is LOG(X) divided by LOG10(e)
00DF64  1               
00DF64  1               ;	Exit.
00DF64  1               
00DF64  1  18           LOGC7	CLC			;indicate success
00DF65  1  60           	RTS			;return
00DF66  1               ;	SPACE	4,10
00DF66  1               ;**	SQR10 - Square Root of 10
00DF66  1               
00DF66  1               
00DF66  1  40 03 16 22  SQR10	DB	$40,$03,$16,$22,$77,$66	;square root of 10
00DF6A  1  77 66        
00DF6C  1               ;	SPACE	4,10
00DF6C  1               ;**	FHALF - 0.5
00DF6C  1               
00DF6C  1               
00DF6C  1  3F 50 00 00  FHALF	DB	$3F,$50,$00,$00,$00,$00	;0.5
00DF70  1  00 00        
00DF72  1               ;	SPACE	4,10
00DF72  1               ;**	LGCOEF - Logartihm Coefficients
00DF72  1               
00DF72  1               
00DF72  1  3F 49 15 57  LGCOEF	DB	$3F,$49,$15,$57,$11,$08	;0.4915571108
00DF76  1  11 08 BF 51  
00DF7A  1  70 49 47 08  
00DFAE  1               	DB	$BF,$51,$70,$49,$47,$08	;-0.5170494708
00DFAE  1               	DB	$3F,$39,$20,$57,$61,$95	;0.3920576195
00DFAE  1               	DB	$BF,$04,$39,$63,$03,$55	;-0.0439630355
00DFAE  1               	DB	$3F,$10,$09,$30,$12,$64	;0.1009301264
00DFAE  1               	DB	$3F,$09,$39,$08,$04,$60	;0.0939080460
00DFAE  1               	DB	$3F,$12,$42,$58,$47,$42	;0.1242584742
00DFAE  1               	DB	$3F,$17,$37,$12,$06,$08	;0.1737120608
00DFAE  1               	DB	$3F,$28,$95,$29,$71,$17	;0.2895297117
00DFAE  1               	DB	$3F,$86,$85,$88,$96,$44	;0.8685889644
00DFAE  1               
00DFAE  1               NLCOEF	=	(*-LGCOEF)/FPREC
00DFAE  1               ;	SPACE	4,10
00DFAE  1               ;**	ATCOEF - Arctangent Coefficients
00DFAE  1               ;*
00DFAE  1               ;*	NOTES
00DFAE  1               ;*		Problem: not used.
00DFAE  1               
00DFAE  1               
00DFAE  1  3E 16 05 44  	DB	$3E,$16,$05,$44,$49,$00	;0.001605444900
00DFB2  1  49 00 BE 95  
00DFB6  1  68 38 45 00  
00DFF0  1               	DB	$BE,$95,$68,$38,$45,$00	;-0.009568384500
00DFF0  1               	DB	$3F,$02,$68,$79,$94,$16	;0.0268799416
00DFF0  1               	DB	$BF,$04,$92,$78,$90,$80	;-0.0492789080
00DFF0  1               	DB	$3F,$07,$03,$15,$20,$00	;0.0703152000
00DFF0  1               	DB	$BF,$08,$92,$29,$12,$44	;-0.0892291244
00DFF0  1               	DB	$3F,$11,$08,$40,$09,$11	;0.1108400911
00DFF0  1               	DB	$BF,$14,$28,$31,$56,$04	;-0.1428315604
00DFF0  1               	DB	$3F,$19,$99,$98,$77,$44	;0.1999987744
00DFF0  1               	DB	$BF,$33,$33,$33,$31,$13	;-0.3333333113
00DFF0  1               	DB	$3F,$99,$99,$99,$99,$99	;0.9999999999
00DFF0  1               
00DFF0  1  3F 78 53 98  	DB	$3F,$78,$53,$98,$16,$34	;pi/4 = arctan 1
00DFF4  1  16 34        
00DFF6  1               ;	SPACE	4,10
00DFF6  1               ;**	LOGQ - Continue Computation of Loagarithm
00DFF6  1               ;*
00DFF6  1               ;*	ENTRY	JSR	LOGQ
00DFF6  1               ;*
00DFF6  1               ;*	NOTES
00DFF6  1               ;*		Problem: logic is convoluted because this code was
00DFF6  1               ;*		moved.
00DFF6  1               ;*		Problem: for readability, this might be relocated
00DFF6  1               ;*		before tables.
00DFF6  1               ;*
00DFF6  1               ;*	MODS
00DFF6  1               ;*		Original Author Unknown
00DFF6  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00DFF6  1               ;*		   R. K. Nordin	11/01/83
00DFF6  1               
00DFF6  1               
00DFF6  1               LOGQ	=	*	;entry
00DFF6  1  A5 D4        	LDA	FR0
00DFF8  1  85 E0        	STA	FR1
00DFFA  1  38           	SEC
00DFFB  1  4C E0 DE     	JMP	LOGC	;complete computation of logarithm, return
00DFFE  1               ;	SUBTTL	'Domestic Character Set'
00DFFE  1               ;	SPACE	4,10
00DFFE  1  00 00        	FIX	DCSORG
00E000  1               ;	SPACE	4,10
00E000  1               ;**	Domestic Character Set
00E000  1               
00E000  1               
00E000  1  00 00 00 00  	DB	$00,$00,$00,$00,$00,$00,$00,$00	;$00 - space
00E004  1  00 00 00 00  
00E008  1  00 18 18 18  
00E080  1               	DB	$00,$18,$18,$18,$18,$00,$18,$00	;$01 - !
00E080  1               	DB	$00,$66,$66,$66,$00,$00,$00,$00	;$02 - "
00E080  1               	DB	$00,$66,$FF,$66,$66,$FF,$66,$00	;$03 - #
00E080  1               	DB	$18,$3E,$60,$3C,$06,$7C,$18,$00	;$04 - $
00E080  1               	DB	$00,$66,$6C,$18,$30,$66,$46,$00	;$05 - %
00E080  1               	DB	$1C,$36,$1C,$38,$6F,$66,$3B,$00	;$06 - &
00E080  1               	DB	$00,$18,$18,$18,$00,$00,$00,$00	;$07 - '
00E080  1               	DB	$00,$0E,$1C,$18,$18,$1C,$0E,$00	;$08 - (
00E080  1               	DB	$00,$70,$38,$18,$18,$38,$70,$00	;$09 - )
00E080  1               	DB	$00,$66,$3C,$FF,$3C,$66,$00,$00	;$0A - asterisk
00E080  1               	DB	$00,$18,$18,$7E,$18,$18,$00,$00	;$0B - plus
00E080  1               	DB	$00,$00,$00,$00,$00,$18,$18,$30	;$0C - comma
00E080  1               	DB	$00,$00,$00,$7E,$00,$00,$00,$00	;$0D - minus
00E080  1               	DB	$00,$00,$00,$00,$00,$18,$18,$00	;$0E - period
00E080  1               	DB	$00,$06,$0C,$18,$30,$60,$40,$00	;$0F - /
00E080  1               
00E080  1  00 3C 66 6E  	DB	$00,$3C,$66,$6E,$76,$66,$3C,$00	;$10 - 0
00E084  1  76 66 3C 00  
00E088  1  00 18 38 18  
00E100  1               	DB	$00,$18,$38,$18,$18,$18,$7E,$00	;$11 - 1
00E100  1               	DB	$00,$3C,$66,$0C,$18,$30,$7E,$00	;$12 - 2
00E100  1               	DB	$00,$7E,$0C,$18,$0C,$66,$3C,$00	;$13 - 3
00E100  1               	DB	$00,$0C,$1C,$3C,$6C,$7E,$0C,$00	;$14 - 4
00E100  1               	DB	$00,$7E,$60,$7C,$06,$66,$3C,$00	;$15 - 5
00E100  1               	DB	$00,$3C,$60,$7C,$66,$66,$3C,$00	;$16 - 6
00E100  1               	DB	$00,$7E,$06,$0C,$18,$30,$30,$00	;$17 - 7
00E100  1               	DB	$00,$3C,$66,$3C,$66,$66,$3C,$00	;$18 - 8
00E100  1               	DB	$00,$3C,$66,$3E,$06,$0C,$38,$00	;$19 - 9
00E100  1               	DB	$00,$00,$18,$18,$00,$18,$18,$00	;$1A - colon
00E100  1               	DB	$00,$00,$18,$18,$00,$18,$18,$30	;$1B - semicolon
00E100  1               	DB	$06,$0C,$18,$30,$18,$0C,$06,$00	;$1C - <
00E100  1               	DB	$00,$00,$7E,$00,$00,$7E,$00,$00	;$1D - =
00E100  1               	DB	$60,$30,$18,$0C,$18,$30,$60,$00	;$1E - >
00E100  1               	DB	$00,$3C,$66,$0C,$18,$00,$18,$00	;$1F - ?
00E100  1               
00E100  1  00 3C 66 6E  	DB	$00,$3C,$66,$6E,$6E,$60,$3E,$00	;$20 - @
00E104  1  6E 60 3E 00  
00E108  1  00 18 3C 66  
00E180  1               	DB	$00,$18,$3C,$66,$66,$7E,$66,$00	;$21 - A
00E180  1               	DB	$00,$7C,$66,$7C,$66,$66,$7C,$00	;$22 - B
00E180  1               	DB	$00,$3C,$66,$60,$60,$66,$3C,$00	;$23 - C
00E180  1               	DB	$00,$78,$6C,$66,$66,$6C,$78,$00	;$24 - D
00E180  1               	DB	$00,$7E,$60,$7C,$60,$60,$7E,$00	;$25 - E
00E180  1               	DB	$00,$7E,$60,$7C,$60,$60,$60,$00	;$26 - F
00E180  1               	DB	$00,$3E,$60,$60,$6E,$66,$3E,$00	;$27 - G
00E180  1               	DB	$00,$66,$66,$7E,$66,$66,$66,$00	;$28 - H
00E180  1               	DB	$00,$7E,$18,$18,$18,$18,$7E,$00	;$29 - I
00E180  1               	DB	$00,$06,$06,$06,$06,$66,$3C,$00	;$2A - J
00E180  1               	DB	$00,$66,$6C,$78,$78,$6C,$66,$00	;$2B - K
00E180  1               	DB	$00,$60,$60,$60,$60,$60,$7E,$00	;$2C - L
00E180  1               	DB	$00,$63,$77,$7F,$6B,$63,$63,$00	;$2D - M
00E180  1               	DB	$00,$66,$76,$7E,$7E,$6E,$66,$00	;$2E - N
00E180  1               	DB	$00,$3C,$66,$66,$66,$66,$3C,$00	;$2F - O
00E180  1               
00E180  1  00 7C 66 66  	DB	$00,$7C,$66,$66,$7C,$60,$60,$00	;$30 - P
00E184  1  7C 60 60 00  
00E188  1  00 3C 66 66  
00E200  1               	DB	$00,$3C,$66,$66,$66,$6C,$36,$00	;$31 - Q
00E200  1               	DB	$00,$7C,$66,$66,$7C,$6C,$66,$00	;$32 - R
00E200  1               	DB	$00,$3C,$60,$3C,$06,$06,$3C,$00	;$33 - S
00E200  1               	DB	$00,$7E,$18,$18,$18,$18,$18,$00	;$34 - T
00E200  1               	DB	$00,$66,$66,$66,$66,$66,$7E,$00	;$35 - U
00E200  1               	DB	$00,$66,$66,$66,$66,$3C,$18,$00	;$36 - V
00E200  1               	DB	$00,$63,$63,$6B,$7F,$77,$63,$00	;$37 - W
00E200  1               	DB	$00,$66,$66,$3C,$3C,$66,$66,$00	;$38 - X
00E200  1               	DB	$00,$66,$66,$3C,$18,$18,$18,$00	;$39 - Y
00E200  1               	DB	$00,$7E,$0C,$18,$30,$60,$7E,$00	;$3A - Z
00E200  1               	DB	$00,$1E,$18,$18,$18,$18,$1E,$00	;$3B - [
00E200  1               	DB	$00,$40,$60,$30,$18,$0C,$06,$00	;$3C - \
00E200  1               	DB	$00,$78,$18,$18,$18,$18,$78,$00	;$3D - ]
00E200  1               	DB	$00,$08,$1C,$36,$63,$00,$00,$00	;$3E - ^
00E200  1               	DB	$00,$00,$00,$00,$00,$00,$FF,$00	;$3F - underline
00E200  1               
00E200  1  00 36 7F 7F  	DB	$00,$36,$7F,$7F,$3E,$1C,$08,$00	;$40 - heart card
00E204  1  3E 1C 08 00  
00E208  1  18 18 18 1F  
00E280  1               	DB	$18,$18,$18,$1F,$1F,$18,$18,$18	;$41 - mid left window
00E280  1               	DB	$03,$03,$03,$03,$03,$03,$03,$03	;$42 - right box
00E280  1               	DB	$18,$18,$18,$F8,$F8,$00,$00,$00	;$43 - low right window
00E280  1               	DB	$18,$18,$18,$F8,$F8,$18,$18,$18	;$44 - mid right window
00E280  1               	DB	$00,$00,$00,$F8,$F8,$18,$18,$18	;$45 - up right window
00E280  1               	DB	$03,$07,$0E,$1C,$38,$70,$E0,$C0	;$46 - right slant box
00E280  1               	DB	$C0,$E0,$70,$38,$1C,$0E,$07,$03	;$47 - left slant box
00E280  1               	DB	$01,$03,$07,$0F,$1F,$3F,$7F,$FF	;$48 - right slant solid
00E280  1               	DB	$00,$00,$00,$00,$0F,$0F,$0F,$0F	;$49 - low right solid
00E280  1               	DB	$80,$C0,$E0,$F0,$F8,$FC,$FE,$FF	;$4A - left slant solid
00E280  1               	DB	$0F,$0F,$0F,$0F,$00,$00,$00,$00	;$4B - up right solid
00E280  1               	DB	$F0,$F0,$F0,$F0,$00,$00,$00,$00	;$4C - up left solid
00E280  1               	DB	$FF,$FF,$00,$00,$00,$00,$00,$00	;$4D - top box
00E280  1               	DB	$00,$00,$00,$00,$00,$00,$FF,$FF	;$4E - bottom box
00E280  1               	DB	$00,$00,$00,$00,$F0,$F0,$F0,$F0	;$4F - low left solid
00E280  1               
00E280  1  00 1C 1C 77  	DB	$00,$1C,$1C,$77,$77,$08,$1C,$00	;$50 - club card
00E284  1  77 08 1C 00  
00E288  1  00 00 00 1F  
00E300  1               	DB	$00,$00,$00,$1F,$1F,$18,$18,$18	;$51 - up left window
00E300  1               	DB	$00,$00,$00,$FF,$FF,$00,$00,$00	;$52 - mid box
00E300  1               	DB	$18,$18,$18,$FF,$FF,$18,$18,$18	;$53 - mid window
00E300  1               	DB	$00,$00,$3C,$7E,$7E,$7E,$3C,$00	;$54 - solid circle
00E300  1               	DB	$00,$00,$00,$00,$FF,$FF,$FF,$FF	;$55 - bottom solid
00E300  1               	DB	$C0,$C0,$C0,$C0,$C0,$C0,$C0,$C0	;$56 - left box
00E300  1               	DB	$00,$00,$00,$FF,$FF,$18,$18,$18	;$57 - up mid window
00E300  1               	DB	$18,$18,$18,$FF,$FF,$00,$00,$00	;$58 - low mid window
00E300  1               	DB	$F0,$F0,$F0,$F0,$F0,$F0,$F0,$F0	;$59 - left solid
00E300  1               	DB	$18,$18,$18,$1F,$1F,$00,$00,$00	;$5A - low left window
00E300  1               	DB	$78,$60,$78,$60,$7E,$18,$1E,$00	;$5B - display escape
00E300  1               	DB	$00,$18,$3C,$7E,$18,$18,$18,$00	;$5C - up arrow
00E300  1               	DB	$00,$18,$18,$18,$7E,$3C,$18,$00	;$5D - down arrow
00E300  1               	DB	$00,$18,$30,$7E,$30,$18,$00,$00	;$5E - left arrow
00E300  1               	DB	$00,$18,$0C,$7E,$0C,$18,$00,$00	;$5F - right arrow
00E300  1               
00E300  1  00 18 3C 7E  	DB	$00,$18,$3C,$7E,$7E,$3C,$18,$00	;$60 - diamond card
00E304  1  7E 3C 18 00  
00E308  1  00 00 3C 06  
00E380  1               	DB	$00,$00,$3C,$06,$3E,$66,$3E,$00	;$61 - a
00E380  1               	DB	$00,$60,$60,$7C,$66,$66,$7C,$00	;$62 - b
00E380  1               	DB	$00,$00,$3C,$60,$60,$60,$3C,$00	;$63 - c
00E380  1               	DB	$00,$06,$06,$3E,$66,$66,$3E,$00	;$64 - d
00E380  1               	DB	$00,$00,$3C,$66,$7E,$60,$3C,$00	;$65 - e
00E380  1               	DB	$00,$0E,$18,$3E,$18,$18,$18,$00	;$66 - f
00E380  1               	DB	$00,$00,$3E,$66,$66,$3E,$06,$7C	;$67 - g
00E380  1               	DB	$00,$60,$60,$7C,$66,$66,$66,$00	;$68 - h
00E380  1               	DB	$00,$18,$00,$38,$18,$18,$3C,$00	;$69 - i
00E380  1               	DB	$00,$06,$00,$06,$06,$06,$06,$3C	;$6A - j
00E380  1               	DB	$00,$60,$60,$6C,$78,$6C,$66,$00	;$6B - k
00E380  1               	DB	$00,$38,$18,$18,$18,$18,$3C,$00	;$6C - l
00E380  1               	DB	$00,$00,$66,$7F,$7F,$6B,$63,$00	;$6D - m
00E380  1               	DB	$00,$00,$7C,$66,$66,$66,$66,$00	;$6E - n
00E380  1               	DB	$00,$00,$3C,$66,$66,$66,$3C,$00	;$6F - o
00E380  1               
00E380  1  00 00 7C 66  	DB	$00,$00,$7C,$66,$66,$7C,$60,$60	;$70 - p
00E384  1  66 7C 60 60  
00E388  1  00 00 3E 66  
00E400  1               	DB	$00,$00,$3E,$66,$66,$3E,$06,$06	;$71 - q
00E400  1               	DB	$00,$00,$7C,$66,$60,$60,$60,$00	;$72 - r
00E400  1               	DB	$00,$00,$3E,$60,$3C,$06,$7C,$00	;$73 - s
00E400  1               	DB	$00,$18,$7E,$18,$18,$18,$0E,$00	;$74 - t
00E400  1               	DB	$00,$00,$66,$66,$66,$66,$3E,$00	;$75 - u
00E400  1               	DB	$00,$00,$66,$66,$66,$3C,$18,$00	;$76 - v
00E400  1               	DB	$00,$00,$63,$6B,$7F,$3E,$36,$00	;$77 - w
00E400  1               	DB	$00,$00,$66,$3C,$18,$3C,$66,$00	;$78 - x
00E400  1               	DB	$00,$00,$66,$66,$66,$3E,$0C,$78	;$79 - y
00E400  1               	DB	$00,$00,$7E,$0C,$18,$30,$7E,$00	;$7A - z
00E400  1               	DB	$00,$18,$3C,$7E,$7E,$18,$3C,$00	;$7B - spade card
00E400  1               	DB	$18,$18,$18,$18,$18,$18,$18,$18	;$7C - |
00E400  1               	DB	$00,$7E,$78,$7C,$6E,$66,$06,$00	;$7D - display clear
00E400  1               	DB	$08,$18,$38,$78,$38,$18,$08,$00	;$7E - display backspace
00E400  1               	DB	$10,$18,$1C,$1E,$1C,$18,$10,$00	;$7F - display tab
00E400  1               ;	SUBTTL	'Device Handler Vector Tables'
00E400  1               ;	SPACE	4,10
00E400  1               	FIX	EDITRV
00E400  1               ;	SPACE	4,10
00E400  1               ;**	EDITRV - Editor Handler Vector Table
00E400  1               
00E400  1               
00E400  1  93 EF 2D F2  	DW	EOP-1	;perform editor OPEN
00E404  1  49 F2 AF F2  
00E408  1  1D F2 2C F2  
00E40C  1               	DW	ECL-1	;perform editor CLOSE
00E40C  1               	DW	EGB-1	;perform editor GET-BYTE
00E40C  1               	DW	EPB-1	;perform editor PUT-BYTE
00E40C  1               	DW	SST-1	;perform editor STATUS (screen STAT:
00E40C  1               	DW	ESP-1	;perform editor SPECIAL
00E40C  1  4C 6E EF 00  	JMP	SIN	;initialize editor (initialize scre:
00E410  1               	DB	0	;reserved
00E410  1               ;	SPACE	4,10
00E410  1               	FIX	SCRENV
00E410  1               ;	SPACE	4,10
00E410  1               ;**	SCRENV - Screen Handler Vector Table
00E410  1               
00E410  1               
00E410  1  8D EF 2D F2  	DW	SOP-1	;perform screen OPEN
00E414  1  7F F1 A3 F1  
00E418  1  1D F2 AE F9  
00E41C  1               	DW	ECL-1	;perform screen CLOSE (editor CLOSE:
00E41C  1               	DW	SGB-1	;perform screen GET-BYTE
00E41C  1               	DW	SPB-1	;perform screen PUT-BYTE
00E41C  1               	DW	SST-1	;perform screen STATUS
00E41C  1               	DW	SSP-1	;perform screen SPECIAL
00E41C  1  4C 6E EF 00  	JMP	SIN	;initialize screen
00E420  1               	DB	0	;reserved
00E420  1               ;	SPACE	4,10
00E420  1               	FIX	KEYBDV
00E420  1               ;	SPACE	4,10
00E420  1               ;**	KEYBDV - Keyboard Handler Vector Table
00E420  1               
00E420  1               
00E420  1  1D F2 1D F2  	DW	SST-1	;perform keyboard OPEN (screen STAT:
00E424  1  FC F2 2C F2  
00E428  1  1D F2 2C F2  
00E42C  1               	DW	SST-1	;perform keyboard CLOSE (screen STA:
00E42C  1               	DW	KGB-1	;perform keyboard GET-BYTE
00E42C  1               	DW	ESP-1	;perform keyboard SPECIAL (editor S:
00E42C  1               	DW	SST-1	;perform keyboard STATUS (screen ST:
00E42C  1               	DW	ESP-1	;perform keyboard SPECIAL (editor S:
00E42C  1  4C 6E EF 00  	JMP	SIN	;initialize keyboard (initialize sc:
00E430  1               	DB	0	;reserved
00E430  1               ;	SPACE	4,10
00E430  1               	FIX	PRINTV
00E430  1               ;	SPACE	4,10
00E430  1               ;**	PRINTV - Printer Handler Vector Table
00E430  1               
00E430  1               
00E430  1  C1 FE 06 FF  	DW	POP-1	;perform printer OPEN
00E434  1  C0 FE CA FE  
00E438  1  A2 FE C0 FE  
00E43C  1               	DW	PCL-1	;perform printer CLOSE
00E43C  1               	DW	PSP-1	;perform printer SPECIAL
00E43C  1               	DW	PPB-1	;perform printer PUT-BYTE
00E43C  1               	DW	PST-1	;perform printer STATUS
00E43C  1               	DW	PSP-1	;perform printer SPECIAL
00E43C  1  4C 99 FE 00  	JMP	PIN	;initialize printer
00E440  1               	DB	0	;reserved
00E440  1               ;	SPACE	4,10
00E440  1               	FIX	CASETV
00E440  1               ;	SPACE	4,10
00E440  1               ;**	CASETV - Cassette Handler Vector Table
00E440  1               
00E440  1               
00E440  1  E5 FC CE FD  	DW	COP-1	;perform cassette OPEN
00E444  1  79 FD B3 FD  
00E448  1  CB FD E4 FC  
00E44C  1               	DW	CCL-1	;perform cassette CLOSE
00E44C  1               	DW	CGB-1	;perform cassette GET-BYTE
00E44C  1               	DW	CPB-1	;perform cassette PUT-BYTE
00E44C  1               	DW	CST-1	;perform cassette STATUS
00E44C  1               	DW	CSP-1	;perform cassette SPECIAL
00E44C  1  4C DB FC 00  	JMP	CIN	;initialize cassette
00E450  1               	DB	0	;reserved
00E450  1               	SUBTTL	'Jump Vectors'
00E450  1               ;	SPACE	4,10
00E450  1               ;**	Jump Vectors
00E450  1               
00E450  1               
00E450  1               	FIX	DINITV
00E450  1  4C A3 C6     	JMP	IDIO	;initialize DIO
00E453  1               
00E453  1               	FIX	DSKINV
00E453  1  4C B3 C6     	JMP	DIO	;perform DIO
00E456  1               
00E456  1               	FIX	CIOV
00E456  1  4C DF E4     	JMP	CIO	;perform CIO
00E459  1               
00E459  1               	FIX	SIOV
00E459  1  4C 33 C9     	JMP	PIO	;perform PIO
00E45C  1               
00E45C  1               	FIX	SETVBV
00E45C  1  4C 72 C2     	JMP	SVP	;set VBLANK parameters
00E45F  1               
00E45F  1               	FIX	SYSVBV
00E45F  1  4C E2 C0     	JMP	IVNM	;process immediate VBLANK NMI
00E462  1               
00E462  1               	FIX	XITVBV
00E462  1  4C 8A C2     	JMP	DVNM	;process deferred VBLANK NMI
00E465  1               
00E465  1               	FIX	SIOINV
00E465  1  4C 5C E9     	JMP	ISIO	;initialize SIO
00E468  1               
00E468  1               	FIX	SENDEV
00E468  1  4C 17 EC     	JMP	ESS	;enable SIO SEND
00E46B  1               
00E46B  1               	FIX	INTINV
00E46B  1  4C 0C C0     	JMP	IIH	;initialize interrupt handler
00E46E  1               
00E46E  1               	FIX	CIOINV
00E46E  1  4C C1 E4     	JMP	ICIO	;initialize CIO
00E471  1               
00E471  1               	FIX	BLKBDV
00E471  1  4C 23 F2     	JMP	PPD	;perform power-up display
00E474  1               
00E474  1               	FIX	WARMSV
00E474  1  4C 90 C2     	JMP	PWS	;perform warmstart
00E477  1               
00E477  1               	FIX	COLDSV
00E477  1  4C C8 C2     	JMP	PCS	;perform coldstart
00E47A  1               
00E47A  1               	FIX	RBLOKV
00E47A  1  4C 8D FD             JMP     RCB	;read cassette block
00E47D  1               
00E47D  1               	FIX	CSOPIV
00E47D  1  4C F7 FC             JMP     OCI	;open cassette for input
00E480  1               
00E480  1               	FIX	PUPDIV
00E480  1  4C 23 F2     	JMP	PPD	;perform power-up display
00E483  1               
00E483  1               	FIX	SLFTSV
00E483  1  4C 00 50     	JMP	STH	;self-test hardware
00E486  1               
00E486  1               	FIX	PHENTV
00E486  1  4C BC EE     	JMP	PHE	;perform peripheral handler entry
00E489  1               
00E489  1               	FIX	PHUNLV
00E489  1  4C 15 E9     	JMP	PHU	;perform peripheral handler unlinking
00E48C  1               
00E48C  1               	FIX	PHINIV
00E48C  1  4C 98 E8     	JMP	PHI	;perform peripheral handler initialization
00E48F  1               	SUBTTL	'Generic Parallel Device Handler Vector Table'
00E48F  1               ;	SPACE	4,10
00E48F  1               	FIX	GPDVV
00E48F  1               ;	SPACE	4,10
00E48F  1               ;**	GPDVV - Generic Parallel Device Handler Vector Table
00E48F  1               
00E48F  1               
00E48F  1  90 C9 95 C9  	DW	GOP-1	;perform generic parallel device OPEN
00E493  1  9A C9 9F C9  
00E497  1  A4 C9 A9 C9  
00E49B  1               	DW	GCL-1	;perform generic parallel device CLOSE
00E49B  1               	DW	GGB-1	;perform generic parallel device GET-BYTE
00E49B  1               	DW	GPB-1	;perform generic parallel device PUT-BYTE
00E49B  1               	DW	GST-1	;perform generic parallel device STATUS
00E49B  1               	DW	GSP-1	;perform generic parallel device SPECIAL
00E49B  1  4C 0C C9     	JMP	GIN	;initialize generic parallel device
00E49E  1               ;	SUBTTL	'$E4C0 Patch'
00E49E  1               ;	SPACE	4,10
00E49E  1  00 00 00 00  	FIX	$E4C0
00E4A2  1  00 00 00 00  
00E4A6  1  00 00 00 00  
00E4C0  1               ;	SPACE	4,10
00E4C0  1               ;**	E4C0 - $E4C0 Patch
00E4C0  1               ;*
00E4C0  1               ;*	For compatibility with OS Revision B, return.
00E4C0  1               
00E4C0  1               
00E4C0  1  60           	RTS		;return
00E4C1  1               ;	SUBTTL	'Central Input/Output'
00E4C1  1               ;	SPACE	4,10
00E4C1  1               ;**	ICIO - Initialize CIO
00E4C1  1               ;*
00E4C1  1               ;*	ENTRY	JSR	ICIO
00E4C1  1               ;*
00E4C1  1               ;*	MODS
00E4C1  1               ;*		Original Author Unknown
00E4C1  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00E4C1  1               ;*		   R. K. Nordin	11/01/83
00E4C1  1               
00E4C1  1               
00E4C1  1               ICIO	=	*		;entry
00E4C1  1               
00E4C1  1               ;	Initialize IOCB's.
00E4C1  1               
00E4C1  1  A2 00        	LDX	#0		;index of first IOCB
00E4C3  1               
00E4C3  1  A9 FF        ICIO1	LDA	#IOCFRE		;IOCB free indicator
00E4C5  1  9D 40 03     	STA	ICHID,X		;set IOCB free
00E4C8  1  A9 DB        	LDA	#low (IIN-1)
00E4CA  1  9D 46 03     	STA	ICPTL,X		;initialize PUT-BYTE routine address
00E4CD  1  A9 E4        	LDA	#high (IIN-1)
00E4CF  1  9D 47 03     	STA	ICPTH,X
00E4D2  1  8A           	TXA			;index of current IOCB
00E4D3  1  18           	CLC
00E4D4  1  69 10        	ADC	#IOCBSZ		;add IOCB size
00E4D6  1  AA           	TAX			;index of next IOCB
00E4D7  1  C9 80        	CMP	#MAXIOC		;index of first invalid IOCB
00E4D9  1  90 E8        	BCC	ICIO1		;if not done
00E4DB  1               
00E4DB  1  60           	RTS			;return
00E4DC  1               ;	SPACE	4,10
00E4DC  1               ;**	IIN - Indicate IOCB Not Open Error
00E4DC  1               ;*
00E4DC  1               ;*	ENTRY	JSR	IIN
00E4DC  1               ;*
00E4DC  1               ;*	EXIT
00E4DC  1               ;*		Y = IOCB Not Open error code
00E4DC  1               ;*
00E4DC  1               ;*	MODS
00E4DC  1               ;*		Original Author Unknown
00E4DC  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00E4DC  1               ;*		   R. K. Nordin	11/01/83
00E4DC  1               
00E4DC  1               
00E4DC  1               IIN	=	*	;entry
00E4DC  1  A0 85        	LDY	#NOTOPN	;IOCB not open error
00E4DE  1  60           	RTS		;return
00E4DF  1               ;	SPACE	4,10
00E4DF  1               ;**	CIO - Central Input/Output
00E4DF  1               ;*
00E4DF  1               ;*	ENTRY	JSR	CIO
00E4DF  1               ;*
00E4DF  1               ;*	MODS
00E4DF  1               ;*		Original Author Unknown
00E4DF  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00E4DF  1               ;*		   R. K. Nordin	11/01/83
00E4DF  1               
00E4DF  1               
00E4DF  1               CIO	=	*	;entry
00E4DF  1               
00E4DF  1               ;	Initialize.
00E4DF  1               
00E4DF  1  85 2F        	STA	CIOCHR	;save possible output byte value
00E4E1  1  86 2E        	STX	ICIDNO	;save IOCB index
00E4E3  1               
00E4E3  1               ;	Check IOCB index validity.
00E4E3  1               
00E4E3  1  8A           	TXA		;IOCB index
00E4E4  1  29 0F        	AND	#$0F	;index modulo 16
00E4E6  1  D0 04        	BNE	CIO1	;if IOCB not multiple of 16, error
00E4E8  1               
00E4E8  1  E0 80        	CPX	#MAXIOC	;index of first invalid IOCB
00E4EA  1  90 05        	BCC	CIO2	;if index within range
00E4EC  1               
00E4EC  1               ;	Indicate Invalid IOCB Index error.
00E4EC  1               
00E4EC  1  A0 86        CIO1	LDY	#BADIOC	;invalid IOCB index error
00E4EE  1  4C 70 E6     	JMP	SSC	;set status and complete operation, return
00E4F1  1               
00E4F1  1               ;	Move part of IOCB to zero page IOCB.
00E4F1  1               
00E4F1  1  A0 00        CIO2	LDY	#0		;offset to first byte of page zero IOCB
00E4F3  1               
00E4F3  1  BD 40 03     CIO3	LDA	IOCB,X		;byte of IOCB
00E4F6  1  99 20 00     	STA	IOCBAS,Y	;byte of zero page IOCB
00E4F9  1  E8           	INX
00E4FA  1  C8           	INY
00E4FB  1  C0 0C        	CPY	#ICSPRZ-IOCBAS	;offset to first undesired byte
00E4FD  1  90 F4        	BCC	CIO3		;if not done
00E4FF  1               
00E4FF  1               ;	Check for provisionally open IOCB.
00E4FF  1               
00E4FF  1  A5 20        	LDA	ICHIDZ	;handler ID
00E501  1  C9 7F        	CMP	#$7F	;provisionally open indicator
00E503  1  D0 15        	BNE	PCC	;if not provisionally open, perform:
00E505  1               
00E505  1               ;	Check for CLOSE command.
00E505  1               
00E505  1  A5 22        	LDA	ICCOMZ	;command
00E507  1  C9 0C        	CMP	#CLOSE
00E509  1  F0 71        	BEQ	XCL	;if CLOSE command
00E50B  1               
00E50B  1               ;	Check handler load flag.
00E50B  1               
00E50B  1  AD E9 02     	LDA	HNDLOD
00E50E  1  D0 05        	BNE	LHO	;if handler load desired
00E510  1               
00E510  1               ;	Indicate nonexistent device error.
00E510  1               
00E510  1               ;	JMP	IND	;indicate nonexistent device error,:
00E510  1               ;	SPACE	4,10
00E510  1               ;**	IND - Indicate Nonexistent Device Error
00E510  1               ;*
00E510  1               ;*	ENTRY	JSR	IND
00E510  1               ;*
00E510  1               ;*	MODS
00E510  1               ;*		Original Author Unknown
00E510  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00E510  1               ;*		   R. K. Nordin	11/01/83
00E510  1               
00E510  1               
00E510  1               IND	=	*	;entry
00E510  1  A0 82        	LDY	#NONDEV	;nonexistent device error
00E512  1               
00E512  1  4C 70 E6     IND1	JMP	SSC	;set status and complete operation,:
00E515  1               ;	SPACE	4,10
00E515  1               ;**	LHO - Load Peripheral Handler for OPEN
00E515  1               ;*
00E515  1               ;*	ENTRY	JSR	LHO
00E515  1               ;*
00E515  1               ;*	MODS
00E515  1               ;*		Original Author Unknown
00E515  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00E515  1               ;*		   R. K. Nordin	11/01/83
00E515  1               
00E515  1               
00E515  1               LHO	=	*	;entry
00E515  1  20 29 CA     	JSR	PHL	;load and initialize peripheral han:
00E518  1  30 F8        	BMI	IND1	;if error
00E51A  1               
00E51A  1               ;	JMP	PCC	;perform CIO command, return
00E51A  1               ;	SPACE	4,10
00E51A  1               ;**	PCC - Perform CIO Command
00E51A  1               ;*
00E51A  1               ;*	ENTRY	JSR	PCC
00E51A  1               ;*
00E51A  1               ;*	MODS
00E51A  1               ;*		Original Author Unknown
00E51A  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00E51A  1               ;*		   R. K. Nordin	11/01/83
00E51A  1               
00E51A  1               
00E51A  1               PCC	=	*	;entry
00E51A  1               
00E51A  1               ;	Check command validity.
00E51A  1               
00E51A  1  A0 84        	LDY	#NVALID		;assume invalid code
00E51C  1  A5 22        	LDA	ICCOMZ		;command
00E51E  1  C9 03        	CMP	#OPEN		;first valid command
00E520  1  90 25        	BCC	XOP1		;if command invalid
00E522  1               
00E522  1  A8           	TAY			;command
00E523  1               
00E523  1  C0 0E        	CPY	#SPECIL		;last valid command
00E525  1  90 02        	BCC	PCC1		;if valid
00E527  1               
00E527  1  A0 0E        	LDY	#SPECIL		;substitute SPECIAL command
00E529  1               
00E529  1               ;	Obtain vector offset.
00E529  1               
00E529  1  84 17        PCC1	STY	ICCOMT		;save command
00E52B  1  B9 2A E7     	LDA	TCVO-3,Y	;vector offset for command
00E52E  1  F0 0F        	BEQ	XOP		;if OPEN command, process
00E530  1               
00E530  1               ;	Perform command.
00E530  1               
00E530  1  C9 02        	CMP	#2
00E532  1  F0 48        	BEQ	XCL		;if CLOSE command, process
00E534  1               
00E534  1  C9 08        	CMP	#8
00E536  1  B0 5F        	BCS	XSS		;if STATUS or SPECIAL command, process
00E538  1               
00E538  1  C9 04        	CMP	#4
00E53A  1  F0 76        	BEQ	XGT		;if GET command, process
00E53C  1               
00E53C  1  4C 1E E6     	JMP	XPT		;process PUT command, process
00E53F  1               ;	SPACE	4,10
00E53F  1               ;**	XOP - Execute OPEN Command
00E53F  1               ;*
00E53F  1               ;*	ENTRY	JSR	XOP
00E53F  1               ;*
00E53F  1               ;*	MODS
00E53F  1               ;*		Original Author Unknown
00E53F  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00E53F  1               ;*		   R. K. Nordin	11/01/83
00E53F  1               
00E53F  1               
00E53F  1               XOP	=	*	;entry
00E53F  1               
00E53F  1               ;	Check IOCB free.
00E53F  1               
00E53F  1  A5 20        	LDA	ICHIDZ	;handler ID
00E541  1  C9 FF        	CMP	#IOCFRE	;IOCB free indicator
00E543  1  F0 05        	BEQ	XOP2	;if IOCB free
00E545  1               
00E545  1               ;	Process error.
00E545  1               
00E545  1  A0 81        	LDY	#PRVOPN	;IOCB previously open error
00E547  1               
00E547  1  4C 70 E6     XOP1	JMP	SSC	;set status and complete operation, return
00E54A  1               
00E54A  1               ;	Check handler load.
00E54A  1               
00E54A  1  AD E9 02     XOP2	LDA	HNDLOD
00E54D  1  D0 27        	BNE	PPO	;if user wants unconditional poll
00E54F  1               
00E54F  1               ;	Search handler table.
00E54F  1               
00E54F  1  20 FF E6     	JSR	SHT	;search handler table
00E552  1  B0 22        	BCS	PPO	;if not found, poll
00E554  1               
00E554  1               ;	Initialize status.
00E554  1               
00E554  1  A9 00        	LDA	#0
00E556  1  8D EA 02     	STA	DVSTAT	;clear status
00E559  1  8D EB 02     	STA	DVSTAT+1
00E55C  1               
00E55C  1               ;	Initialize IOCB.
00E55C  1               
00E55C  1               ;	JMP	IIO	;initialize IOCB for OPEN, return
00E55C  1               ;	SPACE	4,10
00E55C  1               ;**	IIO - Initialize IOCB for OPEN
00E55C  1               ;*
00E55C  1               ;*	ENTRY	JSR	IIO
00E55C  1               ;*
00E55C  1               ;*	MODS
00E55C  1               ;*		Original Author Unknown
00E55C  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00E55C  1               ;*		   R. K. Nordin	11/01/83
00E55C  1               
00E55C  1               
00E55C  1               IIO	=	*	;entry
00E55C  1               
00E55C  1               ;	Compute handler entry point.
00E55C  1               
00E55C  1  20 95 E6     	JSR	CEP	;compute handler entry point
00E55F  1  B0 E6        	BCS	XOP1	;if error
00E561  1               
00E561  1               ;	Execute command.
00E561  1               
00E561  1  20 EA E6     	JSR	EHC	;execute handler command
00E564  1               
00E564  1               ;	Set PUT-BYTE routine address in IOCB.
00E564  1               
00E564  1  A9 0B        	LDA	#PUTCHR
00E566  1  85 17        	STA	ICCOMT	;command
00E568  1  20 95 E6     	JSR	CEP	;compute handler entry point
00E56B  1  A5 2C        	LDA	ICSPRZ	;PUT-BYTE routine address
00E56D  1  85 26        	STA	ICPTLZ	;IOCB PUT-BYTE routine address
00E56F  1  A5 2D        	LDA	ICSPRZ+1
00E571  1  85 27        	STA	ICPTHZ
00E573  1  4C 72 E6     	JMP	CCO	;complete CIO operation, return
00E576  1               ;	SPACE	4,10
00E576  1               ;**	PPO - Peripheral for OPEN
00E576  1               ;*
00E576  1               ;*	ENTRY	JSR	PPO
00E576  1               ;*
00E576  1               ;*	MODS
00E576  1               ;*		Original Author Unknown
00E576  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00E576  1               ;*		   R. K. Nordin	11/01/83
00E576  1               
00E576  1               
00E576  1               PPO	=	*	;entry
00E576  1  20 F9 EE     	JSR	PHO	;poll
00E579  1  4C 70 E6     	JMP	SSC	;set status and complete operation,:
00E57C  1               ;	SPACE	4,10
00E57C  1               ;**	XCL - Execute CLOSE Command
00E57C  1               ;*
00E57C  1               ;*	ENTRY	JSR	XCL
00E57C  1               ;*
00E57C  1               ;*	MODS
00E57C  1               ;*		Original Author Unknown
00E57C  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00E57C  1               ;*		   R. K. Nordin	11/01/83
00E57C  1               
00E57C  1               
00E57C  1               XCL	=	*		;entry
00E57C  1               
00E57C  1               ;	Initialize.
00E57C  1               
00E57C  1  A0 01        	LDY	#SUCCES		;assume success
00E57E  1  84 23        	STY	ICSTAZ		;status
00E580  1  20 95 E6     	JSR	CEP		;compute handler entry point
00E583  1  B0 03        	BCS	XCL1		;if error
00E585  1               
00E585  1               ;	Execute command.
00E585  1               
00E585  1  20 EA E6     	JSR	EHC		;execute handler command
00E588  1               
00E588  1               ;	Close IOCB.
00E588  1               
00E588  1  A9 FF        XCL1	LDA	#IOCFRE		;IOCB free indicator
00E58A  1  85 20        	STA	ICHIDZ		;indicate IOCB free
00E58C  1  A9 E4        	LDA	#high (IIN-1)
00E58E  1  85 27        	STA	ICPTHZ		;reset initial PUT-BYTE routine address
00E590  1  A9 DB        	LDA	#low (IIN-1)
00E592  1  85 26        	STA	ICPTLZ
00E594  1  4C 72 E6     	JMP	CCO		;complete CIO operation, return
00E597  1               ;	SPACE	4,10
00E597  1               ;**	XSS - Execute STATUS and SPECIAL Commands
00E597  1               ;*
00E597  1               ;*	???word about implicit OPEN and CLOSE.
00E597  1               ;*
00E597  1               ;*	ENTRY	JSR	XSS
00E597  1               ;*
00E597  1               ;*	MODS
00E597  1               ;*		Original Author Unknown
00E597  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00E597  1               ;*		   R. K. Nordin	11/01/83
00E597  1               
00E597  1               
00E597  1               XSS	=	*	;entry
00E597  1               
00E597  1               ;	Check IOCB free.
00E597  1               
00E597  1  A5 20        	LDA	ICHIDZ	;handler ID
00E599  1  C9 FF        	CMP	#IOCFRE
00E59B  1  D0 05        	BNE	XSS1	;if IOCB not free
00E59D  1               
00E59D  1               ;	Open IOCB.
00E59D  1               
00E59D  1  20 FF E6     	JSR	SHT	;search handler table
00E5A0  1  B0 A5        	BCS	XOP1	;if error
00E5A2  1               
00E5A2  1               ;	Execute command.
00E5A2  1               
00E5A2  1  20 95 E6     XSS1	JSR	CEP	;compute handler entry point
00E5A5  1  20 EA E6     	JSR	EHC	;execute handler command
00E5A8  1               
00E5A8  1               ;	Restore handler ID, in case IOCB implicitly opened.
00E5A8  1               
00E5A8  1  A6 2E        	LDX	ICIDNO	;IOCB index
00E5AA  1  BD 40 03     	LDA	ICHID,X	;original handler ID
00E5AD  1  85 20        	STA	ICHIDZ	;restore zero page handler ID
00E5AF  1  4C 72 E6     	JMP	CCO	;complete CIO operation, return
00E5B2  1               ;	SPACE	4,10
00E5B2  1               ;**	XGT - Execute GET Command
00E5B2  1               ;*
00E5B2  1               ;*	ENTRY	JSR	XGT
00E5B2  1               ;*
00E5B2  1               ;*	MODS
00E5B2  1               ;*		Original Author Unknown
00E5B2  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00E5B2  1               ;*		   R. K. Nordin	11/01/83
00E5B2  1               
00E5B2  1               
00E5B2  1               XGT	=	*	;entry
00E5B2  1               
00E5B2  1               ;	Check GET validity.
00E5B2  1               
00E5B2  1  A5 22        	LDA	ICCOMZ	;command
00E5B4  1  25 2A        	AND	ICAX1Z	;???
00E5B6  1  D0 05        	BNE	XGT2	;if GET command valid
00E5B8  1               
00E5B8  1               ;	Process error.
00E5B8  1               
00E5B8  1  A0 83        	LDY	#WRONLY	;IOCB opened for write only error
00E5BA  1               
00E5BA  1  4C 70 E6     XGT1	JMP	SSC	;set status and complete operation, return
00E5BD  1               
00E5BD  1               ;	Compute and check handler entry point.
00E5BD  1               
00E5BD  1  20 95 E6     XGT2	JSR	CEP	;compute handler entry point
00E5C0  1  B0 F8        	BCS	XGT1	;if error
00E5C2  1               
00E5C2  1               ;	Check buffer length.
00E5C2  1               
00E5C2  1  A5 28        	LDA	ICBLLZ		;buffer length
00E5C4  1  05 29        	ORA	ICBLLZ+1
00E5C6  1  D0 08        	BNE	XGT3		;if buffer length non-zero
00E5C8  1               
00E5C8  1               ;	Get byte.
00E5C8  1               
00E5C8  1  20 EA E6     	JSR	EHC	;execute handler command
00E5CB  1  85 2F        	STA	CIOCHR	;data
00E5CD  1  4C 72 E6     	JMP	CCO	;complete CIO operation, return
00E5D0  1               
00E5D0  1               ;	Fill buffer.
00E5D0  1               
00E5D0  1  20 EA E6     XGT3	JSR	EHC		;execute handler command
00E5D3  1  85 2F        	STA	CIOCHR		;data
00E5D5  1  30 41        	BMI	XGT7		;if error, end transfer
00E5D7  1               
00E5D7  1  A0 00        	LDY	#0
00E5D9  1  91 24        	STA	(ICBALZ),Y	;byte of buffer
00E5DB  1  20 D1 E6     	JSR	IBP		;increment buffer pointer
00E5DE  1  A5 22        	LDA	ICCOMZ		;command
00E5E0  1  29 02        	AND	#$02
00E5E2  1  D0 0C        	BNE	XGT4		;if GET RECORD command
00E5E4  1               
00E5E4  1               ;	Check for EOL.
00E5E4  1               
00E5E4  1  A5 2F        	LDA	CIOCHR	;data
00E5E6  1  C9 9B        	CMP	#EOL
00E5E8  1  D0 06        	BNE	XGT4	;if not EOL
00E5EA  1               
00E5EA  1               ;	Process EOL.
00E5EA  1               
00E5EA  1  20 BB E6     	JSR	DBL	;decrement buffer length
00E5ED  1  4C 18 E6     	JMP	XGT7	;clean up
00E5F0  1               
00E5F0  1               ;	Check buffer full.
00E5F0  1               
00E5F0  1  20 BB E6     XGT4	JSR	DBL	;decrement buffer length
00E5F3  1  D0 DB        	BNE	XGT3	;if buffer not full, continue
00E5F5  1               
00E5F5  1               ;	Check command.
00E5F5  1               
00E5F5  1  A5 22        	LDA	ICCOMZ	;command
00E5F7  1  29 02        	AND	#$02
00E5F9  1  D0 1D        	BNE	XGT7	;if GET CHARACTER command, clean up
00E5FB  1               
00E5FB  1               ;	Process GET RECORD.
00E5FB  1               
00E5FB  1  20 EA E6     XGT5	JSR	EHC	;execute handler command
00E5FE  1  85 2F        	STA	CIOCHR	;data
00E600  1  30 0A        	BMI	XGT6	;if error
00E602  1               
00E602  1               ;	Check for EOL.
00E602  1               
00E602  1  A5 2F        	LDA	CIOCHR	;data
00E604  1  C9 9B        	CMP	#EOL
00E606  1  D0 F3        	BNE	XGT5	;if not EOL, continue
00E608  1               
00E608  1               ;	Process end of record.
00E608  1               
00E608  1  A9 89        	LDA	#TRNRCD	;truncated record error
00E60A  1  85 23        	STA	ICSTAZ	;status
00E60C  1               
00E60C  1               ;	Process error.
00E60C  1               
00E60C  1  20 C8 E6     XGT6	JSR	DBP		;decrement buffer pointer
00E60F  1  A0 00        	LDY	#0
00E611  1  A9 9B        	LDA	#EOL
00E613  1  91 24        	STA	(ICBALZ),Y	;set EOL in buffer
00E615  1  20 D1 E6     	JSR	IBP		;increment buffer pointer
00E618  1               
00E618  1               ;	Clean up.
00E618  1               
00E618  1  20 D8 E6     XGT7	JSR	SFL	;set final buffer length
00E61B  1  4C 72 E6     	JMP	CCO	;complete CIO operation, return
00E61E  1               ;	SPACE	4,10
00E61E  1               ;**	XPT - Execute PUT Command
00E61E  1               ;*
00E61E  1               ;*	ENTRY	JSR	XPT
00E61E  1               ;*
00E61E  1               ;*	MODS
00E61E  1               ;*		Original Author Unknown
00E61E  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00E61E  1               ;*		   R. K. Nordin	11/01/83
00E61E  1               
00E61E  1               
00E61E  1               XPT	=	*	;entry
00E61E  1               
00E61E  1               ;	Check PUT validity.
00E61E  1               
00E61E  1  A5 22        	LDA	ICCOMZ	;command
00E620  1  25 2A        	AND	ICAX1Z
00E622  1  D0 05        	BNE	XPT2	;if PUT command valid
00E624  1               
00E624  1               ;	Process error.
00E624  1               
00E624  1  A0 87        	LDY	#RDONLY	;IOCB opened for read only error
00E626  1               
00E626  1  4C 70 E6     XPT1	JMP	SSC	;set status and complete operation, return
00E629  1               
00E629  1               ;	Compute and check handler entry point.
00E629  1               
00E629  1  20 95 E6     XPT2	JSR	CEP	;compute handler entry point
00E62C  1  B0 F8        	BCS	XPT1	;if error
00E62E  1               
00E62E  1               ;	Check buffer length.
00E62E  1               
00E62E  1  A5 28        	LDA	ICBLLZ	;buffer length
00E630  1  05 29        	ORA	ICBLLZ+1
00E632  1  D0 06        	BNE	XPT3	;if buffer length non-zero
00E634  1               
00E634  1               ;	Put byte.
00E634  1               
00E634  1  A5 2F        	LDA	CIOCHR	;data
00E636  1  E6 28        	INC	ICBLLZ	;set buffer length to 1
00E638  1  D0 06        	BNE	XPT4	;transfer one byte
00E63A  1               
00E63A  1               ;	Transfer data from buffer to handler.
00E63A  1               
00E63A  1  A0 00        XPT3	LDY	#0
00E63C  1  B1 24        	LDA	(ICBALZ),Y	;byte from buffer
00E63E  1  85 2F        	STA	CIOCHR		;data
00E640  1               
00E640  1  20 EA E6     XPT4	JSR	EHC		;execute handler command
00E643  1  08           	PHP			;save status
00E644  1  20 D1 E6     	JSR	IBP		;increment buffer pointer
00E647  1  20 BB E6     	JSR	DBL		;decrement buffer length
00E64A  1  28           	PLP			;status
00E64B  1  30 1D        	BMI	XPT6		;if error
00E64D  1               
00E64D  1               ;	Check command.
00E64D  1               
00E64D  1  A5 22        	LDA	ICCOMZ	;command
00E64F  1  29 02        	AND	#$02
00E651  1  D0 06        	BNE	XPT5	;if PUT RECORD command
00E653  1               
00E653  1               ;	Check for EOL.
00E653  1               
00E653  1  A5 2F        	LDA	CIOCHR	;data
00E655  1  C9 9B        	CMP	#EOL
00E657  1  F0 11        	BEQ	XPT6	;if EOL, clean up
00E659  1               
00E659  1               ;	Check for buffer empty.
00E659  1               
00E659  1  A5 28        XPT5	LDA	ICBLLZ		;buffer length
00E65B  1  05 29        	ORA	ICBLLZ+1
00E65D  1  D0 DB        	BNE	XPT3		;if buffer not empty, continue
00E65F  1               
00E65F  1               ;	Check command.
00E65F  1               
00E65F  1  A5 22        	LDA	ICCOMZ	;command
00E661  1  29 02        	AND	#$02
00E663  1  D0 05        	BNE	XPT6	;if PUT CHARACTER command
00E665  1               
00E665  1               ;	Write EOL.
00E665  1               
00E665  1  A9 9B        	LDA	#EOL
00E667  1  20 EA E6     	JSR	EHC	;execute handler command
00E66A  1               
00E66A  1               ;	Clean up.
00E66A  1               
00E66A  1  20 D8 E6     XPT6	JSR	SFL	;set final buffer length
00E66D  1  4C 72 E6     	JMP	CCO	;complete CIO operation, return
00E670  1               ;	SPACE	4,10
00E670  1               ;**	SSC - Set Status and Complete Operation
00E670  1               ;*
00E670  1               ;*	ENTRY	JSR	SSC
00E670  1               ;*
00E670  1               ;*	MODS
00E670  1               ;*		Original Author Unknown
00E670  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00E670  1               ;*		   R. K. Nordin	11/01/83
00E670  1               
00E670  1               
00E670  1               SSC	=	*	;entry
00E670  1  84 23        	STY	ICSTAZ	;status
00E672  1               ;	JMP	CCO	;complete CIO operation, return
00E672  1               ;	SPACE	4,10
00E672  1               ;**	CCO - Complete CIO Operation
00E672  1               ;*
00E672  1               ;*	ENTRY	JSR	CCO
00E672  1               ;*
00E672  1               ;*	MODS
00E672  1               ;*		Original Author Unknown
00E672  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00E672  1               ;*		   R. K. Nordin	11/01/83
00E672  1               
00E672  1               
00E672  1               CCO	=	*		;entry
00E672  1               
00E672  1               ;	Initialize.
00E672  1               
00E672  1  A4 2E        	LDY	ICIDNO		;IOCB index
00E674  1               
00E674  1               ;	Restore buffer pointer.
00E674  1               
00E674  1  B9 44 03     	LDA	ICBAL,Y
00E677  1  85 24        	STA	ICBALZ		;restore buffer pointer
00E679  1  B9 45 03     	LDA	ICBAH,Y
00E67C  1  85 25        	STA	ICBAHZ
00E67E  1               
00E67E  1               ;	Move part of zero page IOCB to IOCB.
00E67E  1               
00E67E  1  A2 00        	LDX	#0		;first byte of zero page IOCB
00E680  1  8E E9 02     	STX	HNDLOD
00E683  1               
00E683  1  B5 20        CCO1	LDA	IOCBAS,X	;byte of zero page IOCB
00E685  1  99 40 03     	STA	IOCB,Y		;byte of IOCB
00E688  1  E8           	INX
00E689  1  C8           	INY
00E68A  1  E0 0C        	CPX	#ICSPRZ-IOCBAS	;offset to first undesired byte
00E68C  1  90 F5        	BCC	CCO1		;if not done
00E68E  1               
00E68E  1               ;	Restore A, X and Y.
00E68E  1               
00E68E  1  A5 2F        	LDA	CIOCHR		;data
00E690  1  A6 2E        	LDX	ICIDNO		;IOCB index
00E692  1  A4 23        	LDY	ICSTAZ		;status
00E694  1  60           	RTS			;return
00E695  1               ;	SPACE	4,10
00E695  1               ;**	CEP - Compute Handler Entry Point
00E695  1               ;*
00E695  1               ;*	ENTRY	JSR	CEP
00E695  1               ;*
00E695  1               ;*	MODS
00E695  1               ;*		Original Author Unknown
00E695  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00E695  1               ;*		   R. K. Nordin	11/01/83
00E695  1               
00E695  1               
00E695  1               CEP	=	*		;entry
00E695  1               
00E695  1               ;	Check handler ID validity.
00E695  1               
00E695  1  A4 20        	LDY	ICHIDZ		;handler ID
00E697  1  C0 22        	CPY	#MAXDEV+1	;first invalid ID
00E699  1  90 04        	BCC	CEP1		;if handler ID within range
00E69B  1               
00E69B  1               ;	Process error.
00E69B  1               
00E69B  1  A0 85        	LDY	#NOTOPN		;IOCB not open error
00E69D  1  B0 1B        	BCS	CEP2		;return
00E69F  1               
00E69F  1               ;	Compute entry point.
00E69F  1               
00E69F  1  B9 1B 03     CEP1	LDA	HATABS+1,Y	;low address
00E6A2  1  85 2C        	STA	ICSPRZ
00E6A4  1  B9 1C 03     	LDA	HATABS+2,Y	;high address
00E6A7  1  85 2D        	STA	ICSPRZ+1
00E6A9  1  A4 17        	LDY	ICCOMT		;command
00E6AB  1  B9 2A E7     	LDA	TCVO-3,Y	;vector offset for command
00E6AE  1  A8           	TAY
00E6AF  1  B1 2C        	LDA	(ICSPRZ),Y	;low vector address
00E6B1  1  AA           	TAX			;low vector address
00E6B2  1  C8           	INY
00E6B3  1  B1 2C        	LDA	(ICSPRZ),Y	;high vector address
00E6B5  1  85 2D        	STA	ICSPRZ+1	;set high address
00E6B7  1  86 2C        	STX	ICSPRZ		;set low address
00E6B9  1  18           	CLC			;indicate success
00E6BA  1               
00E6BA  1               ;	Exit.
00E6BA  1               
00E6BA  1  60           CEP2	RTS			;return
00E6BB  1               ;	SPACE	4,10
00E6BB  1               ;**	DBL - Decrement Buffer Length
00E6BB  1               ;*
00E6BB  1               ;*	ENTRY	JSR	DBL
00E6BB  1               ;*
00E6BB  1               ;*	EXIT
00E6BB  1               ;*		Z set if buffer length = 0
00E6BB  1               ;*
00E6BB  1               ;*	MODS
00E6BB  1               ;*		Original Author Unknown
00E6BB  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00E6BB  1               ;*		   R. K. Nordin	11/01/83
00E6BB  1               
00E6BB  1               
00E6BB  1               DBL	=	*		;entry
00E6BB  1  A5 28        	LDA	ICBLLZ		;low buffer length
00E6BD  1  D0 02        	BNE	DBL1		;if low buffer length non-zero
00E6BF  1               
00E6BF  1  C6 29        	DEC	ICBLLZ+1	;decrement high buffer length
00E6C1  1               
00E6C1  1  C6 28        DBL1	DEC	ICBLLZ		;decrement low buffer length
00E6C3  1  A5 28        	LDA	ICBLLZ
00E6C5  1  05 29        	ORA	ICBLLZ+1	;indicate buffer length status
00E6C7  1  60           	RTS			;return
00E6C8  1               ;	SPACE	4,10
00E6C8  1               ;**	DBP - Decrement Buffer Pointer
00E6C8  1               ;*
00E6C8  1               ;*	ENTRY	JSR	DBP
00E6C8  1               ;*
00E6C8  1               ;*	MODS
00E6C8  1               ;*		Original Author Unknown
00E6C8  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00E6C8  1               ;*		   R. K. Nordin	11/01/83
00E6C8  1               
00E6C8  1               
00E6C8  1               DBP	=	*		;entry
00E6C8  1  A5 24        	LDA	ICBALZ		;low buffer address
00E6CA  1  D0 02        	BNE	DBP1		;if low buffer address non-zero
00E6CC  1               
00E6CC  1  C6 25        	DEC	ICBALZ+1	;decrement high buffer address
00E6CE  1               
00E6CE  1  C6 24        DBP1	DEC	ICBALZ		;decrement low buffer address
00E6D0  1  60           	RTS			;return
00E6D1  1               ;	SPACE	4,10
00E6D1  1               ;**	IBP - Increment Buffer Pointer
00E6D1  1               ;*
00E6D1  1               ;*	ENTRY	JSR	IBP
00E6D1  1               ;*
00E6D1  1               ;*	MODS
00E6D1  1               ;*		Original Author Unknown
00E6D1  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00E6D1  1               ;*		   R. K. Nordin	11/01/83
00E6D1  1               
00E6D1  1               
00E6D1  1               IBP	=	*		;entry
00E6D1  1  E6 24        	INC	ICBALZ		;increment low buffer address
00E6D3  1  D0 02        	BNE	IBP1		;if low buffer address non-zero
00E6D5  1               
00E6D5  1  E6 25        	INC	ICBALZ+1	;increment high buffer address
00E6D7  1               
00E6D7  1  60           IBP1	RTS			;return
00E6D8  1               ;	SPACE	4,10
00E6D8  1               ;**	SFL - Set Final Buffer Length
00E6D8  1               ;*
00E6D8  1               ;*	ENTRY	JSR	SFL
00E6D8  1               ;*
00E6D8  1               ;*	MODS
00E6D8  1               ;*		Original Author Unknown
00E6D8  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00E6D8  1               ;*		   R. K. Nordin	11/01/83
00E6D8  1               
00E6D8  1               
00E6D8  1               SFL	=	*		;entry
00E6D8  1  A6 2E        	LDX	ICIDNO		;IOCB index
00E6DA  1  38           	SEC
00E6DB  1  BD 48 03     	LDA	ICBLL,X		;initial length
00E6DE  1  E5 28        	SBC	ICBLLZ		;subtract byte count
00E6E0  1  85 28        	STA	ICBLLZ		;update length
00E6E2  1  BD 49 03     	LDA	ICBLH,X
00E6E5  1  E5 29        	SBC	ICBLLZ+1
00E6E7  1  85 29        	STA	ICBLHZ
00E6E9  1  60           	RTS			;return
00E6EA  1               ;	SPACE	4,10
00E6EA  1               ;**	EHC - Execute Handler Command
00E6EA  1               ;*
00E6EA  1               ;*	ENTRY	JSR	EHC
00E6EA  1               ;*
00E6EA  1               ;*	MODS
00E6EA  1               ;*		Original Author Unknown
00E6EA  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00E6EA  1               ;*		   R. K. Nordin	11/01/83
00E6EA  1               
00E6EA  1               
00E6EA  1               EHC	=	*		;entry
00E6EA  1  A0 92        	LDY	#FNCNOT		;assume function not defined error
00E6EC  1  20 F4 E6     	JSR	IDH		;invoke device handler
00E6EF  1  84 23        	STY	ICSTAZ		;status
00E6F1  1  C0 00        	CPY	#0		;set N accordingly
00E6F3  1  60           	RTS			;return
00E6F4  1               ;	SPACE	4,10
00E6F4  1               ;**	IDH - Invoke Device Handler
00E6F4  1               ;*
00E6F4  1               ;*	ENTRY	JSR	IDH
00E6F4  1               ;*
00E6F4  1               ;*	MODS
00E6F4  1               ;*		Original Author Unknown
00E6F4  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00E6F4  1               ;*		   R. K. Nordin	11/01/83
00E6F4  1               
00E6F4  1               
00E6F4  1               IDH	=	*		;entry
00E6F4  1  AA           	TAX			;save A
00E6F5  1  A5 2D        	LDA	ICSPRZ+1	;high vector
00E6F7  1  48           	PHA			;put high vector on stack
00E6F8  1  A5 2C        	LDA	ICSPRZ		;low vector
00E6FA  1  48           	PHA			;put low vector on stack
00E6FB  1  8A           	TXA			;restore A
00E6FC  1  A6 2E        	LDX	ICIDNO		;IOCB index
00E6FE  1  60           	RTS			;invoke handler (address on stack)
00E6FF  1               ;	SPACE	4,10
00E6FF  1               ;**	SHT - Search Handler Table
00E6FF  1               ;*
00E6FF  1               ;*	ENTRY	JSR	SHT
00E6FF  1               ;*
00E6FF  1               ;*	MODS
00E6FF  1               ;*		Original Author Unknown
00E6FF  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00E6FF  1               ;*		   R. K. Nordin	11/01/83
00E6FF  1               
00E6FF  1               
00E6FF  1               SHT	=	*	;entry
00E6FF  1               
00E6FF  1               ;	Set device number.
00E6FF  1               
00E6FF  1  38           	SEC
00E700  1  A0 01        	LDY	#1
00E702  1  B1 24        	LDA	(ICBALZ),Y	;device number
00E704  1  E9 31        	SBC	#'1'
00E706  1  30 04        	BMI	SHT1		;if number less than  "1"
00E708  1               
00E708  1  C9 09        	CMP	#'9'-'1'+1
00E70A  1  90 02        	BCC	SHT2		;if number in range "1" to "9"
00E70C  1               
00E70C  1  A9 00        SHT1	LDA	#0		;substitute device number "1"
00E70E  1               
00E70E  1  85 21        SHT2	STA	ICDNOZ		;device number (0 through 8)
00E710  1  E6 21        	INC	ICDNOZ		;adjust number to range 1 t:
00E712  1               
00E712  1               ;	Find device handler.
00E712  1               
00E712  1  A0 00        	LDY	#0		;offset to device code
00E714  1  B1 24        	LDA	(ICBALZ),Y	;device code
00E716  1               ;	JMP	FDH		;find device handler, return
00E716  1               ;	SPACE	4,10
00E716  1               ;**	FDH - Find Device Handler
00E716  1               ;*
00E716  1               ;*	ENTRY	JSR	FDH
00E716  1               ;*
00E716  1               ;*	MODS
00E716  1               ;*		Original Author Unknown
00E716  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00E716  1               ;*		   R. K. Nordin	11/01/83
00E716  1               
00E716  1               
00E716  1               FDH	=	*		;entry
00E716  1               
00E716  1               ;	Check device code.
00E716  1               
00E716  1  F0 0C        	BEQ	FDH2		;if device code null
00E718  1               
00E718  1               ;	Search handler table for device.
00E718  1               
00E718  1  A0 21        	LDY	#MAXDEV		;offset to last possible entry
00E71A  1               
00E71A  1  D9 1A 03     FDH1	CMP	HATABS,Y	;device code from table
00E71D  1  F0 09        	BEQ	FDH3		;if device found
00E71F  1               
00E71F  1  88           	DEY
00E720  1  88           	DEY
00E721  1  88           	DEY
00E722  1  10 F6        	BPL	FDH1		;if not done
00E724  1               
00E724  1               ;	Process device not found.
00E724  1               
00E724  1  A0 82        FDH2	LDY	#NONDEV		;nonexistent device error
00E726  1  38           	SEC			;indicate error
00E727  1  60           	RTS			;return
00E728  1               
00E728  1               ;	Set handler ID.
00E728  1               
00E728  1  98           FDH3	TYA			;offset to device code in table
00E729  1  85 20        	STA	ICHIDZ		;set handler ID
00E72B  1  18           	CLC			;indicate no error
00E72C  1  60           	RTS			;return
00E72D  1               ;	SPACE	4,10
00E72D  1               ;**	TCVO - Table of Command Vector Offsets
00E72D  1               ;*
00E72D  1               ;*	Entry n is the vector offset for command n+3.
00E72D  1               
00E72D  1               
00E72D  1  00 04 04 04  TCVO	DB	0	;3 - open
00E731  1  04 06 06 06  
00E735  1  06 02 08 0A  
00E739  1               	DB	4	;4
00E739  1               	DB	4	;5 - get record
00E739  1               	DB	4	;6
00E739  1               	DB	4	;7 - get byte(s)
00E739  1               	DB	6	;8
00E739  1               	DB	6	;9 - put record
00E739  1               	DB	6	;10
00E739  1               	DB	6	;11 - put byte(s)
00E739  1               	DB	2	;12 - close
00E739  1               	DB	8	;13 - status
00E739  1               	DB	10	;14 - special
00E739  1               ;	SUBTTL	'Peripheral Handler Loading Facility, Part 3'
00E739  1               ;	SPACE	4,10
00E739  1               ;**	PHR - Perform Peripheral Handler Loading Initializa:
00E739  1               ;*
00E739  1               ;*	* Performs Power-up Polling, with Handler loading a:
00E739  1               ;*	and Initialization;
00E739  1               ;*	* Performs System Reset Re-initialization of all ha:
00E739  1               ;*
00E739  1               ;*	Input Parameters:
00E739  1               ;*	WARMST (used to distinguish Cold and Warm Start).
00E739  1               ;*
00E739  1               ;*	Output Parameters:
00E739  1               ;*	None.
00E739  1               ;*
00E739  1               ;*	Modified:
00E739  1               ;*	Registers are not saved;
00E739  1               ;*	All kinds of side effects when any handler is loade:
00E739  1               ;*	(potentially MEMLO, DVSTAT thru DVSTAT+3, the DCB,
00E739  1               ;*	CHLINK, ZCHAIN, TEMP1, TEMP2, TEMP3.    This list m:
00E739  1               ;*	not be complete.).
00E739  1               ;*
00E739  1               ;*	ENTRY	JSR	PHR
00E739  1               ;*
00E739  1               ;*	MODS
00E739  1               ;*		R. S. Scheiman	04/01/82
00E739  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00E739  1               ;*		   R. K. Nordin	11/01/83
00E739  1               
00E739  1               
00E739  1               PHR	=	*	;entry
00E739  1               
00E739  1               ;	Check for coldstart.
00E739  1               
00E739  1  A5 08        	LDA	WARMST		;warmstart flag
00E73B  1  F0 25        	BEQ	PHR2		;if coldstart
00E73D  1               
00E73D  1               ;	Process warmstart.
00E73D  1               
00E73D  1  A9 E9        	LDA	#low (CHLINK-18)
00E73F  1  85 4A        	STA	ZCHAIN
00E741  1  A9 03        	LDA	#high (CHLINK-18)
00E743  1  85 4B        	STA	ZCHAIN+1
00E745  1               
00E745  1               ;	Check next link.
00E745  1               
00E745  1  A0 12        PHR1	LDY	#18		;offset to link
00E747  1  18           	CLC
00E748  1  B1 4A        	LDA	(ZCHAIN),y	;low link
00E74A  1  AA           	TAX
00E74B  1  C8           	INY
00E74C  1  71 4A        	ADC	(ZCHAIN),Y	;high link
00E74E  1  F0 26        	BEQ	PHR4		;if forward link null
00E750  1               
00E750  1               ;	Re-initialize peripheral handler.
00E750  1               
00E750  1  B1 4A        	LDA	(ZCHAIN),Y	;high link
00E752  1  85 4B        	STA	ZCHAIN+1
00E754  1  86 4A        	STX	ZCHAIN
00E756  1  20 56 CB     	JSR	CLT		;checksum linkage table
00E759  1  D0 1B        	BNE	PHR4		;if checksum bad
00E75B  1               
00E75B  1  20 94 E8     	JSR	PHW		;re-initialize peripheral h:
00E75E  1  B0 16        	BCS	PHR4		;if error
00E760  1               
00E760  1               ;	Continue with next handler.
00E760  1               
00E760  1  90 E3        	BCC	PHR1		;continue with next handler
00E762  1               
00E762  1               ;	Process coldstart.
00E762  1               
00E762  1  A9 00        PHR2	LDA	#0
00E764  1  8D FB 03     	STA	CHLINK		;clear chain link
00E767  1  8D FC 03     	STA	CHLINK+1
00E76A  1  A9 4F        	LDA	#$4F		;send POLL RESET poll
00E76C  1  D0 2D        	BNE	PHR7
00E76E  1               
00E76E  1               ;	Perform type 3 poll.
00E76E  1               
00E76E  1  A9 00        PHR3	LDA	#0
00E770  1  A8           	TAY
00E771  1  20 BE E7     	JSR	PHP_
00E774  1  10 01        	BPL	PHR5		;if poll answered
00E776  1               
00E776  1               ;	Exit.
00E776  1               
00E776  1  60           PHR4	RTS			;return
00E777  1               
00E777  1               ;	Process answered poll.
00E777  1               
00E777  1  18           PHR5	CLC
00E778  1  AD E7 02     	LDA	MEMLO
00E77B  1  6D EA 02     	ADC	DVSTAT
00E77E  1  8D 12 03     	STA	TEMP1
00E781  1  AD E8 02     	LDA	MEMLO+1
00E784  1  6D EB 02     	ADC	DVSTAT+1
00E787  1  8D 13 03     	STA	TEMP1+1		;(TEMP2 := MEMLO + handler :
00E78A  1  38           	SEC
00E78B  1  AD E5 02     	LDA	MEMTOP
00E78E  1  ED 12 03     	SBC	TEMP1
00E791  1  AD E6 02     	LDA	MEMTOP+1
00E794  1  ED 13 03     	SBC	TEMP1+1		;(subtract MEMTOP)
00E797  1  B0 09        	BCS	PHR8		;if room to load
00E799  1               
00E799  1               ;	Prepare for another poll.
00E799  1               
00E799  1  A9 4E        PHR6	LDA	#$4E		;following any load or init:
00E79B  1               				;prepare for another Type 3:
00E79B  1               				;sending a "special" load c:
00E79B  1               				;serial port.
00E79B  1               
00E79B  1               ;	Poll.
00E79B  1               
00E79B  1  A8           PHR7	TAY			;Send either "special" load:
00E79C  1  20 BE E7     	JSR	PHP_
00E79F  1  4C 6E E7     	JMP	PHR3		;go poll again
00E7A2  1               
00E7A2  1               ;	Load peripheral handler.
00E7A2  1               
00E7A2  1  AD EC 02     PHR8	LDA	DVSTAT+2	;call the loader
00E7A5  1  AE E7 02     	LDX	MEMLO
00E7A8  1  8E EC 02     	STX	DVSTAT+2	;(Parameter = load address)
00E7AB  1  AE E8 02     	LDX	MEMLO+1
00E7AE  1  8E ED 02     	STX	DVSTAT+3
00E7B1  1  20 DE E7     	JSR	LPH		;load peripheral handler
00E7B4  1  30 E3        	BMI	PHR6		;if load error, poll again
00E7B6  1               
00E7B6  1  38           	SEC			;Call for initialize new ha:
00E7B7  1  20 9E E8     	JSR	PHC		;(Parameter = add size to M:
00E7BA  1  B0 DD        	BCS	PHR6		;if init error, poll again
00E7BC  1               
00E7BC  1  90 B0        	BCC	PHR3		;poll again normally
00E7BE  1               ;	SPACE	4,10
00E7BE  1               ;**	PHP - Perform Poll
00E7BE  1               ;*
00E7BE  1               ;*	Polling subroutine calls SIO for Type 3 or 4 Poll.
00E7BE  1               ;*
00E7BE  1               ;*	Input Parameters:
00E7BE  1               ;*	A	Value for AUX1
00E7BE  1               ;*	Y	Value for AUX2
00E7BE  1               ;*
00E7BE  1               ;*	Output Parameters:
00E7BE  1               ;*	Y	SIO status from poll
00E7BE  1               ;*	DVSTAT: Device minimum size (low), if poll answered
00E7BE  1               ;*	DVSTAT+1: Device minimum size (high), if poll answe:
00E7BE  1               ;*	DVSTAT+2: Device address for loading, if poll answe:
00E7BE  1               ;*	DVSTAT+3: Device version number, if poll answered
00E7BE  1               ;*
00E7BE  1               ;*	Modified:
00E7BE  1               ;*	The registers are not saved;
00E7BE  1               ;*
00E7BE  1               ;*	Subroutines called:
00E7BE  1               ;*	SIO (performs poll and returns to PHP's caller).
00E7BE  1               ;*
00E7BE  1               ;*	ENTRY	JSR	PHP
00E7BE  1               ;*
00E7BE  1               ;*	MODS
00E7BE  1               ;*		R. S. Scheiman	04/01/82
00E7BE  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00E7BE  1               ;*		   R. K. Nordin	11/01/83
00E7BE  1               
00E7BE  1               
00E7BE  1               PHP_	=	*		;entry
00E7BE  1               
00E7BE  1               ;	Initialize.
00E7BE  1               
00E7BE  1  48           	PHA			;save parameter
00E7BF  1               
00E7BF  1               ;	Set up DCB.
00E7BF  1               
00E7BF  1  A2 09        	LDX	#PHPAL-1	;offset to last byte of DCB:
00E7C1  1  BD D4 E7     PHP1	LDA	PHPA,X		;byte of DCB data
00E7C4  1  9D 00 03     	STA	DCB,X		;byte of DCB
00E7C7  1  CA           	DEX
00E7C8  1  10 F7        	BPL	PHP1		;if not done
00E7CA  1               
00E7CA  1               ;	Set parameters in DBC auxiliary bytes.
00E7CA  1               
00E7CA  1  8C 0B 03     	STY	DAUX2
00E7CD  1  68           	PLA
00E7CE  1  8D 0A 03     	STA	DAUX1
00E7D1  1               
00E7D1  1               ;	Perform SIO.
00E7D1  1               
00E7D1  1  4C 59 E4     	JMP	SIOV		;vector to SIO, return
00E7D4  1               
00E7D4  1               
00E7D4  1               ;	DCB Poll Request Data
00E7D4  1               
00E7D4  1  4F 01 40 40  PHPA	DB	$4F	;device bus ID
00E7D8  1  EA 02 1E 00  
00E7DC  1  04 00        
00E7DE  1               	DB	1	;unit number
00E7DE  1               	DB	'@'	;type 3 or 4 poll command
00E7DE  1               	DB	$40	;I/O direction
00E7DE  1               	DW	DVSTAT	;buffer
00E7DE  1               	DB	30	;timeout
00E7DE  1               	DB	0
00E7DE  1               	DW	4	;buffer length
00E7DE  1               
00E7DE  1               PHPAL	=	*-PHPA	;length
00E7DE  1               ;	SPACE	4,10
00E7DE  1               ;**	LPH - Load Peripheral Handler
00E7DE  1               ;*
00E7DE  1               ;*	This subroutine calls the relocating loader to load
00E7DE  1               ;*	a handler from a peripheral.
00E7DE  1               ;*
00E7DE  1               ;*	Input Parameters:
00E7DE  1               ;*	A	Peripheral serial address for load;
00E7DE  1               ;*	DVSTAT+2: Load address (low)
00E7DE  1               ;*	DVSTAT+3: Load address (high)
00E7DE  1               ;*
00E7DE  1               ;*	Output Parameters:
00E7DE  1               ;*	From the relocating loader.
00E7DE  1               ;*
00E7DE  1               ;*	Modified:
00E7DE  1               ;*	TEMP1, TEMP2, TEMP3,
00E7DE  1               ;*	DVSTAT+3, DVSTAT+3 (forced even),
00E7DE  1               ;*	Relocating loader variables and parameters,
00E7DE  1               ;*	Registers not saved;
00E7DE  1               ;*
00E7DE  1               ;*	Subroutines called:
00E7DE  1               ;*	RLR (relocating loader).
00E7DE  1               ;*
00E7DE  1               ;*	ENTRY	JSR	LPH
00E7DE  1               ;*
00E7DE  1               ;*	MODS
00E7DE  1               ;*		R. S. Scheiman	04/01/82
00E7DE  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00E7DE  1               ;*		   R. K. Nordin	11/01/83
00E7DE  1               
00E7DE  1               
00E7DE  1               LPH	=	*	;entry
00E7DE  1               
00E7DE  1               ;	Initialize.
00E7DE  1               
00E7DE  1  8D 13 03     	STA	TEMP2	;save peripheral address
00E7E1  1  A2 00        	LDX	#0
00E7E3  1  8E 12 03     	STX	TEMP1	;set starting block number
00E7E6  1  CA           	DEX
00E7E7  1  8E 15 03     	STX	TEMP3	;set starting byte number
00E7EA  1               
00E7EA  1               ; Ensure load address even.
00E7EA  1               
00E7EA  1  AD EC 02     	LDA	DVSTAT+2	;low load address
00E7ED  1  6A           	ROR	A
00E7EE  1  90 08        	BCC	LPH1		;if even
00E7F0  1               
00E7F0  1  EE EC 02     	INC	DVSTAT+2	;increment low load address
00E7F3  1  D0 03        	BNE	LPH1		;if no carry
00E7F5  1               
00E7F5  1  EE ED 02     	INC	DVSTAT+3	;increment high load address
00E7F8  1               
00E7F8  1               ;	Set up relocating loader parameters.
00E7F8  1               
00E7F8  1  AD EC 02     LPH1	LDA	DVSTAT+2	;load address
00E7FB  1  8D D1 02     	STA	LOADAD
00E7FE  1  AD ED 02     	LDA	DVSTAT+3
00E801  1  8D D2 02     	STA	LOADAD+1
00E804  1  A9 16        	LDA	#low PHG	;get-byte routine address
00E806  1  8D CF 02     	STA	GBYTEA
00E809  1  A9 E8        	LDA	#high PHG
00E80B  1  8D D0 02     	STA	GBYTEA+1
00E80E  1  A9 80        	LDA	#$80		;loader page zero load addr:
00E810  1  8D D3 02     	STA	ZLOADA
00E813  1               
00E813  1               ;	Relocate routine.
00E813  1               
00E813  1  4C 45 C7     	JMP	RLR		;relocate routine, return
00E816  1               ;	SPACE	4,10
00E816  1               ;**	PHG - Perform Peripheral Handler GET-BYTE
00E816  1               ;*
00E816  1               ;*	Get a byte subroutine for relocating loader passes
00E816  1               ;*	bytes from peripheral to relocating loader via
00E816  1               ;*	cassette buffer. Calls GNL each time new
00E816  1               ;*	buffer is needed.
00E816  1               ;*
00E816  1               ;*	Input Parameters:
00E816  1               ;*	TEMP1: Next block number;
00E816  1               ;*	TEMP2: Peripheral address (for GNL);
00E816  1               ;*	TEMP3: Next byte number (index to CASBUF).
00E816  1               ;*
00E816  1               ;*	Output Parameters (for relocating loader):
00E816  1               ;*	Carry bit indicates error;
00E816  1               ;*	A	Next byte, if no error.
00E816  1               ;*
00E816  1               ;*	Modified:
00E816  1               ;*	Cassette buffer CASBUF;
00E816  1               ;*	TEMP3;
00E816  1               ;*	X, Y not saved.
00E816  1               ;*
00E816  1               ;*	Subroutines called:
00E816  1               ;*	GNL, which calls SIO to get load records.
00E816  1               ;*
00E816  1               ;*	ENTRY	JSR	PHG
00E816  1               ;*
00E816  1               ;*	MODS
00E816  1               ;*		R. S. Scheiman	04/01/82
00E816  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00E816  1               ;*		   R. K. Nordin	11/01/83
00E816  1               
00E816  1               PHG	=	*		;entry
00E816  1               
00E816  1               ;	Check for another byte in buffer.
00E816  1               
00E816  1  AE 15 03     	LDX	TEMP3
00E819  1  E8           	INX
00E81A  1  8E 15 03     	STX	TEMP3
00E81D  1  F0 08        	BEQ	PHG2		;if empty, load next block
00E81F  1               
00E81F  1               ;	Retrieve next byte.
00E81F  1               
00E81F  1  AE 15 03     PHG1	LDX	TEMP3
00E822  1  BD 7D 03     	LDA	CASBUF-$80,X	;byte
00E825  1  18           	CLC			;indicate no error
00E826  1  60           	RTS			;return
00E827  1               
00E827  1               ;	Load next block and retrieve next byte.
00E827  1               
00E827  1  A9 80        PHG2	LDA	#<-128	;offset to first byte
00E829  1  8D 15 03     	STA	TEMP3
00E82C  1  20 33 E8     	JSR	GNL	;get next load block
00E82F  1  10 EE        	BPL	PHG1	;if no error, retrieve next byte
00E831  1               
00E831  1               ;	Process error.
00E831  1               
00E831  1  38           	SEC		;indicate error
00E832  1  60           	RTS		;return
00E833  1               ;	SPACE	4,10
00E833  1               ;**	GNL - Get Next Load Block
00E833  1               ;*
00E833  1               ;*	Subroutine to get a load block from the peripheral.
00E833  1               ;*
00E833  1               ;*	Input Parameters:
00E833  1               ;*	TEMP1: Block number.
00E833  1               ;*
00E833  1               ;*	Output Parameters (for relocating loader):
00E833  1               ;*	Negative bit is set by SIO if I/O error occurs.
00E833  1               ;*
00E833  1               ;*	Modified:
00E833  1               ;*	TEMP1;
00E833  1               ;*	the DCB (SIO);
00E833  1               ;*	Registers not saved.
00E833  1               ;*
00E833  1               ;*	Subroutines called:
00E833  1               ;*	SIO.
00E833  1               ;*
00E833  1               ;*	ENTRY	JSR	GNL
00E833  1               ;*
00E833  1               ;*	MODS
00E833  1               ;*		R. S. Scheiman	04/01/82
00E833  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00E833  1               ;*		   R. K. Nordin	11/01/83
00E833  1               
00E833  1               GNL	=	*		;entry
00E833  1               
00E833  1               ;	Set up DCB.
00E833  1  A2 0B        	LDX	#GNLAL-1	;offset to last DCB data by:
00E835  1               
00E835  1  BD 51 E8     GNL1	LDA	GNLA,X		;byte of DCB data
00E838  1  9D 00 03     	STA	DCB,X		;byte of DCB
00E83B  1  CA           	DEX
00E83C  1  10 F7        	BPL	GNL1		;if not done
00E83E  1               
00E83E  1               ;	Set DCB parameters
00E83E  1               
00E83E  1  AE 12 03     	LDX	TEMP1		;block number
00E841  1  8E 0A 03     	STX	DAUX1		;auxiliary 1
00E844  1  E8           	INX
00E845  1  8E 12 03     	STX	TEMP1		;next block number
00E848  1  AD 13 03     	LDA	TEMP2		;device address
00E84B  1  8D 00 03     	STA	DDEVIC		;device bus ID
00E84E  1               
00E84E  1               ;	Perform SIO.
00E84E  1               
00E84E  1  4C 59 E4     	JMP	SIOV		;vector to SIO, return.
00E851  1               
00E851  1               
00E851  1               ;	DCB Data
00E851  1               
00E851  1  00 01 26 40  GNLA	DB	$00	;dummy device bus ID
00E855  1  FD 03 1E 00  
00E859  1  80 00 00 00  
00E85D  1               	DB	1	;dummy unit number
00E85D  1               	DB	'&'	;load command
00E85D  1               	DB	$40	;I/O direction
00E85D  1               	DW	CASBUF	;buffer
00E85D  1               	DB	30	;timeout
00E85D  1               	DB	0
00E85D  1               	DW	128	;buffer length
00E85D  1               	DB	0	;auxiliary 1
00E85D  1               	DB	0	;auxiliary 2
00E85D  1               
00E85D  1               GNLAL	=	*-GNLA	;length
00E85D  1               ;	SPACE	4,10
00E85D  1               ;**	SHC - Search Handler Chain
00E85D  1               ;*
00E85D  1               ;*	Forward chain search searches for pointer to handle:
00E85D  1               ;*	table whose address matches caller's parameter. If :
00E85D  1               ;*	parameter is zero, this routine looks for the point:
00E85D  1               ;*	the final linkage table since this table's forward :
00E85D  1               ;*	is zero (null.
00E85D  1               ;*
00E85D  1               ;*	Input Parameters:
00E85D  1               ;*	A	Linkage table address to match (High)
00E85D  1               ;*	Y	Linkage table address to match (Low)
00E85D  1               ;*
00E85D  1               ;*	Output Parameters:
00E85D  1               ;*	ZCHAIN points to linkage whose forward pointe:
00E85D  1               ;*		contains the match (if match is found);
00E85D  1               ;*		if the match is found just following the li:
00E85D  1               ;*		chain base CHLINK, then ZCHAIN points to CH:
00E85D  1               ;*		minus 18;
00E85D  1               ;*	If match successful, A (High) and X (Low) contain
00E85D  1               ;*		matched address (equiv. to A and Y parms.);
00E85D  1               ;*	Carry bit is set to indicate no match or checksum v:
00E85D  1               ;*		along the chain. [Note: the linkage table p:
00E85D  1               ;*		to by ZCHAIN upon return is not checksum ch:
00E85D  1               ;*
00E85D  1               ;*	Modified:
00E85D  1               ;*	TEMP1, TEMP2, ZCHAIN;
00E85D  1               ;*	The registers are not saved.
00E85D  1               ;*
00E85D  1               ;*	Subroutines called:
00E85D  1               ;*	CLT.
00E85D  1               ;*
00E85D  1               ;*	ENTRY	JSR	SHC
00E85D  1               ;*
00E85D  1               ;*	MODS
00E85D  1               ;*		R. S. Scheiman	04/01/82
00E85D  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00E85D  1               ;*		   R. K. Nordin	11/01/83
00E85D  1               
00E85D  1               
00E85D  1               SHC	=	*	;entry
00E85D  1               
00E85D  1               ;	Initialize.
00E85D  1               
00E85D  1  8C 12 03     	STY	TEMP1
00E860  1  8D 13 03     	STA	TEMP1+1
00E863  1  A9 E9        	LDA	#low (CHLINK-18)
00E865  1  85 4A        	STA	ZCHAIN		;start ZCHAIN at proper off:
00E867  1  A9 03        	LDA	#high (CHLINK-18)
00E869  1  85 4B        	STA	ZCHAIN+1
00E86B  1               
00E86B  1               ;	Check for match.
00E86B  1               
00E86B  1  A0 12        SHC1	LDY	#18
00E86D  1  B1 4A        	LDA	(ZCHAIN),Y
00E86F  1  AA           	TAX			;low chain pointer
00E870  1  C8           	INY
00E871  1  B1 4A        	LDA	(ZCHAIN),Y	;high chain pointer
00E873  1  CD 13 03     	CMP	TEMP2		;check for match with param:
00E876  1  D0 07        	BNE	SHC2		;if no match
00E878  1               
00E878  1  EC 12 03     	CPX	TEMP1
00E87B  1  D0 02        	BNE	SHC2		;if no match
00E87D  1               
00E87D  1               ;	Exit.
00E87D  1               
00E87D  1  18           	CLC		;indicate match
00E87E  1  60           	RTS		;return
00E87F  1               
00E87F  1               ;	Check for end of chain.
00E87F  1               
00E87F  1  C9 00        SHC2	CMP	#0	;end of chain indicator
00E881  1  D0 06        	BNE	SHC4	;if not end of chain
00E883  1               
00E883  1  E0 00        	CPX	#0
00E885  1  D0 02        	BNE	SHC4	;if not end of chain
00E887  1               
00E887  1               ;	Process end of chain or checksum error.
00E887  1               
00E887  1  38           SHC3	SEC		;return error (checksum or end)
00E888  1  60           	RTS		;return
00E889  1               
00E889  1               ;	Set link to new linkage table.
00E889  1               
00E889  1  86 4A        SHC4	STX	ZCHAIN	;link to new linkage table
00E88B  1  85 4B        	STA	ZCHAIN+1
00E88D  1               
00E88D  1  20 56 CB     	JSR	CLT	;checksum linkage table
00E890  1  D0 F5        	BNE	SHC3	;if error
00E892  1               
00E892  1               ;	Continue searching chain.
00E892  1               
00E892  1  F0 D7        	BEQ	SHC1	;continue searching chain
00E894  1               ;	SPACE	4,10
00E894  1               ;**	PHW - Perform Peripheral Handler Warmstart Initiali:
00E894  1               ;*
00E894  1               ;*	PHC is the main entry. This performs full initializ:
00E894  1               ;*		including adding the new linkage table into:
00E894  1               ;*		table chain;
00E894  1               ;*	PHW does all initialization except adding to the li:
00E894  1               ;*		table chain (intended for warm start reinit:
00E894  1               ;*	PHI is the full initialization entry for calling
00E894  1               ;*		init from outside the OS.
00E894  1               ;*
00E894  1               ;*	The code does the following:
00E894  1               ;*	1)	Links new handler to end of chain;
00E894  1               ;*	2)	Calls handler init subroutine in handler;
00E894  1               ;*	3)	If 2 failed, unlinks handler from chain,
00E894  1               ;*		and returns with carry;
00E894  1               ;*	4)	Else, conditionally zeroes handler size ent:
00E894  1               ;*		handler linkage table (per parameter);
00E894  1               ;*	5)	Adds handler size entry (possibly zeroed) t:
00E894  1               ;*	6)	If handler size entry is nonzero, MEMLO is :
00E894  1               ;*		forced even;
00E894  1               ;*	7)	Calculates and enters linkage table checksu:
00E894  1               ;*	8)	Returns with carry clear.
00E894  1               ;*
00E894  1               ;*	PHC is called by PHR when loading handlers at cold
00E894  1               ;*		initialization;and by PHL when loading a ha:
00E894  1               ;*		application request under CIO;
00E894  1               ;*	PHW is called by PHR to reinitialize a handler duri:
00E894  1               ;*		warm-start;
00E894  1               ;*	PHI is vectored by OS vector at $E49E and is intend:
00E894  1               ;*		for use by system-level applications which :
00E894  1               ;*		handlers (ie., AUTORUN.SYS handler loader, :
00E894  1               ;*
00E894  1               ;*	Input Parameters:
00E894  1               ;*	PHC:
00E894  1               ;*		DVSTAT, DVSTAT+1 contain handler size (for
00E894  1               ;*		handler init, not used by this routine);
00E894  1               ;*		DVSTAT+2, DVSTAT+3 contain handler linkage :
00E894  1               ;*		address.
00E894  1               ;*	PHW:
00E894  1               ;*		DVSTAT+2, DVSTAT+3 same;
00E894  1               ;*		DVSTAT, DVSTAT+1 undefined.
00E894  1               ;*	PHI:
00E894  1               ;*		A and Y contain handler linkage table addre:
00E894  1               ;*		they are copied into DVSTAT+3 and DVSTAT+2;
00E894  1               ;*		DVSTAT, DVSTAT+1 may or may not be signific:
00E894  1               ;*		any concern about these are up to the progr:
00E894  1               ;*		of the peripheral handler init routine and :
00E894  1               ;*		is making use of the non-OS-caller entry PH:
00E894  1               ;*
00E894  1               ;*	For PHI and PHC, the Carry bit specifies whether
00E894  1               ;*		the handler size entry of the linkage table:
00E894  1               ;*		be zeroed prior to adding to MEMLO: Carry s:
00E894  1               ;*		do NOT zero this entry.
00E894  1               ;*
00E894  1               ;*	Output Parameters:
00E894  1               ;*	Carry indicates error (initialization failed);
00E894  1               ;*	The registers are not saved.
00E894  1               ;*
00E894  1               ;*	Modified:
00E894  1               ;*	DVSTAT+2, DVSTAT+3 are modified by PHI;
00E894  1               ;*	ZCHAIN, TEMP1, TEMP2;
00E894  1               ;*	MEMLO, MEMLO+1 conditionally incremented by handler:
00E894  1               ;*
00E894  1               ;*	Subroutines called:
00E894  1               ;*	SHC (to find end of linkage table chain);
00E894  1               ;*	PHU (to unlink handler if init. error);
00E894  1               ;*	CLT (to insert linkage table checksum);
00E894  1               ;*	loaded handler's INIT entry.
00E894  1               ;*
00E894  1               ;*	ENTRY	JSR	PHW
00E894  1               ;*
00E894  1               ;*	MODS
00E894  1               ;*		R. S. Scheiman	04/01/82
00E894  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00E894  1               ;*		   R. K. Nordin	11/01/83
00E894  1               
00E894  1               
00E894  1               PHW	=	*	;entry
00E894  1  38           	SEC		;indicate not zeroing handler size
00E895  1  08           	PHP
00E896  1  B0 28        	BCS	PHQ	;initialize handler and update MEML:
00E898  1               ;	SPACE	4,10
00E898  1               ;**	PHI - Perform Peripheral Handler Initialization wit:
00E898  1               ;*
00E898  1               ;*	ENTRY	JSR	PHI
00E898  1               ;*
00E898  1               ;*	MODS
00E898  1               ;*		R. S. Scheiman	04/01/82
00E898  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00E898  1               ;*		   R. K. Nordin	11/01/83
00E898  1               
00E898  1               
00E898  1               PHI	=	*		;entry
00E898  1  8D ED 02     	STA	DVSTAT+3
00E89B  1  8C EC 02     	STY	DVSTAT+2
00E89E  1               ;	JMP	PHC		;perform coldstart initiali:
00E89E  1               ;	SPACE	4,10
00E89E  1               ;**	PHC - Perform Peripheral Handler Coldstart Initiali:
00E89E  1               ;*
00E89E  1               ;*	ENTRY	JSR	PHC
00E89E  1               ;*
00E89E  1               ;*	MODS
00E89E  1               ;*		R. S. Scheiman	04/01/82
00E89E  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00E89E  1               ;*		   R. K. Nordin	11/01/83
00E89E  1               
00E89E  1               PHC	=	*	;entry
00E89E  1               
00E89E  1               ;	Initialize.
00E89E  1               
00E89E  1  08           	PHP
00E89F  1               
00E89F  1               ;	Search for end of chain.
00E89F  1               
00E89F  1  A9 00        	LDA	#0	;indicate searching for end of chai:
00E8A1  1  A8           	TAY
00E8A2  1  20 5D E8     	JSR	SHC	;search handler chain
00E8A5  1  B0 27        	BCS	PHQ1	;if error, exit
00E8A7  1               
00E8A7  1               ;	Enter at end of chain.
00E8A7  1               
00E8A7  1  A0 12        	LDY	#18		;offset
00E8A9  1  AD EC 02     	LDA	DVSTAT+2
00E8AC  1  91 4A        	STA	(ZCHAIN),Y	;low link
00E8AE  1  AA           	TAX
00E8AF  1  C8           	INY
00E8B0  1  AD ED 02     	LDA	DVSTAT+3
00E8B3  1  91 4A        	STA	(ZCHAIN),Y	;high link
00E8B5  1  86 4A        	STX	ZCHAIN		;link to new table
00E8B7  1  85 4B        	STA	ZCHAIN+1
00E8B9  1  A9 00        	LDA	#0		;indicate end of chain
00E8BB  1  91 4A        	STA	(ZCHAIN),Y	;low link
00E8BD  1  88           	DEY
00E8BE  1  91 4A        	STA	(ZCHAIN),Y	;high link
00E8C0  1               
00E8C0  1               ;	Initialize handler.
00E8C0  1               
00E8C0  1               ;	JMP	PHQ		;initialize handler, return
00E8C0  1               ;	SPACE	4,10
00E8C0  1               ;**	PHQ - Initialize Handler and Update MEMLO
00E8C0  1               ;*
00E8C0  1               ;*	ENTRY	JSR	PHQ
00E8C0  1               ;*
00E8C0  1               ;*	MODS
00E8C0  1               ;*		R. S. Scheiman	04/01/82
00E8C0  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00E8C0  1               ;*		   R. K. Nordin	11/01/83
00E8C0  1               
00E8C0  1               
00E8C0  1               PHQ	=	*		;entry
00E8C0  1               
00E8C0  1               ;	Initialize handler.
00E8C0  1               
00E8C0  1  20 00 E9     	JSR	PHX		;initialize handler
00E8C3  1  90 0C        	BCC	PHQ2		;if no error
00E8C5  1               
00E8C5  1               ;	Process error.
00E8C5  1               
00E8C5  1  AD ED 02     	LDA	DVSTAT+3
00E8C8  1  AC EC 02     	LDY	DVSTAT+2
00E8CB  1  20 15 E9     	JSR	PHU		;unlink handler
00E8CE  1               
00E8CE  1               ;	Exit, indicating error.
00E8CE  1               
00E8CE  1  28           PHQ1	PLP			;fix stack
00E8CF  1  38           	SEC			;indicate error
00E8D0  1  60           	RTS			;return
00E8D1  1               
00E8D1  1               ;	Check for zeroing handler size.
00E8D1  1               
00E8D1  1  28           PHQ2	PLP
00E8D2  1  B0 09        	BCS	PHQ3		;if not zero
00E8D4  1               
00E8D4  1               ;	Zero handler size.
00E8D4  1               
00E8D4  1  A9 00        	LDA	#0
00E8D6  1  A0 10        	LDY	#16		;offset
00E8D8  1  91 4A        	STA	(ZCHAIN),Y	;zero size
00E8DA  1  C8           	INY
00E8DB  1  91 4A        	STA	(ZCHAIN),Y
00E8DD  1               
00E8DD  1               ; Increase MEMLO by size.
00E8DD  1               
00E8DD  1  18           PHQ3	CLC
00E8DE  1  A0 10        	LDY	#16		;offset to size
00E8E0  1  AD E7 02     	LDA	MEMLO
00E8E3  1  71 4A        	ADC	(ZCHAIN),Y	;add low size
00E8E5  1  8D E7 02     	STA	MEMLO		;new low MEMLO
00E8E8  1  C8           	INY
00E8E9  1  AD E8 02     	LDA	MEMLO+1
00E8EC  1  71 4A        	ADC	(ZCHAIN),Y	;add high size
00E8EE  1  8D E8 02     	STA	MEMLO+1		;new high MEMLO
00E8F1  1               
00E8F1  1               ;	Pu checksum in linkage table.
00E8F1  1               
00E8F1  1  A0 0F        	LDY	#15		;offset to checksum
00E8F3  1  A9 00        	LDA	#0
00E8F5  1  91 4A        	STA	(ZCHAIN),Y	;clear checksum
00E8F7  1  20 56 CB     	JSR	CLT		;checksum linkage table
00E8FA  1  A0 0F        	LDY	#15		;offset to checksum
00E8FC  1  91 4A        	STA	(ZCHAIN),Y	;checksum
00E8FE  1               
00E8FE  1               ;	Exit.
00E8FE  1               
00E8FE  1  18           	CLC			;indicate success
00E8FF  1  60           	RTS			;return
00E900  1               ;	SPACE	4,10
00E900  1               ;**	PHX - Initialize Handler
00E900  1               ;*
00E900  1               ;*	ENTRY	JSR	PHX
00E900  1               ;*
00E900  1               ;*	MODS
00E900  1               ;*		R. S. Scheiman	04/01/82
00E900  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00E900  1               ;*		   R. K. Nordin	11/01/83
00E900  1               
00E900  1               
00E900  1               PHX	=	*		;entry
00E900  1  18           	CLC
00E901  1  A5 4A        	LDA	ZCHAIN
00E903  1  69 0C        	ADC	#12
00E905  1  8D 12 03     	STA	TEMP1		;low handler initialization:
00E908  1  A5 4B        	LDA	ZCHAIN+1
00E90A  1  69 00        	ADC	#0
00E90C  1  8D 13 03     	STA	TEMP1+1		;high handler initializatio:
00E90F  1  6C 12 03     	JMP	(TEMP1)		;initialize handler, return
00E912  1               ;	SUBTTL	'$E912 Patch'
00E912  1               ;	SPACE	4,10
00E912  1               	FIX	$E912
00E912  1               ;	SPACE	4,10
00E912  1               ;**	E912 - $E912 Patch
00E912  1               ;*
00E912  1               ;*	For compatibilty with OS Revision B, set VBLANK parameters.
00E912  1               
00E912  1               
00E912  1  4C 72 C2     	JMP	SVP	;set VBLANK parameters, return
00E915  1               ;	SUBTTL	'Peripheral Handler Loading Facility, Part 4'
00E915  1               ;	SPACE	4,10
00E915  1               ;**	PHU - Perform Peripheral Handler Unlinking
00E915  1               ;*
00E915  1               ;*	Handler entry unlinking routine. This routine is ca:
00E915  1               ;*	by the OS handler initialization to unlink a handle:
00E915  1               ;*	initialization fails, or by the handler itself if i:
00E915  1               ;*	the handler unload feature.     This routine is ent:
00E915  1               ;*	OS vector at $E49B.
00E915  1               ;*
00E915  1               ;*	Input Parameters:
00E915  1               ;*	A	Address of linkage table to unlink (High);
00E915  1               ;*	Y	Address of linkage table to unlink (Low).
00E915  1               ;*	COLDST: Tested to see if PHU is called during cold :
00E915  1               ;*		if so, chain entry is unlinked even if at M:
00E915  1               ;*
00E915  1               ;*	Output Parameters:
00E915  1               ;*	Carry is set to indicate error;in this case,
00E915  1               ;*		no unlinking has occurred.
00E915  1               ;*
00E915  1               ;*	Modified:
00E915  1               ;*	TEMP1, TEMP2;
00E915  1               ;*	ZCHAIN,ZCHAIN+1;
00E915  1               ;*	The forward chain pointer in the precedessor of the:
00E915  1               ;*	table being removed is modified to point to the suc:
00E915  1               ;*	of the removed table if the removal is successful--
00E915  1               ;*	this forward chain pointer may be CHLINK, CHLINK+1.
00E915  1               ;*
00E915  1               ;*	The registers are not saved.
00E915  1               ;*
00E915  1               ;*	Subroutines called:
00E915  1               ;*	SHC, CLT.
00E915  1               ;*
00E915  1               ;*	ENTRY	JSR	PHU
00E915  1               ;*
00E915  1               ;*	MODS
00E915  1               ;*		R. S. Scheiman	04/01/82
00E915  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00E915  1               ;*		   R. K. Nordin	11/01/83
00E915  1               
00E915  1               
00E915  1               PHU	=	*		;entry
00E915  1               
00E915  1               ;	Search handler chain.
00E915  1               
00E915  1  20 5D E8     	JSR	SHC		;search handler chain
00E918  1  B0 3B        	BCS	PHU3		;if error
00E91A  1               
00E91A  1               ;	Perform unlinking.
00E91A  1               
00E91A  1  A8           	TAY			;(save return parameter)
00E91B  1  A5 4A        	LDA	ZCHAIN		;save ZCHAIN (points to pre:
00E91D  1  48           	PHA
00E91E  1  A5 4B        	LDA	ZCHAIN+1
00E920  1  48           	PHA
00E921  1  86 4A        	STX	ZCHAIN		;make ZCHAIN point to linka:
00E923  1  84 4B        	STY	ZCHAIN+1	;to be removed
00E925  1  AD 44 02     	LDA	COLDST		;coldstart flag
00E928  1  D0 0F        	BNE	PHU1		;if coldstart, unconditional:
00E92A  1               
00E92A  1  A0 10        	LDY	#16		;check if loaded at MEMLO..:
00E92C  1  18           	CLC			;by checking if size is non:
00E92D  1  B1 4A        	LDA	(ZCHAIN),Y
00E92F  1  C8           	INY
00E930  1  71 4A        	ADC	(ZCHAIN),Y
00E932  1  D0 1F        	BNE	PHU2		;if handler size non-zero
00E934  1               
00E934  1  20 56 CB     	JSR	CLT		;checksum linkage table
00E937  1  D0 1A        	BNE	PHU2		;if checksum nonzero, bad c:
00E939  1               
00E939  1  A0 12        PHU1	LDY	#18		;take link from table being:
00E93B  1  B1 4A        	LDA	(ZCHAIN),Y
00E93D  1  AA           	TAX
00E93E  1  C8           	INY
00E93F  1  B1 4A        	LDA	(ZCHAIN),Y
00E941  1  A8           	TAY
00E942  1  68           	PLA		;Make ZCHAIN point to the predecess:
00E943  1  85 4B        	STA	ZCHAIN+1
00E945  1  68           	PLA
00E946  1  85 4A        	STA	ZCHAIN
00E948  1  98           	TYA		;And put forward link from table be:
00E949  1  A0 13        	LDY	#19	;removed into its predecessors link:
00E94B  1  91 4A        	STA	(ZCHAIN),Y
00E94D  1  88           	DEY
00E94E  1  8A           	TXA
00E94F  1  91 4A        	STA	(ZCHAIN),Y
00E951  1  18           	CLC		;indicate success
00E952  1  60           	RTS		;return
00E953  1               
00E953  1               ;	Clean stack and process error.
00E953  1               
00E953  1  68           PHU2	PLA		;Error return--restore stack
00E954  1  68           	PLA
00E955  1               
00E955  1               ;	Process error.
00E955  1               
00E955  1  38           PHU3	SEC		;indicate error
00E956  1  60           	RTS		;return
00E957  1               ;	SUBTTL	'$E959 Patch'
00E957  1               ;	SPACE	4,10
00E957  1  00 00        	FIX	$E959
00E959  1               ;	SPACE	4,10
00E959  1               ;**	E959 - $E959 Patch
00E959  1               ;*
00E959  1               ;*	For compatibilty with OS Revision B, perform PIO.
00E959  1               
00E959  1               
00E959  1  4C 33 C9     	JMP	PIO	;perform PIO, return
00E95C  1               ;	SUBTTL	'Serial Input/Output'
00E95C  1               ;	SPACE	4,10
00E95C  1               ;**	ISIO - Initialize SIO
00E95C  1               ;*
00E95C  1               ;*	ENTRY	JSR	ISIO
00E95C  1               ;*
00E95C  1               ;*	MODS
00E95C  1               ;*		Original Author Unknown
00E95C  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00E95C  1               ;*		   R. K. Nordin	11/01/83
00E95C  1               
00E95C  1               
00E95C  1               ISIO	=	*	;entry
00E95C  1               
00E95C  1  A9 3C        	LDA	#MOTRST
00E95E  1  8D 02 D3     	STA	PACTL	;turn off motor
00E961  1               
00E961  1  A9 3C        	LDA	#NCOMHI
00E963  1  8D 03 D3     	STA	PBCTL	;raise NOT COMMAND line
00E966  1               
00E966  1  A9 03        	LDA	#$03	;POKEY out of initialize mode
00E968  1  8D 32 02     	STA	SSKCTL	;SKCTL shadow
00E96B  1  85 41        	STA	SOUNDR	;select noisy I/O
00E96D  1  8D 0F D2     	STA	SKCTL
00E970  1               
00E970  1  60           	RTS		;return
00E971  1               ;	SPACE	4,10
00E971  1               ;**	SIO - Serial Input/Output
00E971  1               ;*
00E971  1               ;*	ENTRY	JSR	SIO
00E971  1               ;*
00E971  1               ;*	MODS
00E971  1               ;*		Original Author Unknown
00E971  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00E971  1               ;*		   R. K. Nordin	11/01/83
00E971  1               
00E971  1               
00E971  1               SIO	=	*	;entry
00E971  1               
00E971  1               ;	Initialize.
00E971  1               
00E971  1  BA           	TSX
00E972  1  8E 18 03     	STX	STACKP	;save stack pointer
00E975  1  A9 01        	LDA	#1	;critical section indicator
00E977  1  85 42        	STA	CRITIC	;indicate critical section
00E979  1               
00E979  1               ;	Check device ID.
00E979  1               
00E979  1  AD 00 03     	LDA	DDEVIC	;device ID
00E97C  1  C9 60        	CMP	#CASET
00E97E  1  D0 03        	BNE	SIO1	;if not cassette
00E980  1               
00E980  1               ;	Process cassette.
00E980  1               
00E980  1  4C 9D EB     	JMP	PCI	;process cassette I/O, return
00E983  1               
00E983  1               ;	Process intelligent device.
00E983  1               
00E983  1  A9 00        SIO1	LDA	#0
00E985  1  8D 0F 03     	STA	CASFLG	;indicate not cassette
00E988  1               
00E988  1  A9 01        	LDA	#DRETRI
00E98A  1  8D BD 02     	STA	DRETRY	;set device retry count
00E98D  1               
00E98D  1  A9 0D        SIO2	LDA	#CRETRI
00E98F  1  8D 9C 02     	STA	CRETRY	;set command frame retry count
00E992  1               
00E992  1               ;	Send command frame.
00E992  1               
00E992  1  A9 28        SIO3	LDA	#low B19200
00E994  1  8D 04 D2     	STA	AUDF3		;set baud rate to 19200
00E997  1  A9 00        	LDA	#high B19200
00E999  1  8D 06 D2     	STA	AUDF4
00E99C  1               
00E99C  1               ;	Set up command buffer.
00E99C  1               
00E99C  1  18           	CLC
00E99D  1  AD 00 03     	LDA	DDEVIC		;device ID
00E9A0  1  6D 01 03     	ADC	DUNIT		;add unit number
00E9A3  1  69 FF        	ADC	#$FF		;subtract 1
00E9A5  1  8D 3A 02     	STA	CDEVIC		;device bus ID
00E9A8  1  AD 02 03     	LDA	DCOMND		;command
00E9AB  1  8D 3B 02     	STA	CCOMND
00E9AE  1  AD 0A 03     	LDA	DAUX1		;auxiliary information 1
00E9B1  1  8D 3C 02     	STA	CAUX1
00E9B4  1  AD 0B 03     	LDA	DAUX2		;auxiliary information 2
00E9B7  1  8D 3D 02     	STA	CAUX2
00E9BA  1               
00E9BA  1               ;	Set buffer pointer to command frame buffer.
00E9BA  1               
00E9BA  1  18           	CLC
00E9BB  1  A9 3A        	LDA	#low CDEVIC	;low buffer address
00E9BD  1  85 32        	STA	BUFRLO		;low buffer address
00E9BF  1  69 04        	ADC	#4
00E9C1  1  85 34        	STA	BFENLO		;low buffer end address
00E9C3  1  A9 02        	LDA	#high CDEVIC	;high buffer address
00E9C5  1  85 33        	STA	BUFRHI		;high buffer address
00E9C7  1  85 35        	STA	BFENHI		;high buffer end address
00E9C9  1               
00E9C9  1               ;	Send command frame to device.
00E9C9  1               
00E9C9  1  A9 34        	LDA	#NCOMLO
00E9CB  1  8D 03 D3     	STA	PBCTL		;lower NOT COMMAND line
00E9CE  1  20 AF EC     	JSR	SID		;send command frame
00E9D1  1  AD 3F 02     	LDA	ERRFLG		;error flag
00E9D4  1  D0 03        	BNE	SIO4		;if error received
00E9D6  1               
00E9D6  1  98           	TYA			;status
00E9D7  1  D0 08        	BNE	SIO5		;if ACK received
00E9D9  1               
00E9D9  1               ;	Process NAK or timeout.
00E9D9  1               
00E9D9  1  CE 9C 02     SIO4	DEC	CRETRY	;decrement command frame retry count
00E9DC  1  10 B4        	BPL	SIO3	;if retries not exhausted
00E9DE  1               
00E9DE  1               ;	Process command frame retries exhausted.
00E9DE  1               
00E9DE  1  4C 22 EA     	JMP	SIO10	;process error
00E9E1  1               
00E9E1  1               ;	Process ACK.
00E9E1  1               
00E9E1  1  AD 03 03     SIO5	LDA	DSTATS
00E9E4  1  10 0D        	BPL	SIO6	;if no data to send
00E9E6  1               
00E9E6  1               ;	Send data frame to device.
00E9E6  1               
00E9E6  1  A9 0D        	LDA	#CRETRI
00E9E8  1  8D 9C 02     	STA	CRETRY	;set command frame retry count
00E9EB  1  20 87 EB     	JSR	SBP	;set buffer pointers
00E9EE  1  20 AF EC     	JSR	SID	;send data frame
00E9F1  1  F0 2F        	BEQ	SIO10	;if error
00E9F3  1               
00E9F3  1               ;	Wait for complete.
00E9F3  1               
00E9F3  1  20 9A EC     SIO6	JSR	GTO	;set device timeout
00E9F6  1  A9 00        	LDA	#0
00E9F8  1  8D 3F 02     	STA	ERRFLG	;clear error flag
00E9FB  1  20 C0 EC     	JSR	STW	;set timer and wait
00E9FE  1  F0 12        	BEQ	SIO8	;if timeout
00EA00  1               
00EA00  1               ;	Process no timeout.
00EA00  1               
00EA00  1  2C 03 03     	BIT	DSTATS
00EA03  1  70 07        	BVS	SIO7	;if more data follows
00EA05  1               
00EA05  1  AD 3F 02     	LDA	ERRFLG	;error flag
00EA08  1  D0 18        	BNE	SIO10	;if error
00EA0A  1               
00EA0A  1               ;	Process no error.
00EA0A  1               
00EA0A  1  F0 1E        	BEQ	CSO	;complete SIO operation
00EA0C  1               
00EA0C  1               ;	Receive data frame from device.
00EA0C  1               
00EA0C  1  20 87 EB     SIO7	JSR	SBP	;set buffer pointers
00EA0F  1  20 FD EA     	JSR	REC	;receive
00EA12  1               
00EA12  1               ;	Check error flag.
00EA12  1               
00EA12  1  AD 3F 02     SIO8	LDA	ERRFLG	;error flag
00EA15  1  F0 05        	BEQ	SIO9	;if no error preceded data
00EA17  1               
00EA17  1               ;	Process error.
00EA17  1               
00EA17  1  AD 19 03     	LDA	TSTAT	;temporary status
00EA1A  1  85 30        	STA	STATUS	;status
00EA1C  1               
00EA1C  1               ;	Check status.
00EA1C  1               
00EA1C  1  A5 30        SIO9	LDA	STATUS	;status
00EA1E  1  C9 01        	CMP	#SUCCES
00EA20  1  F0 08        	BEQ	CSO	;if successful, complete operation, return
00EA22  1               
00EA22  1               ;	Process error.
00EA22  1               
00EA22  1  CE BD 02     SIO10	DEC	DRETRY	;decrement device retry count
00EA25  1  30 03        	BMI	CSO	;if retries exhausted, complete, return
00EA27  1               
00EA27  1               ;	Retry.
00EA27  1               
00EA27  1  4C 8D E9     	JMP	SIO2	;retry
00EA2A  1               ;	SPACE	4,10
00EA2A  1               ;**	CSO - Complete SIO Operation
00EA2A  1               ;*
00EA2A  1               ;*	ENTRY	JSR	CSO
00EA2A  1               ;*
00EA2A  1               ;*	MODS
00EA2A  1               ;*		Original Author Unknown
00EA2A  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00EA2A  1               ;*		   R. K. Nordin	11/01/83
00EA2A  1               
00EA2A  1               
00EA2A  1               CSO	=	*	;entry
00EA2A  1  20 84 EC     	JSR	DSR	;disable SEND and RECEIVE
00EA2D  1  A9 00        	LDA	#0	;not critical section indicator
00EA2F  1  85 42        	STA	CRITIC	;critical section flag
00EA31  1  A4 30        	LDY	STATUS	;status
00EA33  1  8C 03 03     	STY	DSTATS	;status
00EA36  1  60           	RTS		;return
00EA37  1               ;	SPACE	4,10
00EA37  1               ;**	WCA - Wait for Completion or ACK
00EA37  1               ;*
00EA37  1               ;*	ENTRY	JSR	WCA
00EA37  1               ;*
00EA37  1               ;*	EXIT
00EA37  1               ;*		Y = 0, if failure
00EA37  1               ;*		  = $FF, if success
00EA37  1               ;*
00EA37  1               ;*	NOTES
00EA37  1               ;*		Problem: WCA does not handle NAK correctly;:
00EA37  1               ;*		just before WCA3 should be removed.
00EA37  1               ;*
00EA37  1               ;*	MODS
00EA37  1               ;*		Original Author Unknown
00EA37  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00EA37  1               ;*		   R. K. Nordin	11/01/83
00EA37  1               
00EA37  1               
00EA37  1               WCA	=	*		;entry
00EA37  1               
00EA37  1               ;	Initialize.
00EA37  1               
00EA37  1  A9 00        	LDA	#0
00EA39  1  8D 3F 02     	STA	ERRFLG		;clear error flag
00EA3C  1               
00EA3C  1               ;	Set buffer pointer.
00EA3C  1               
00EA3C  1  18           	CLC
00EA3D  1  A9 3E        	LDA	#low TEMP	;low temporary address
00EA3F  1  85 32        	STA	BUFRLO		;low buffer address
00EA41  1  69 01        	ADC	#1
00EA43  1  85 34        	STA	BFENLO		;low buffer end address
00EA45  1  A9 02        	LDA	#high TEMP	;high temporary address
00EA47  1  85 33        	STA	BUFRHI		;high buffer address
00EA49  1  85 35        	STA	BFENHI		;high buffer end address
00EA4B  1  A9 FF        	LDA	#$FF
00EA4D  1  85 3C        	STA	NOCKSM		;indicate no checksum follows
00EA4F  1  20 FD EA     	JSR	REC		;receive
00EA52  1  A0 FF        	LDY	#$FF		;assume success
00EA54  1  A5 30        	LDA	STATUS		;status
00EA56  1  C9 01        	CMP	#SUCCES
00EA58  1  D0 19        	BNE	WCA2		;if failure
00EA5A  1               
00EA5A  1  AD 3E 02     	LDA	TEMP		;byte received
00EA5D  1  C9 41        	CMP	#ACK
00EA5F  1  F0 21        	BEQ	WCA4		;if ACK, exit
00EA61  1               
00EA61  1  C9 43        	CMP	#COMPLT
00EA63  1  F0 1D        	BEQ	WCA4		;if complete, exit
00EA65  1               
00EA65  1  C9 45        	CMP	#ERROR
00EA67  1  D0 06        	BNE	WCA1		;if device did not send back
00EA69  1               
00EA69  1               ;	Process unrecognized response.
00EA69  1               
00EA69  1  A9 90        	LDA	#DERROR
00EA6B  1  85 30        	STA	STATUS		;indicate device error
00EA6D  1  D0 04        	BNE	WCA2		;check for timeout
00EA6F  1               
00EA6F  1               ;	Process nothing sent back.
00EA6F  1               
00EA6F  1  A9 8B        WCA1	LDA	#DNACK
00EA71  1  85 30        	STA	STATUS		;indicate NAK
00EA73  1               
00EA73  1               ;	Check for timeout.
00EA73  1               
00EA73  1  A5 30        WCA2	LDA	STATUS		;status
00EA75  1  C9 8A        	CMP	#TIMOUT
00EA77  1  F0 07        	BEQ	WCA3		;if timeout
00EA79  1               
00EA79  1               ;	Process other error.
00EA79  1               
00EA79  1  A9 FF        	LDA	#$FF		;error indicator
00EA7B  1  8D 3F 02     	STA	ERRFLG		;indicate error
00EA7E  1  D0 02        	BNE	WCA4		;exit
00EA80  1               
00EA80  1               ;	Indicate failure.
00EA80  1               
00EA80  1  A0 00        WCA3	LDY	#0		;failure indicator
00EA82  1               
00EA82  1               ;	Exit.
00EA82  1               
00EA82  1  A5 30        WCA4	LDA	STATUS		;status
00EA84  1  8D 19 03     	STA	TSTAT		;temporary status
00EA87  1  60           	RTS			;return
00EA88  1               ;	SPACE	4,10
00EA88  1               ;**	SEN - Send
00EA88  1               ;*
00EA88  1               ;*	SEN sends a buffer over the serial bus.
00EA88  1               ;*
00EA88  1               ;*	ENTRY	JSR	SEN
00EA88  1               ;*
00EA88  1               ;*	NOTES
00EA88  1               ;*		Problem: an interrupt may occur before CHKS:
00EA88  1               ;*		initialized, causing an incorrect checksum :
00EA88  1               ;*		STA CHKSUM should precede STA SEROUT.
00EA88  1               ;*
00EA88  1               ;*	MODS
00EA88  1               ;*		Original Author Unknown
00EA88  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00EA88  1               ;*		   R. K. Nordin	11/01/83
00EA88  1               
00EA88  1               
00EA88  1               SEN	=	*		;entry
00EA88  1               
00EA88  1               ;	Initialize.
00EA88  1               
00EA88  1  A9 01        	LDA	#SUCCES		;assume success
00EA8A  1  85 30        	STA	STATUS		;status
00EA8C  1  20 17 EC     	JSR	ESS		;enable SIO SEND
00EA8F  1  A0 00        	LDY	#0
00EA91  1  84 31        	STY	CHKSUM		;clear checksum
00EA93  1  84 3B        	STY	CHKSNT		;clear checksum sent flag
00EA95  1  84 3A        	STY	XMTDON		;clear transmit-frame done flag
00EA97  1               
00EA97  1               ;	Initiate TRANSMIT.
00EA97  1               
00EA97  1  B1 32        	LDA	(BUFRLO),Y	;first byte from buffer
00EA99  1  8D 0D D2     	STA	SEROUT		;serial output register
00EA9C  1  85 31        	STA	CHKSUM		;checksum
00EA9E  1               
00EA9E  1               ;	Check BREAK key.
00EA9E  1               
00EA9E  1  A5 11        SEN1	LDA	BRKKEY
00EAA0  1  D0 03        	BNE	SEN2		;if BREAK key not pressed
00EAA2  1               
00EAA2  1               ;	Process BREAK key.
00EAA2  1               
00EAA2  1  4C C7 ED     	JMP	PBK		;process BREAK key, return
00EAA5  1               
00EAA5  1               ;	Process BREAK key not pressed.
00EAA5  1               
00EAA5  1  A5 3A        SEN2	LDA	XMTDON		;transmit-frame done flag
00EAA7  1  F0 F5        	BEQ	SEN1		;if transmit-frame not done
00EAA9  1               
00EAA9  1               ;	Exit.
00EAA9  1               
00EAA9  1  20 84 EC     	JSR	DSR		;disable SEND and RECEIVE
00EAAC  1  60           	RTS			;return
00EAAD  1               ;	SPACE	4,10
00EAAD  1               ;**	ORIR - Process Serial Output Ready IRQ
00EAAD  1               ;*
00EAAD  1               ;*	ENTRY	JMP	ORIR
00EAAD  1               ;*
00EAAD  1               ;*	EXIT
00EAAD  1               ;*		Exits via RTI
00EAAD  1               ;*
00EAAD  1               ;*	MODS
00EAAD  1               ;*		Original Author Unknown
00EAAD  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00EAAD  1               ;*		   R. K. Nordin	11/01/83
00EAAD  1               
00EAAD  1               
00EAAD  1               ORIR	=	*	;entry
00EAAD  1               
00EAAD  1               ;	Initialize.
00EAAD  1               
00EAAD  1  98           	TYA
00EAAE  1  48           	PHA		;save Y
00EAAF  1  E6 32        	INC	BUFRLO	;increment low buffer pointer
00EAB1  1  D0 02        	BNE	ORI1	;if low buffer pointer non-zero
00EAB3  1               
00EAB3  1  E6 33        	INC	BUFRHI	;increment high buffer pointer
00EAB5  1               
00EAB5  1               ;	Check end of buffer.
00EAB5  1               
00EAB5  1  A5 32        ORI1	LDA	BUFRLO	;buffer address
00EAB7  1  C5 34        	CMP	BFENLO	;buffer end address
00EAB9  1  A5 33        	LDA	BUFRHI
00EABB  1  E5 35        	SBC	BFENHI
00EABD  1  90 1C        	BCC	ORI4	;if not past end of buffer
00EABF  1               
00EABF  1               ;	Process end of buffer.
00EABF  1               
00EABF  1  A5 3B        	LDA	CHKSNT	;checksum sent flag
00EAC1  1  D0 0B        	BNE	ORI2	;if checksum already sent
00EAC3  1               
00EAC3  1               ;	Send checksum.
00EAC3  1               
00EAC3  1  A5 31        	LDA	CHKSUM	;checksum
00EAC5  1  8D 0D D2     	STA	SEROUT	;serial output register
00EAC8  1  A9 FF        	LDA	#$FF
00EACA  1  85 3B        	STA	CHKSNT	;indicate checksum sent
00EACC  1  D0 09        	BNE	ORI3
00EACE  1               
00EACE  1               ;	Enable TRANSMIT done interrupt.
00EACE  1               
00EACE  1  A5 10        ORI2	LDA	POKMSK
00EAD0  1  09 08        	ORA	#$08
00EAD2  1  85 10        	STA	POKMSK
00EAD4  1  8D 0E D2     	STA	IRQEN
00EAD7  1               
00EAD7  1               ;	Exit.
00EAD7  1               
00EAD7  1  68           ORI3	PLA
00EAD8  1  A8           	TAY		;restore Y
00EAD9  1  68           	PLA		;restore A
00EADA  1  40           	RTI		;return
00EADB  1               
00EADB  1               ;	Transmit next byte from buffer.
00EADB  1               
00EADB  1  A0 00        ORI4	LDY	#0
00EADD  1  B1 32        	LDA	(BUFRLO),Y	;byte from buffer
00EADF  1  8D 0D D2     	STA	SEROUT		;serial output register
00EAE2  1  18           	CLC
00EAE3  1  65 31        	ADC	CHKSUM		;add byte to checksum
00EAE5  1  69 00        	ADC	#0
00EAE7  1  85 31        	STA	CHKSUM		;update checksum
00EAE9  1  4C D7 EA     	JMP	ORI3		;exit
00EAEC  1               ;	SPACE	4,10
00EAEC  1               ;**	OCIR - Process Serial Output Complete IRQ
00EAEC  1               ;*
00EAEC  1               ;*	ENTRY	JMP	OCIR
00EAEC  1               ;*
00EAEC  1               ;*	EXIT
00EAEC  1               ;*		Exits via RTI
00EAEC  1               ;*
00EAEC  1               ;*	MODS
00EAEC  1               ;*		Original Author Unknown
00EAEC  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00EAEC  1               ;*		   R. K. Nordin	11/01/83
00EAEC  1               
00EAEC  1               
00EAEC  1               OCIR	=	*	;entry
00EAEC  1               
00EAEC  1               ;	Check checksum sent.
00EAEC  1               
00EAEC  1  A5 3B        	LDA	CHKSNT	;checksum sent flag
00EAEE  1  F0 0B        	BEQ	OCI1	;if checksum not yet sent
00EAF0  1               
00EAF0  1               ;	Process checksum sent.
00EAF0  1               
00EAF0  1  85 3A        	STA	XMTDON	;indicate transmit-frame done
00EAF2  1               
00EAF2  1               ;	Disable TRANSMIT done interrupt.
00EAF2  1               
00EAF2  1  A5 10        	LDA	POKMSK
00EAF4  1  29 F7        	AND	#$F7
00EAF6  1  85 10        	STA	POKMSK
00EAF8  1  8D 0E D2     	STA	IRQEN
00EAFB  1               
00EAFB  1               ;	Exit.
00EAFB  1               
00EAFB  1  68           OCI1	PLA		;restore A
00EAFC  1  40           	RTI		;return
00EAFD  1               ;	SPACE	4,10
00EAFD  1               ;**	REC - Receive
00EAFD  1               ;*
00EAFD  1               ;*	ENTRY	JSR	REC
00EAFD  1               ;*
00EAFD  1               ;*	MODS
00EAFD  1               ;*		Original Author Unknown
00EAFD  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00EAFD  1               ;*		   R. K. Nordin	11/01/83
00EAFD  1               
00EAFD  1               
00EAFD  1               REC	=	*	;entry
00EAFD  1               
00EAFD  1               ;	Initialize.
00EAFD  1               
00EAFD  1  A9 00        	LDA	#0
00EAFF  1  AC 0F 03     	LDY	CASFLG
00EB02  1  D0 02        	BNE	REC1	;if cassette
00EB04  1               
00EB04  1  85 31        	STA	CHKSUM	;initialize checksum
00EB06  1               
00EB06  1  85 38        REC1	STA	BUFRFL	;clear buffer full flag
00EB08  1  85 39        	STA	RECVDN	;clear receive-frame done flag
00EB0A  1  A9 01        	LDA	#SUCCES	;assume success
00EB0C  1  85 30        	STA	STATUS	;status
00EB0E  1  20 40 EC     	JSR	ESR	;enable SIO RECEIVE
00EB11  1  A9 3C        	LDA	#NCOMHI
00EB13  1  8D 03 D3     	STA	PBCTL
00EB16  1               
00EB16  1               ;	Check BREAK key.
00EB16  1               
00EB16  1  A5 11        REC2	LDA	BRKKEY
00EB18  1  D0 03        	BNE	REC3	;if BREAK key not pressed
00EB1A  1               
00EB1A  1               ;	Process BREAK key.
00EB1A  1               
00EB1A  1  4C C7 ED     	JMP	PBK	;process BREAK key, return
00EB1D  1               
00EB1D  1               ;	Process BREAK key not pressed.
00EB1D  1               
00EB1D  1  AD 17 03     REC3	LDA	TIMFLG	;timeout flag
00EB20  1  F0 05        	BEQ	ITO	;if timeout, indicate timeout
00EB22  1               
00EB22  1               ;	Process no timeout.
00EB22  1               
00EB22  1  A5 39        	LDA	RECVDN	;receive-frame done flag
00EB24  1  F0 F0        	BEQ	REC2	;if receive-frame done, continue
00EB26  1               
00EB26  1               ;	Exit.
00EB26  1               
00EB26  1  60           	RTS		;return
00EB27  1               ;	SPACE	4,10
00EB27  1               ;**	ITO - Indicate Timeout
00EB27  1               ;*
00EB27  1               ;*	ENTRY	JSR	ITO
00EB27  1               ;*
00EB27  1               ;*	MODS
00EB27  1               ;*		Original Author Unknown
00EB27  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00EB27  1               ;*		   R. K. Nordin	11/01/83
00EB27  1               
00EB27  1               
00EB27  1               ITO	=	*	;entry
00EB27  1  A9 8A        	LDA	#TIMOUT	;timeout indicator
00EB29  1  85 30        	STA	STATUS	;indicate timeout
00EB2B  1  60           	RTS		;return
00EB2C  1               ;	SPACE	4,10
00EB2C  1               ;**	IRIR - Process Serial Input Ready IRQ
00EB2C  1               ;*
00EB2C  1               ;*	ENTRY	JMP	IRIR
00EB2C  1               ;*
00EB2C  1               ;*	EXIT
00EB2C  1               ;*		Exits via RTI
00EB2C  1               ;*
00EB2C  1               ;*	MODS
00EB2C  1               ;*		Original Author Unknown
00EB2C  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00EB2C  1               ;*		   R. K. Nordin	11/01/83
00EB2C  1               
00EB2C  1               
00EB2C  1               IRIR	=	*	;entry
00EB2C  1               
00EB2C  1               ;	Initialize.
00EB2C  1               
00EB2C  1  98           	TYA
00EB2D  1  48           	PHA		;save Y
00EB2E  1  AD 0F D2     	LDA	SKSTAT
00EB31  1  8D 0A D2     	STA	SKRES	;reset status register
00EB34  1               
00EB34  1               ;	Check for frame error.
00EB34  1               
00EB34  1  30 04        	BMI	IRI1	;if no frame error
00EB36  1               
00EB36  1               ;	Process frame error.
00EB36  1               
00EB36  1  A0 8C        	LDY	#FRMERR	;frame error
00EB38  1  84 30        	STY	STATUS	;indicate frame error
00EB3A  1               
00EB3A  1               ;	Check for overrun error.
00EB3A  1               
00EB3A  1  29 20        IRI1	AND	#$20
00EB3C  1  D0 04        	BNE	IRI2	;if no overrun error
00EB3E  1               
00EB3E  1               ;	Process overrun error.
00EB3E  1               
00EB3E  1  A0 8E        	LDY	#OVRRUN	;overrun error
00EB40  1  84 30        	STY	STATUS	;indicate overrun error
00EB42  1               
00EB42  1               ;	Check for buffer full.
00EB42  1               
00EB42  1  A5 38        IRI2	LDA	BUFRFL
00EB44  1  F0 13        	BEQ	IRI5	;if buffer not yet full
00EB46  1               
00EB46  1               ;	Process buffer full.
00EB46  1               
00EB46  1  AD 0D D2     	LDA	SERIN	;checksum from device
00EB49  1  C5 31        	CMP	CHKSUM	;computed checksum
00EB4B  1  F0 04        	BEQ	IRI3	;if checksums match
00EB4D  1               
00EB4D  1               ;	Process checksum error.
00EB4D  1               
00EB4D  1  A0 8F        	LDY	#CHKERR	;checksum error
00EB4F  1  84 30        	STY	STATUS	;indicate checksum error
00EB51  1               
00EB51  1               ;	Indicate receive-frame done.
00EB51  1               
00EB51  1  A9 FF        IRI3	LDA	#$FF	;receive-frame done indicator
00EB53  1  85 39        	STA	RECVDN	;indicate receive-frame done
00EB55  1               
00EB55  1               ;	Exit.
00EB55  1               
00EB55  1  68           IRI4	PLA
00EB56  1  A8           	TAY		;restore Y
00EB57  1  68           	PLA		;restore A
00EB58  1  40           	RTI		;return
00EB59  1               
00EB59  1               ;	Process buffer not full.
00EB59  1               
00EB59  1  AD 0D D2     IRI5	LDA	SERIN		;serial input register
00EB5C  1  A0 00        	LDY	#0
00EB5E  1  91 32        	STA	(BUFRLO),Y	;byte of buffer
00EB60  1  18           	CLC
00EB61  1  65 31        	ADC	CHKSUM		;add byte to checksum
00EB63  1  69 00        	ADC	#0
00EB65  1  85 31        	STA	CHKSUM		;update checksum
00EB67  1  E6 32        	INC	BUFRLO		;increment low buffer pointer
00EB69  1  D0 02        	BNE	IRI6		;if low buffer pointer non-zero
00EB6B  1               
00EB6B  1  E6 33        	INC	BUFRHI		;increment high buffer pointer
00EB6D  1               
00EB6D  1               ;	Check end of buffer.
00EB6D  1               
00EB6D  1  A5 32        IRI6	LDA	BUFRLO		;buffer address
00EB6F  1  C5 34        	CMP	BFENLO		;buffer end address
00EB71  1  A5 33        	LDA	BUFRHI
00EB73  1  E5 35        	SBC	BFENHI
00EB75  1  90 DE        	BCC	IRI4		;if not past end of buffer
00EB77  1               
00EB77  1               ;	Process end of buffer.
00EB77  1               
00EB77  1  A5 3C        	LDA	NOCKSM		;no checksum follows flag
00EB79  1  F0 06        	BEQ	IRI7		;if checksum will follow
00EB7B  1               
00EB7B  1               ;	Process no checksum will follow.
00EB7B  1               
00EB7B  1  A9 00        	LDA	#0
00EB7D  1  85 3C        	STA	NOCKSM		;clear no checksum follows flag
00EB7F  1  F0 D0        	BEQ	IRI3		;indicate receive-frame done
00EB81  1               
00EB81  1               ;	Process checksum will follow.
00EB81  1               
00EB81  1  A9 FF        IRI7	LDA	#$FF
00EB83  1  85 38        	STA	BUFRFL		;indicate buffer full
00EB85  1  D0 CE        	BNE	IRI4		;exit
00EB87  1               ;	SPACE	4,10
00EB87  1               ;**	SBP - Set Buffer Pointers
00EB87  1               ;*
00EB87  1               ;*	ENTRY	JSR	SBP
00EB87  1               ;*
00EB87  1               ;*	MODS
00EB87  1               ;*		Original Author Unknown
00EB87  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00EB87  1               ;*		   R. K. Nordin	11/01/83
00EB87  1               
00EB87  1               
00EB87  1               SBP	=	*	;entry
00EB87  1  18           	CLC
00EB88  1  AD 04 03     	LDA	DBUFLO
00EB8B  1  85 32        	STA	BUFRLO	;low buffer address
00EB8D  1  6D 08 03     	ADC	DBYTLO
00EB90  1  85 34        	STA	BFENLO	;low buffer end address
00EB92  1  AD 05 03     	LDA	DBUFHI
00EB95  1  85 33        	STA	BUFRHI	;high buffer address
00EB97  1  6D 09 03     	ADC	DBYTHI
00EB9A  1  85 35        	STA	BFENHI	;high buffer end address
00EB9C  1  60           	RTS		;return
00EB9D  1               ;	SPACE	4,10
00EB9D  1               ;**	PCI - Process Cassette I/O
00EB9D  1               ;*
00EB9D  1               ;*	ENTRY	JSR	PCI
00EB9D  1               ;*
00EB9D  1               ;*	MODS
00EB9D  1               ;*		Original Author Unknown
00EB9D  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00EB9D  1               ;*		   R. K. Nordin	11/01/83
00EB9D  1               
00EB9D  1               
00EB9D  1               PCI	=	*	;entry
00EB9D  1               
00EB9D  1               ;	Check command type.
00EB9D  1               
00EB9D  1  AD 03 03     	LDA	DSTATS		;command type
00EBA0  1  10 32        	BPL	PCI3		;if READ
00EBA2  1               
00EBA2  1               ;	Write a record.
00EBA2  1               
00EBA2  1  A9 CC        	LDA	#low B00600
00EBA4  1  8D 04 D2     	STA	AUDF3		;set 600 baud
00EBA7  1  A9 05        	LDA	#high B00600
00EBA9  1  8D 06 D2     	STA	AUDF4
00EBAC  1  20 17 EC     	JSR	ESS		;enable SIO SEND
00EBAF  1  A6 62        	LDX	PALNTS		;PAL/NTSC offset
00EBB1  1  BC 15 EE     	LDY	WSIRGX,X	;low short WRITE IRG time
00EBB4  1  AD 0B 03     	LDA	DAUX2		;IRG type
00EBB7  1  30 03        	BMI	PCI1		;if short IRG is desired
00EBB9  1               
00EBB9  1  BC 11 EE     	LDY	WIRGLX,X	;low long WRITE IRG time
00EBBC  1               
00EBBC  1  A2 00        PCI1	LDX	#WIRGHI		;high IRG time
00EBBE  1  20 E2 ED     	JSR	SSV		;set SIO VBLANK parameters
00EBC1  1  A9 34        	LDA	#MOTRGO
00EBC3  1  8D 02 D3     	STA	PACTL		;turn on motor
00EBC6  1               
00EBC6  1  AD 17 03     PCI2	LDA	TIMFLG		;timeout flag
00EBC9  1  D0 FB        	BNE	PCI2		;if no timeout
00EBCB  1               
00EBCB  1  20 87 EB     	JSR	SBP		;set buffer pointers
00EBCE  1  20 88 EA     	JSR	SEN		;send
00EBD1  1  4C 04 EC     	JMP	PCI6		;exit
00EBD4  1               
00EBD4  1               ;	Read a record.
00EBD4  1               
00EBD4  1  A9 FF        PCI3	LDA	#$FF		;cassette I/O indicator
00EBD6  1  8D 0F 03     	STA	CASFLG		;cassette I/O flag
00EBD9  1               
00EBD9  1  A6 62        	LDX	PALNTS		;PAL/NTSC offset
00EBDB  1  BC 17 EE     	LDY	RSIRGX,X	;low short READ IRG time
00EBDE  1  AD 0B 03     	LDA	DAUX2		;IRG type
00EBE1  1  30 03        	BMI	PCI4		;if short IRG desired
00EBE3  1               
00EBE3  1  BC 13 EE     	LDY	RIRGLX,X	;low long READ IRG time
00EBE6  1               
00EBE6  1  A2 00        PCI4	LDX	#RIRGHI		;high READ IRG time
00EBE8  1  20 E2 ED     	JSR	SSV		;set SIO VBLANK parameters
00EBEB  1  A9 34        	LDA	#MOTRGO
00EBED  1  8D 02 D3     	STA	PACTL		;turn on motor
00EBF0  1               
00EBF0  1  AD 17 03     PCI5	LDA	TIMFLG		;timeout flag
00EBF3  1  D0 FB        	BNE	PCI5		;if no timeout
00EBF5  1               
00EBF5  1  20 87 EB     	JSR	SBP		;set buffer pointers
00EBF8  1  20 9A EC     	JSR	GTO		;get device timeout
00EBFB  1  20 E2 ED     	JSR	SSV		;set SIO VBLANK parameters
00EBFE  1  20 3D ED     	JSR	SBR		;set initial baud rate
00EC01  1  20 FD EA     	JSR	REC		;receive
00EC04  1               
00EC04  1               ;	Exit.
00EC04  1               
00EC04  1  AD 0B 03     PCI6	LDA	DAUX2		;IRG type
00EC07  1  30 05        	BMI	PCI7		;if doing short IRG
00EC09  1               
00EC09  1  A9 3C        	LDA	#MOTRST
00EC0B  1  8D 02 D3     	STA	PACTL		;turn off motor
00EC0E  1               
00EC0E  1  4C 2A EA     PCI7	JMP	CSO		;complete SIO operation, return
00EC11  1               ;	SPACE	4,10
00EC11  1               ;**	PTE - Process Timer Expiration
00EC11  1               ;*
00EC11  1               ;*	ENTRY	JSR	PTE
00EC11  1               ;*
00EC11  1               ;*	MODS
00EC11  1               ;*		Original Author Unknown
00EC11  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00EC11  1               ;*		   R. K. Nordin	11/01/83
00EC11  1               
00EC11  1               
00EC11  1               PTE	=	*	;entry
00EC11  1  A9 00        	LDA	#0	;timeout indicator
00EC13  1  8D 17 03     	STA	TIMFLG	;timeout flag
00EC16  1  60           	RTS		;return
00EC17  1               ;	SPACE	4,10
00EC17  1               ;**	ESS - Enable SIO SEND
00EC17  1               ;*
00EC17  1               ;*	ENTRY	JSR	ESS
00EC17  1               ;*
00EC17  1               ;*	MODS
00EC17  1               ;*		Original Author Unknown
00EC17  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00EC17  1               ;*		   R. K. Nordin	11/01/83
00EC17  1               
00EC17  1               
00EC17  1               ESS	=	*	;entry
00EC17  1               
00EC17  1               ;	Initialize.
00EC17  1               
00EC17  1  A9 07        	LDA	#$07	;mask off previous serail bus control bits
00EC19  1  2D 32 02     	AND	SSKCTL
00EC1C  1  09 20        	ORA	#$20	;set SEND mode
00EC1E  1               
00EC1E  1               ;	Check device type.
00EC1E  1               
00EC1E  1  AC 00 03     	LDY	DDEVIC
00EC21  1  C0 60        	CPY	#CASET
00EC23  1  D0 0C        	BNE	ESS1	;if not cassette
00EC25  1               
00EC25  1               ;	Process cassette.
00EC25  1               
00EC25  1  09 08        	ORA	#$08	;set FSK output
00EC27  1  A0 07        	LDY	#LOTONE	;set FSK tone frequencies
00EC29  1  8C 02 D2     	STY	AUDF2
00EC2C  1  A0 05        	LDY	#HITONE
00EC2E  1  8C 00 D2     	STY	AUDF1
00EC31  1               
00EC31  1               ;	Set serial bus control.
00EC31  1               
00EC31  1  8D 32 02     ESS1	STA	SSKCTL	;SKCTL shadow
00EC34  1  8D 0F D2     	STA	SKCTL
00EC37  1  A9 C7        	LDA	#$C7	;mask off previous serial bus interrupt bits
00EC39  1  25 10        	AND	POKMSK	;and with POKEY IRQ enable
00EC3B  1  09 10        	ORA	#$10	;enable output data needed interrupt
00EC3D  1  4C 56 EC     	JMP	SSR	;set for SEND, return
00EC40  1               ;	SPACE	4,10
00EC40  1               ;**	ESR - Enable SIO RECEIVE
00EC40  1               ;*
00EC40  1               ;*	ENTRY	JSR	ESR
00EC40  1               ;*
00EC40  1               ;*	MODS
00EC40  1               ;*		Original Author Unknown
00EC40  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00EC40  1               ;*		   R. K. Nordin	11/01/83
00EC40  1               
00EC40  1               
00EC40  1               ESR	=	*	;entry
00EC40  1  A9 07        	LDA	#$07	;mask off previous serial bus control bits
00EC42  1  2D 32 02     	AND	SSKCTL
00EC45  1  09 10        	ORA	#$10	;set receive mode asynchronous
00EC47  1  8D 32 02     	STA	SSKCTL	;SKCTL shadow
00EC4A  1  8D 0F D2     	STA	SKCTL
00EC4D  1  8D 0A D2     	STA	SKRES
00EC50  1  A9 C7        	LDA	#$C7	;mask off previous serial bus interrupt bits
00EC52  1  25 10        	AND	POKMSK	;and with POKEY IRQ enable
00EC54  1  09 20        	ORA	#$20	;enable RECEIVE interrupt
00EC56  1               ;	JMP	SSR	;set for RECEIVE, return
00EC56  1               ;	SPACE	4,10
00EC56  1               ;**	SSR - Set for SEND or RECEIVE
00EC56  1               ;*
00EC56  1               ;*	ENTRY	JSR	SSR
00EC56  1               ;*
00EC56  1               ;*	MODS
00EC56  1               ;*		Original Author Unknown
00EC56  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00EC56  1               ;*		   R. K. Nordin	11/01/83
00EC56  1               
00EC56  1               
00EC56  1               SSR	=	*	;entry
00EC56  1               
00EC56  1               ;	Initialize.
00EC56  1               
00EC56  1  85 10        	STA	POKMSK	;update POKEY IRQ enable
00EC58  1  8D 0E D2     	STA	IRQEN	;IRQ enable
00EC5B  1  A9 28        	LDA	#$28	;clock ch. 3 with 1.79 MHz, ch. 4 with ch. 3
00EC5D  1  8D 08 D2     	STA	AUDCTL	;set audio control
00EC60  1               
00EC60  1               ;	Set voice controls.
00EC60  1               
00EC60  1  A2 06        	LDX	#6	;offset to last voice control
00EC62  1  A9 A8        	LDA	#$A8	;pure tone, half volume
00EC64  1  A4 41        	LDY	SOUNDR	;noisy I/O flag
00EC66  1  D0 02        	BNE	SSR1	;if noisy I/O desired
00EC68  1               
00EC68  1  A9 A0        	LDA	#$A0	;pure tone, no volume
00EC6A  1               
00EC6A  1  9D 01 D2     SSR1	STA	AUDC1,X	;set tone and volume
00EC6D  1  CA           	DEX
00EC6E  1  CA           	DEX
00EC6F  1  10 F9        	BPL	SSR1	;if not done
00EC71  1               
00EC71  1               ;	Turn off certain voices.
00EC71  1               
00EC71  1  A9 A0        	LDA	#$A0	;pure tone, no volume
00EC73  1  8D 05 D2     	STA	AUDC3	;turn off sound on voice 3
00EC76  1  AC 00 03     	LDY	DDEVIC	;device bus ID
00EC79  1  C0 60        	CPY	#CASET	;cassette device ID
00EC7B  1  F0 06        	BEQ	SSR2	;if cassette device
00EC7D  1               
00EC7D  1  8D 01 D2     	STA	AUDC1	;turn off sound on voice 1
00EC80  1  8D 03 D2     	STA	AUDC2	;turn off sound on voice 2
00EC83  1               
00EC83  1  60           SSR2	RTS		;return
00EC84  1               ;	SPACE	4,10
00EC84  1               ;**	DSR - Disable SEND and RECEIVE
00EC84  1               ;*
00EC84  1               ;*	ENTRY	JSR	DSR
00EC84  1               ;*
00EC84  1               ;*	NOTES
00EC84  1               ;*		Problem: NOP may not be necessary.
00EC84  1               ;*
00EC84  1               ;*	MODS
00EC84  1               ;*		Original Author Unknown
00EC84  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00EC84  1               ;*		   R. K. Nordin	11/01/83
00EC84  1               
00EC84  1               
00EC84  1               DSR	=	*	;entry
00EC84  1               
00EC84  1               ;	Disable serial bus interrupts.
00EC84  1               
00EC84  1  EA           	NOP
00EC85  1  A9 C7        	LDA	#$C7	;mask to clear serial bus interrupts
00EC87  1  25 10        	AND	POKMSK	;and with POKEY IRQ enable
00EC89  1  85 10        	STA	POKMSK	;update POKEY IRQ enable
00EC8B  1  8D 0E D2     	STA	IRQEN	;IRQ enable
00EC8E  1               
00EC8E  1               ;	Turn off audio volume.
00EC8E  1               
00EC8E  1  A2 06        	LDX	#6	;offset to last voice control
00EC90  1  A9 00        	LDA	#$00	;no volume
00EC92  1               
00EC92  1  9D 01 D2     DSR1	STA	AUDC1,X	;turn off voice
00EC95  1  CA           	DEX
00EC96  1  CA           	DEX
00EC97  1  10 F9        	BPL	DSR1	;if not done
00EC99  1               
00EC99  1  60           	RTS		;return
00EC9A  1               ;	SPACE	4,10
00EC9A  1               ;**	GTO - Get Device Timeout
00EC9A  1               ;*
00EC9A  1               ;*	ENTRY	JSR	GTO
00EC9A  1               ;*
00EC9A  1               ;*	MODS
00EC9A  1               ;*		Original Author Unknown
00EC9A  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00EC9A  1               ;*		   R. K. Nordin	11/01/83
00EC9A  1               
00EC9A  1               
00EC9A  1               GTO	=	*	;entry
00EC9A  1  AD 06 03     	LDA	DTIMLO	;device timeout
00EC9D  1  6A           	ROR	A
00EC9E  1  6A           	ROR	A
00EC9F  1  A8           	TAY		;rotated timeout
00ECA0  1  29 3F        	AND	#$3F	;lower 6 bits
00ECA2  1  AA           	TAX		;high timeout
00ECA3  1  98           	TYA		;rotated timeout
00ECA4  1  6A           	ROR	A
00ECA5  1  29 C0        	AND	#$C0	;upper 2 bits
00ECA7  1  A8           	TAY		;low timeout
00ECA8  1  60           	RTS		;return
00ECA9  1               ;	SPACE	4,10
00ECA9  1               ;**	TSIH - Table of SIO Interrupt Handlers
00ECA9  1               ;*
00ECA9  1               ;*	NOTES
00ECA9  1               ;*		Problem: not used.
00ECA9  1               
00ECA9  1               
00ECA9  1  2C EB AD EA  TSIH	DW	IRIR	;serial input ready IRQ
00ECAD  1  EC EA        
00ECAF  1               	DW	ORIR	;serial output ready IRQ
00ECAF  1               	DW	OCIR	;serial output complete IRQ
00ECAF  1               ;	SPACE	4,10
00ECAF  1               ;**	SID - Send to Intelligent Device
00ECAF  1               ;*
00ECAF  1               ;*	ENTRY	JSR	SID
00ECAF  1               ;*
00ECAF  1               ;*	NOTES
00ECAF  1               ;*		Problem: bytes wasted by outer delay loop.
00ECAF  1               ;*
00ECAF  1               ;*	MODS
00ECAF  1               ;*		Original Author Unknown
00ECAF  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00ECAF  1               ;*		   R. K. Nordin	11/01/83
00ECAF  1               
00ECAF  1               
00ECAF  1               SID	=	*	;entry
00ECAF  1               
00ECAF  1               ;	Delay.
00ECAF  1               
00ECAF  1  A2 01        	LDX	#1
00ECB1  1               
00ECB1  1  A0 FF        SID1	LDY	#255
00ECB3  1               
00ECB3  1  88           SID2	DEY
00ECB4  1  D0 FD        	BNE	SID2		;if inner loop not done
00ECB6  1               
00ECB6  1  CA           	DEX
00ECB7  1  D0 F8        	BNE	SID1		;if outer loop not done
00ECB9  1               
00ECB9  1               ;	Send data frame.
00ECB9  1               
00ECB9  1  20 88 EA     	JSR	SEN		;send
00ECBC  1               
00ECBC  1               ;	Set timer and wait.
00ECBC  1               
00ECBC  1  A0 02        	LDY	#low CTIM	;frame acknowledge timeout
00ECBE  1  A2 00        	LDX	#high CTIM
00ECC0  1               ;	JMP	STW		;set timer and wait, return
00ECC0  1               ;	SPACE	4,10
00ECC0  1               ;**	STW - Set Timer and Wait
00ECC0  1               ;*
00ECC0  1               ;*	ENTRY	JSR	STW
00ECC0  1               ;*
00ECC0  1               ;*	MODS
00ECC0  1               ;*		Original Author Unknown
00ECC0  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00ECC0  1               ;*		   R. K. Nordin	11/01/83
00ECC0  1               
00ECC0  1               
00ECC0  1               STW	=	*	;entry
00ECC0  1  20 E2 ED     	JSR	SSV	;set SIO VBLANK parameters
00ECC3  1  20 37 EA     	JSR	WCA	;wait for completion or ACK
00ECC6  1  98           	TYA		;wait termination status
00ECC7  1  60           	RTS		;return
00ECC8  1               ;	SPACE	4,10
00ECC8  1               ;**	CBR - Compute Baud Rate
00ECC8  1               ;*
00ECC8  1               ;*	CBR computes value for POKEY frequency for the baud rate as
00ECC8  1               ;*	measured by an interval of the VCOUNT timer.
00ECC8  1               ;*
00ECC8  1               ;*	ENTRY	JSR	CBR
00ECC8  1               ;*
00ECC8  1               ;*	MODS
00ECC8  1               ;*		Original Author Unknown
00ECC8  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00ECC8  1               ;*		   R. K. Nordin	11/01/83
00ECC8  1               
00ECC8  1               
00ECC8  1               CBR	=	*		;entry
00ECC8  1  8D 10 03     	STA	TIMER2		;save final timer value
00ECCB  1  8C 11 03     	STY	TIMER2+1
00ECCE  1  20 2E ED     	JSR	AVV		;adjust VCOUNT value
00ECD1  1  8D 10 03     	STA	TIMER2		;save adjusted timer 2 value
00ECD4  1  AD 0C 03     	LDA	TIMER1
00ECD7  1  20 2E ED     	JSR	AVV		;adjust VCOUNT value
00ECDA  1  8D 0C 03     	STA	TIMER1		;save adjusted timer 1 value
00ECDD  1  AD 10 03     	LDA	TIMER2
00ECE0  1  38           	SEC
00ECE1  1  ED 0C 03     	SBC	TIMER1
00ECE4  1  8D 12 03     	STA	TEMP1		;save difference
00ECE7  1  AD 11 03     	LDA	TIMER2+1
00ECEA  1  38           	SEC
00ECEB  1  ED 0D 03     	SBC	TIMER1+1
00ECEE  1  A8           	TAY			;difference
00ECEF  1  A6 62        	LDX	PALNTS
00ECF1  1  A9 00        	LDA	#0
00ECF3  1  38           	SEC
00ECF4  1  FD 19 EE     	SBC	CONS1X,X
00ECF7  1               
00ECF7  1  18           CBR1	CLC
00ECF8  1  7D 19 EE     	ADC	CONS1X,X	;accumulate product
00ECFB  1  88           	DEY
00ECFC  1  10 F9        	BPL	CBR1		;if not done
00ECFE  1               
00ECFE  1  18           	CLC
00ECFF  1  6D 12 03     	ADC	TEMP1		;add to get total VCOUNT difference
00ED02  1  A8           	TAY			;total VCOUNT difference
00ED03  1  4A           	LSR	A
00ED04  1  4A           	LSR	A
00ED05  1  4A           	LSR	A
00ED06  1  0A           	ASL	A		;interval divided by 4
00ED07  1  38           	SEC
00ED08  1  E9 16        	SBC	#22		;adjust offset
00ED0A  1  AA           	TAX			;offset
00ED0B  1  98           	TYA			;total VCOUNT difference
00ED0C  1  29 07        	AND	#7		;extract lower 3 bits of interval
00ED0E  1  A8           	TAY			;lower 3 bits of interval
00ED0F  1  A9 F5        	LDA	#<-11
00ED11  1               
00ED11  1  18           CBR2	CLC
00ED12  1  69 0B        	ADC	#11		;accumulate interpolation constant
00ED14  1  88           	DEY
00ED15  1  10 FA        	BPL	CBR2		;if done
00ED17  1               
00ED17  1  A0 00        	LDY	#0		;assume no addition correction
00ED19  1  38           	SEC
00ED1A  1  E9 07        	SBC	#7		;adjust interpolation constant
00ED1C  1  10 01        	BPL	CBR3
00ED1E  1               
00ED1E  1  88           	DEY			;indicate addition correction
00ED1F  1               
00ED1F  1  18           CBR3	CLC
00ED20  1  7D F9 ED     	ADC	TPFV,X		;add constant to table value
00ED23  1  8D EE 02     	STA	CBAUDL		;low POKEY frequency value
00ED26  1  98           	TYA
00ED27  1  7D FA ED     	ADC	TPFV+1,X
00ED2A  1  8D EF 02     	STA	CBAUDH		;high POKEY frequency value
00ED2D  1  60           	RTS			;return
00ED2E  1               ;	SPACE	4,10
00ED2E  1               ;**	AVV - Adjust VCOUNT Value
00ED2E  1               ;*
00ED2E  1               ;*	ENTRY	JSR	AVV
00ED2E  1               ;*
00ED2E  1               ;*	MODS
00ED2E  1               ;*		Original Author Unknown
00ED2E  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00ED2E  1               ;*		   R. K. Nordin	11/01/83
00ED2E  1               
00ED2E  1               
00ED2E  1               AVV	=	*	;entry
00ED2E  1  C9 7C        	CMP	#$7C
00ED30  1  30 04        	BMI	AVV1	;if >= $7C
00ED32  1               
00ED32  1  38           	SEC
00ED33  1  E9 7C        	SBC	#$7C
00ED35  1  60           	RTS		;return
00ED36  1               
00ED36  1  18           AVV1	CLC
00ED37  1  A6 62        	LDX	PALNTS
00ED39  1  7D 1B EE     	ADC	CONS2X,X
00ED3C  1  60           	RTS		;return
00ED3D  1               ;	SPACE	4,10
00ED3D  1               ;**	SBR - Set Initial Baud Rate
00ED3D  1               ;*
00ED3D  1               ;*	INITIAL BAUD RATE MEASUREMENT -- USED TO SET THE
00ED3D  1               ;*	BAUD RATE AT THE START OF A RECORD.
00ED3D  1               ;*
00ED3D  1               ;*	IT IS ASSUMED THAT THE FIRST TWO BYTES OF EVERY
00ED3D  1               ;*	RECORD ARE $AA.
00ED3D  1               ;*
00ED3D  1               ;*	ENTRY	JSR	SBR
00ED3D  1               ;*
00ED3D  1               ;*	NOTES
00ED3D  1               ;*		Problem: bytes wasted by branch around branch (SBR3).
00ED3D  1               ;*
00ED3D  1               ;*	MODS
00ED3D  1               ;*		Original Author Unknown
00ED3D  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00ED3D  1               ;*		   R. K. Nordin	11/01/83
00ED3D  1               
00ED3D  1               
00ED3D  1               SBR	=	*		;entry
00ED3D  1               
00ED3D  1  A5 11        SBR1	LDA	BRKKEY
00ED3F  1  D0 03        	BNE	SBR2		;if BREAK key not pressed
00ED41  1               
00ED41  1  4C C7 ED     	JMP	PBK		;process BREAK key, return
00ED44  1               
00ED44  1  78           SBR2	SEI
00ED45  1  AD 17 03     	LDA	TIMFLG		;timeout flag
00ED48  1  D0 02        	BNE	SBR3		;if no timeout
00ED4A  1               
00ED4A  1  F0 25        	BEQ	SBR5		;process timeout
00ED4C  1               
00ED4C  1  AD 0F D2     SBR3	LDA	SKSTAT
00ED4F  1  29 10        	AND	#$10		;extract start bit
00ED51  1  D0 EA        	BNE	SBR1		;if start bit
00ED53  1               
00ED53  1  8D 16 03     	STA	SAVIO		;save serial data in
00ED56  1  AE 0B D4     	LDX	VCOUNT		;vertical line counter
00ED59  1  A4 14        	LDY	RTCLOK+2	;low byte of VBLANK clock
00ED5B  1  8E 0C 03     	STX	TIMER1
00ED5E  1  8C 0D 03     	STY	TIMER1+1	;save initial timer value
00ED61  1  A2 01        	LDX	#1
00ED63  1  8E 15 03     	STX	TEMP3		;set mode flag
00ED66  1  A0 0A        	LDY	#10		;10 bits
00ED68  1               
00ED68  1  A5 11        SBR4	LDA	BRKKEY
00ED6A  1  F0 5B        	BEQ	PBK		;if BREAK key pressed, process, return
00ED6C  1               
00ED6C  1  AD 17 03     	LDA	TIMFLG		;timeout flag
00ED6F  1  D0 04        	BNE	SBR6		;if no timeout
00ED71  1               
00ED71  1  58           SBR5	CLI
00ED72  1  4C 27 EB     	JMP	ITO		;indicate timeout, return
00ED75  1               
00ED75  1  AD 0F D2     SBR6	LDA	SKSTAT
00ED78  1  29 10        	AND	#$10		;extract
00ED7A  1  CD 16 03     	CMP	SAVIO		;previous serial data in
00ED7D  1  F0 E9        	BEQ	SBR4		;if data in not changed
00ED7F  1               
00ED7F  1  8D 16 03     	STA	SAVIO		;save serial data in
00ED82  1  88           	DEY			;decrement bit counter
00ED83  1  D0 E3        	BNE	SBR4		;if not done
00ED85  1               
00ED85  1  CE 15 03     	DEC	TEMP3		;decrement mode
00ED88  1  30 0C        	BMI	SBR7		;if done with both modes
00ED8A  1               
00ED8A  1  AD 0B D4     	LDA	VCOUNT
00ED8D  1  A4 14        	LDY	RTCLOK+2
00ED8F  1  20 C8 EC     	JSR	CBR		;compute baud rate
00ED92  1  A0 09        	LDY	#9		;9 bits
00ED94  1  D0 D2        	BNE	SBR4		;set bit counter
00ED96  1               
00ED96  1  AD EE 02     SBR7	LDA	CBAUDL
00ED99  1  8D 04 D2     	STA	AUDF3
00ED9C  1  AD EF 02     	LDA	CBAUDH
00ED9F  1  8D 06 D2     	STA	AUDF4		;set POKEY baud rate
00EDA2  1  A9 00        	LDA	#0
00EDA4  1  8D 0F D2     	STA	SKSTAT
00EDA7  1  AD 32 02     	LDA	SSKCTL
00EDAA  1  8D 0F D2     	STA	SKSTAT		;initialize POKEY serial port
00EDAD  1  A9 55        	LDA	#$55
00EDAF  1  91 32        	STA	(BUFRLO),Y	;first byte of buffer
00EDB1  1  C8           	INY
00EDB2  1  91 32        	STA	(BUFRLO),Y	;second byte of buffer
00EDB4  1  A9 AA        	LDA	#$AA		;checksum
00EDB6  1  85 31        	STA	CHKSUM		;checksum
00EDB8  1  18           	CLC
00EDB9  1  A5 32        	LDA	BUFRLO
00EDBB  1  69 02        	ADC	#2		;add 2
00EDBD  1  85 32        	STA	BUFRLO		;update low buffer pointer
00EDBF  1  A5 33        	LDA	BUFRHI
00EDC1  1  69 00        	ADC	#0
00EDC3  1  85 33        	STA	BUFRHI		;update high buffer pointer
00EDC5  1  58           	CLI
00EDC6  1  60           	RTS			;return
00EDC7  1               ;	SPACE	4,10
00EDC7  1               ;**	PBK - Process BREAK Key
00EDC7  1               ;*
00EDC7  1               ;*	ENTRY	JSR	PBK
00EDC7  1               ;*
00EDC7  1               ;*	MODS
00EDC7  1               ;*		Original Author Unknown
00EDC7  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00EDC7  1               ;*		   R. K. Nordin	11/01/83
00EDC7  1               
00EDC7  1               
00EDC7  1               PBK	=	*	;entry
00EDC7  1  20 84 EC     	JSR	DSR	;disable SEND and RECEIVE
00EDCA  1  A9 3C        	LDA	#MOTRST
00EDCC  1  8D 02 D3     	STA	PACTL	;turn off motor
00EDCF  1  A9 3C        	LDA	#NCOMHI
00EDD1  1  8D 03 D3     	STA	PBCTL	;raise NOT COMMAND line
00EDD4  1  A9 80        	LDA	#BRKABT	;BREAK abort error
00EDD6  1  85 30        	STA	STATUS	;status
00EDD8  1  AE 18 03     	LDX	STACKP	;saved stack pointer
00EDDB  1  9A           	TXS		;restore stack pointer
00EDDC  1  C6 11        	DEC	BRKKEY	;indicate BREAK
00EDDE  1  58           	CLI
00EDDF  1  4C 2A EA     	JMP	CSO	;complete SIO operation, return to caller of SIO
00EDE2  1               ;	SPACE	4,10
00EDE2  1               ;**	SSV - Set SIO VBLANK Parameters
00EDE2  1               ;*
00EDE2  1               ;*	ENTRY	JSR	SSV
00EDE2  1               ;*
00EDE2  1               ;*	MODS
00EDE2  1               ;*		Original Author Unknown	??/??/??
00EDE2  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00EDE2  1               ;*		   R. K. Nordin	11/01/83
00EDE2  1               
00EDE2  1               
00EDE2  1               SSV	=	*		;entry
00EDE2  1  A9 11        	LDA	#low PTE	;timer expiration routine address
00EDE4  1  8D 26 02     	STA	CDTMA1
00EDE7  1  A9 EC        	LDA	#high PTE
00EDE9  1  8D 27 02     	STA	CDTMA1+1
00EDEC  1  A9 01        	LDA	#1		;timer 1
00EDEE  1  78           	SEI
00EDEF  1  20 5C E4     	JSR	SETVBV		;set VBLANK parameters
00EDF2  1  A9 01        	LDA	#1		;no timeout indicator
00EDF4  1  8D 17 03     	STA	TIMFLG		;timeout flag
00EDF7  1  58           	CLI
00EDF8  1  60           	RTS			;return
00EDF9  1               ;	SPACE	4,10
00EDF9  1               ;**	TPFV - Table of POKEY Frequency Values
00EDF9  1               ;*
00EDF9  1               ;*	TPFV translates VCOUNT interval timer measurements to POKEY
00EDF9  1               ;*	frequency register values.
00EDF9  1               ;*
00EDF9  1               ;*	Table entries are AUDF+7.
00EDF9  1               ;*
00EDF9  1               ;*	Frequency-out is Frequency-in divided by 2*(AUDF+M), where
00EDF9  1               ;*	Frequency-in = 1.78979 Mhz and M = 7.
00EDF9  1               ;*
00EDF9  1               ;*	AUDF+7=(11.365167)*T-out, where T-out is the number of counts
00EDF9  1               ;*	(127 used cd soulution???) of VCOUNT for one character
00EDF9  1               ;*	time (10 bit times).
00EDF9  1               
00EDF9  1               
00EDF9  1               ;	DW	636	;baud rate 1407, VCOUNT interval 56
00EDF9  1               ;	DW	727	;baud rate 1231, VCOUNT interval 64
00EDF9  1               ;	DW	818	;baud rate 1094, VCOUNT interval 72
00EDF9  1               ;	DW	909	;baud rate 985, VCOUNT interval 80
00EDF9  1               
00EDF9  1  E8 03 43 04  TPFV	DW	1000	;baud rate 895, VCOUNT interval 88
00EDFD  1  9E 04 F9 04  
00EE01  1  54 05 AF 05  
00EE11  1               	DW	1091	;baud rate 820, VCOUNT interval 96
00EE11  1               	DW	1182	;baud rate 757, VCOUNT interval 104
00EE11  1               	DW	1273	;baud rate 703, VCOUNT interval 112
00EE11  1               	DW	1364	;baud rate 656, VCOUNT interval 120
00EE11  1               	DW	1455	;baud rate 615, VCOUNT interval 128
00EE11  1               	DW	1546	;baud rate 579, VCOUNT interval 136
00EE11  1               	DW	1637	;baud rate 547, VCOUNT interval 144
00EE11  1               	DW	1728	;baud rate 518, VCOUNT interval 152
00EE11  1               	DW	1818	;baud rate 492, VCOUNT interval 160
00EE11  1               	DW	1909	;baud rate 469, VCOUNT interval 168
00EE11  1               	DW	2000	;baud rate 447, VCOUNT interval 176
00EE11  1               
00EE11  1               ;	DW	2091	;baud rate 428, VCOUNT interval 184
00EE11  1               ;	DW	2182	;baud rate 410, VCOUNT interval 192
00EE11  1               ;	DW	2273	;baud rate 394, VCOUNT interval 200
00EE11  1               ;	DW	2364	;baud rate 379, VCOUNT interval 208
00EE11  1               ;	DW	2455	;baud rate 365, VCOUNT interval 216
00EE11  1               ;	DW	2546	;baud rate 352, VCOUNT interval 224
00EE11  1               ;	DW	2637	;baud rate 339, VCOUNT interval 232
00EE11  1               ;	DW	2728	;baud rate 328, VCOUNT interval 240
00EE11  1               ;	DW	2819	;baud rate 318, VCOUNT interval 248
00EE11  1               ;	SPACE	4,10
00EE11  1               ;**	NTSC/PAL Constant Tables
00EE11  1               
00EE11  1               
00EE11  1  B4 96        WIRGLX	DB	low WIRGLN	;NTSC low long write IRG
00EE13  1               	DB	low WIRGLP	;PAL low long write IRG
00EE13  1               
00EE13  1  78 64        RIRGLX	DB	low RIRGLN	;NTSC low long read IRG
00EE15  1               	DB	low RIRGLP	;PAL low long read IRG
00EE15  1               
00EE15  1  0F 0D        WSIRGX	DB	low WSIRGN	;NTSC low short write IRG
00EE17  1               	DB	low WSIRGP	;PAL low short write IRG
00EE17  1               
00EE17  1  0A 08        RSIRGX	DB	low RSIRGN	;NTSC low short read IRG
00EE19  1               	DB	low RSIRGP	;PAL low short read IRG
00EE19  1               
00EE19  1  83 9C        CONS1X	DB	131		;NTSC
00EE1B  1               	DB	156		;PAL
00EE1B  1               
00EE1B  1  07 20        CONS2X	DB	7		;NTSC
00EE1D  1               	DB	32		;PAL
00EE1D  1               ;	SUBTTL	'Keyboard, Editor and Screen Handler, Part 1'
00EE1D  1               ;	SPACE	4,10
00EE1D  1               ;**	TSMA - Table of Screen Memory Allocation
00EE1D  1               ;*
00EE1D  1               ;*	Entry n is the number of $40-byte blocks to allocate for
00EE1D  1               ;*	graphics mode n.
00EE1D  1               ;*
00EE1D  1               ;*	NOTES
00EE1D  1               ;*		Problem: For readability, this, and other t:
00EE1D  1               ;*		this area, could be moved closer to the oth:
00EE1D  1               ;*		the Keyboard, Editor and Screen Handler (ju:
00EE1D  1               ;*		the EF6B patch).
00EE1D  1               
00EE1D  1               
00EE1D  1  18 10 0A 0A  TSMA	DB	24	;0
00EE21  1  10 1C 34 64  
00EE25  1  C4 C4 C4 C4  
00EE2D  1               	DB	16	;1
00EE2D  1               	DB	10	;2
00EE2D  1               	DB	10	;3
00EE2D  1               	DB	16	;4
00EE2D  1               	DB	28	;5
00EE2D  1               	DB	52	;6
00EE2D  1               	DB	100	;7
00EE2D  1               	DB	196	;8
00EE2D  1               	DB	196	;9
00EE2D  1               	DB	196	;10
00EE2D  1               	DB	196	;11
00EE2D  1               	DB	28	;12
00EE2D  1               	DB	16	;13
00EE2D  1               	DB	100	;14
00EE2D  1               	DB	196	;15
00EE2D  1               ;	SPACE	4,10
00EE2D  1               ;**	TDLE - Table of Display List Entry Counts
00EE2D  1               ;*
00EE2D  1               ;*	Each entry is 2 bytes.
00EE2D  1               
00EE2D  1               
00EE2D  1  17 17 0B 17  TDLE	DB	23,23	;0
00EE31  1  2F 2F 5F 5F  
00EE35  1  61 61 61 61  
00EE4D  1               	DB	11,23	;1
00EE4D  1               	DB	47,47	;2
00EE4D  1               	DB	95,95	;3
00EE4D  1               	DB	97,97	;4
00EE4D  1               	DB	97,97	;5
00EE4D  1               	DB	23,11	;6
00EE4D  1               	DB	191,97	;7
00EE4D  1               	DB	19,19	;8
00EE4D  1               	DB	9,19	;9
00EE4D  1               	DB	39,39	;10
00EE4D  1               	DB	79,79	;11
00EE4D  1               	DB	65,65	;12
00EE4D  1               	DB	65,65	;13
00EE4D  1               	DB	19,9	;14
00EE4D  1               	DB	159,65	;15
00EE4D  1               ;	SPACE	4,10
00EE4D  1               ;**	TAGM - Table of ANTIC Graphics Modes
00EE4D  1               ;*
00EE4D  1               ;*	Entry n is the ANTIC graphics mode corresponding to internal
00EE4D  1               ;*	graphics mode n.
00EE4D  1               
00EE4D  1               
00EE4D  1  02 06 07 08  TAGM	DB	$02	;internal 0 - 40x2x8 characters
00EE51  1  09 0A 0B 0D  
00EE55  1  0F 0F 0F 0F  
00EE5D  1               	DB	$06	;internal 1 - 20x5x8 characters
00EE5D  1               	DB	$07	;internal 2 - 20x5x16 characters
00EE5D  1               	DB	$08	;internal 3 - 40x4x8 graphics
00EE5D  1               	DB	$09	;internal 4 - 80x2x4 graphics
00EE5D  1               	DB	$0A	;internal 5 - 80x4x4 graphics
00EE5D  1               	DB	$0B	;internal 6 - 160x2x2 graphics
00EE5D  1               	DB	$0D	;internal 7 - 160x4x2 graphics
00EE5D  1               	DB	$0F	;internal 8 - 320x2x1 graphics
00EE5D  1               	DB	$0F	;internal 9 - 320x2x1 GTIA "lum" mode
00EE5D  1               	DB	$0F	;internal 10 - 320x2x1 GTIA "color/lum" mode
00EE5D  1               	DB	$0F	;internal 11 - 320x2x1 GTIA "color" mode
00EE5D  1               	DB	$04	;internal 12 - 40x5x8 characters
00EE5D  1               	DB	$05	;internal 13 - 40x5x16 characters
00EE5D  1               	DB	$0C	;internal 14 - 160x2x1 graphics
00EE5D  1               	DB	$0E	;internal 15 - 160x4x1 graphics
00EE5D  1               ;	SPACE	4,10
00EE5D  1               ;**	TDLV - Table of Display List Vulnerability
00EE5D  1               ;*
00EE5D  1               ;*	Entry n is non-zero if the display list for mode n cannot
00EE5D  1               ;*	cross a page boundary.
00EE5D  1               
00EE5D  1               
00EE5D  1  00 00 00 00  TDLV	DB	0	;0
00EE61  1  00 00 00 01  
00EE65  1  01 01 01 01  
00EE6D  1               	DB	0	;1
00EE6D  1               	DB	0	;2
00EE6D  1               	DB	0	;3
00EE6D  1               	DB	0	;4
00EE6D  1               	DB	0	;5
00EE6D  1               	DB	0	;6
00EE6D  1               	DB	1	;7
00EE6D  1               	DB	1	;8
00EE6D  1               	DB	1	;9
00EE6D  1               	DB	1	;10
00EE6D  1               	DB	1	;11
00EE6D  1               	DB	0	;12
00EE6D  1               	DB	0	;13
00EE6D  1               	DB	1	;14
00EE6D  1               	DB	1	;15
00EE6D  1               ;	SPACE	4,10
00EE6D  1               ;**	TLSC - Table of Left Shift Counts
00EE6D  1               ;*
00EE6D  1               ;*	Entry n is the NUMBER OF LEFT SHIFTS NEEDED TO MULTIPLY
00EE6D  1               ;*	COLCRS BY # BYTES/ROW ((ROWCRS*5)/(2**TLSC)) for mode n.
00EE6D  1               
00EE6D  1               
00EE6D  1  03 02 02 01  TLSC	DB	3	;0
00EE71  1  01 02 02 03  
00EE75  1  03 03 03 03  
00EE7D  1               	DB	2	;1
00EE7D  1               	DB	2	;2
00EE7D  1               	DB	1	;3
00EE7D  1               	DB	1	;4
00EE7D  1               	DB	2	;5
00EE7D  1               	DB	2	;6
00EE7D  1               	DB	3	;7
00EE7D  1               	DB	3	;8
00EE7D  1               	DB	3	;9
00EE7D  1               	DB	3	;10
00EE7D  1               	DB	3	;11
00EE7D  1               	DB	3	;12
00EE7D  1               	DB	3	;13
00EE7D  1               	DB	2	;14
00EE7D  1               	DB	3	;15
00EE7D  1               ;	SPACE	4,10
00EE7D  1               ;**	TMCC - Table of Mode Column Counts
00EE7D  1               ;*
00EE7D  1               ;*	Entry n is the low column count for mode n.
00EE7D  1               
00EE7D  1               
00EE7D  1  28 14 14 28  TMCC	DB	low 40		;0
00EE81  1  50 50 A0 A0  
00EE85  1  40 50 50 50  
00EE8D  1               	DB	low 20		;1
00EE8D  1               	DB	low 20		;2
00EE8D  1               	DB	low 40		;3
00EE8D  1               	DB	low 80		;4
00EE8D  1               	DB	low 80		;5
00EE8D  1               	DB	low 160		;6
00EE8D  1               	DB	low 160		;7
00EE8D  1               	DB	low 320		;8
00EE8D  1               	DB	low 80		;9
00EE8D  1               	DB	low 80		;10
00EE8D  1               	DB	low 80		;11
00EE8D  1               	DB	low 40		;12
00EE8D  1               	DB	low 40		;13
00EE8D  1               	DB	low 160		;14
00EE8D  1               	DB	low 160		;15
00EE8D  1               ;	SPACE	4,10
00EE8D  1               ;**	TMRC - Table of Mode Row Counts
00EE8D  1               ;*
00EE8D  1               ;*	Entry n is the row count for mode n.
00EE8D  1               
00EE8D  1               
00EE8D  1  18 18 0C 18  TMRC	DB	24	;0
00EE91  1  30 30 60 60  
00EE95  1  C0 C0 C0 C0  
00EE9D  1               	DB	24	;1
00EE9D  1               	DB	12	;2
00EE9D  1               	DB	24	;3
00EE9D  1               	DB	48	;4
00EE9D  1               	DB	48	;5
00EE9D  1               	DB	96	;6
00EE9D  1               	DB	96	;7
00EE9D  1               	DB	192	;8
00EE9D  1               	DB	192	;9
00EE9D  1               	DB	192	;10
00EE9D  1               	DB	192	;11
00EE9D  1               	DB	24	;12
00EE9D  1               	DB	12	;13
00EE9D  1               	DB	192	;14
00EE9D  1               	DB	192	;15
00EE9D  1               ;	SPACE	4,10
00EE9D  1               ;**	TRSC - Table of Right Shift Counts
00EE9D  1               ;*
00EE9D  1               ;*	Entry n is HOW MANY RIGHT SHIFTS FOR HCRSR FOR PARTIAL
00EE9D  1               ;*	BYTE MODES for mode n.
00EE9D  1               
00EE9D  1               
00EE9D  1  00 00 00 02  TRSC	DB	0	;0
00EEA1  1  03 02 03 02  
00EEA5  1  03 01 01 01  
00EEAD  1               	DB	0	;1
00EEAD  1               	DB	0	;2
00EEAD  1               	DB	2	;3
00EEAD  1               	DB	3	;4
00EEAD  1               	DB	2	;5
00EEAD  1               	DB	3	;6
00EEAD  1               	DB	2	;7
00EEAD  1               	DB	3	;8
00EEAD  1               	DB	1	;9
00EEAD  1               	DB	1	;10
00EEAD  1               	DB	1	;11
00EEAD  1               	DB	0	;12
00EEAD  1               	DB	0	;13
00EEAD  1               	DB	3	;14
00EEAD  1               	DB	2	;15
00EEAD  1               ;	SPACE	4,10
00EEAD  1               ;**	TDSM - Table of Display Masks
00EEAD  1               ;*
00EEAD  1               ;*	NOTES
00EEAD  1               ;*		Includes TBTM - Table of Bit Masks.
00EEAD  1               
00EEAD  1               
00EEAD  1  FF F0 0F C0  TDSM	DB	$FF	;1
00EEB1  1  30 0C 03     
00EEB4  1               	DB	$F0	;2
00EEB4  1               	DB	$0F	;3
00EEB4  1               	DB	$C0	;4
00EEB4  1               	DB	$30	;5
00EEB4  1               	DB	$0C	;6
00EEB4  1               	DB	$03	;7
00EEB4  1               
00EEB4  1  80 40 20 10  TBTM	DB	$80	;8 (0)
00EEB8  1  08 04 02 01  
00EEBC  1               	DB	$40	;9 (1)
00EEBC  1               	DB	$20	;10 (2)
00EEBC  1               	DB	$10	;11 (3)
00EEBC  1               	DB	$08	;12 (4)
00EEBC  1               	DB	$04	;13 (5)
00EEBC  1               	DB	$02	;14 (6)
00EEBC  1               	DB	$01	;15 (7)
00EEBC  1               ;	SUBTTL	'Peripheral Handler Loading Facility, Part 5'
00EEBC  1               ;	SPACE	4,10
00EEBC  1               ;**	PHE - Perform Peripheral Handler Entry
00EEBC  1               ;*
00EEBC  1               ;*	PHE attempts to enter a peripheral handler in the handler table.
00EEBC  1               ;*
00EEBC  1               ;*	ENTRY	JSR	PHE
00EEBC  1               ;*		X = device code
00EEBC  1               ;*		A = high linkage table address
00EEBC  1               ;*		Y = low linkage table address
00EEBC  1               ;*
00EEBC  1               ;*	EXIT
00EEBC  1               ;*		Success:
00EEBC  1               ;*		C clear
00EEBC  1               ;*		Handler table entry made
00EEBC  1               ;*
00EEBC  1               ;*		Failure due to entry previously made:
00EEBC  1               ;*		C set
00EEBC  1               ;*		N clear
00EEBC  1               ;*		X = offset to second byte of duplicate entry
00EEBC  1               ;*		A, Y unchanged
00EEBC  1               ;*
00EEBC  1               ;*		Failure due to handler table full:
00EEBC  1               ;*		C set
00EEBC  1               ;*		N set
00EEBC  1               ;*
00EEBC  1               ;*	CHANGES
00EEBC  1               ;*		A X Y
00EEBC  1               ;*
00EEBC  1               ;*	CALLS
00EEBC  1               ;*		-none-
00EEBC  1               ;*
00EEBC  1               ;*	MODS
00EEBC  1               ;*		R. S. Scheiman	04/01/82
00EEBC  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00EEBC  1               ;*		   R. K. Nordin	11/01/83
00EEBC  1               
00EEBC  1               
00EEBC  1               PHE	=	*	;entry
00EEBC  1               
00EEBC  1               ;	Initialize.
00EEBC  1               
00EEBC  1  48           	PHA		;save high linkage table address
00EEBD  1  98           	TYA
00EEBE  1  48           	PHA		;save low linkage table address
00EEBF  1               
00EEBF  1               ;	Search for device code in handler table.
00EEBF  1               
00EEBF  1  8A           	TXA			;device code
00EEC0  1  A2 00        	LDX	#0		;offset to first entry of table
00EEC2  1               
00EEC2  1  DD 1A 03     PHE1	CMP	HATABS,X	;device code from table
00EEC5  1  F0 1E        	BEQ	PHE3		;if device code found
00EEC7  1               
00EEC7  1  E8           	INX
00EEC8  1  E8           	INX
00EEC9  1  E8           	INX
00EECA  1  E0 22        	CPX	#MAXDEV+1	;offset+1 of last possible entry
00EECC  1  30 F4        	BMI	PHE1		;if not done
00EECE  1               
00EECE  1               ;	Search for empty entry in handler table.
00EECE  1               
00EECE  1  A2 00        	LDX	#0		;offset to first entry of table
00EED0  1  A8           	TAY			;save device code
00EED1  1  A9 00        	LDA	#0
00EED3  1               
00EED3  1  DD 1A 03     PHE2	CMP	HATABS,X	;device code from table
00EED6  1  F0 13        	BEQ	PHE4		;if empty entry found
00EED8  1               
00EED8  1  E8           	INX
00EED9  1  E8           	INX
00EEDA  1  E8           	INX
00EEDB  1  E0 22        	CPX	#MAXDEV+1	;offset+1 of last possible entry
00EEDD  1  30 F4        	BMI	PHE2		;if not done
00EEDF  1               
00EEDF  1               ;	Return table full condition.
00EEDF  1               
00EEDF  1  68           	PLA		;clean stack
00EEE0  1  68           	PLA
00EEE1  1  A0 FF        	LDY	#$FF	;indicate table full (set N)
00EEE3  1  38           	SEC		;indicate failure
00EEE4  1  60           	RTS		;return
00EEE5  1               
00EEE5  1               ;	Return device code found condition.
00EEE5  1               
00EEE5  1  68           PHE3	PLA		;saved Y
00EEE6  1  A8           	TAY		;restore Y
00EEE7  1  68           	PLA		;restore A
00EEE8  1  E8           	INX		;indicate device code found (clear N)
00EEE9  1  38           	SEC		;indicate failure
00EEEA  1  60           	RTS		;return
00EEEB  1               
00EEEB  1               ;	Enter handler in table.
00EEEB  1               
00EEEB  1  98           PHE4	TYA			;device code
00EEEC  1  9D 1A 03     	STA	HATABS,X	;enter device code
00EEEF  1  68           	PLA			;saved low linkage table address
00EEF0  1  9D 1B 03     	STA	HATABS+1,X	;low address
00EEF3  1  68           	PLA			;saved high linkage table address
00EEF4  1  9D 1C 03     	STA	HATABS+2,X	;high address
00EEF7  1               
00EEF7  1               ;	Return success condition.
00EEF7  1               
00EEF7  1  18           	CLC		;indicate success
00EEF8  1  60           	RTS		;return
00EEF9  1               ;	SPACE	4,10
00EEF9  1               ;**	PHO - Perform Peripheral Handler Poll at OPEN
00EEF9  1               ;*
00EEF9  1               ;*	Subroutine to perform Type 4 Poll at OPEN time, and
00EEF9  1               ;*	"provisionally" open IOCB if peripheral answers.
00EEF9  1               ;*
00EEF9  1               ;*	Input parameters:
00EEF9  1               ;*	ICIDNO identifies calling IOCB;
00EEF9  1               ;*	From zero-page IOCB:
00EEF9  1               ;*		ICBALZ,ICBAHZ (buffer pointer)
00EEF9  1               ;*		ICDNOZ (device number from caller's filespe:
00EEF9  1               ;*	From caller's buffer: device name (in filespec.)
00EEF9  1               ;*
00EEF9  1               ;*	Output parameters:
00EEF9  1               ;*	"No device" error returned if Poll not answered.
00EEF9  1               ;*	If poll is answered, the calling IOCB is "Provision:
00EEF9  1               ;*		opened (and successful status is returned)-:
00EEF9  1               ;*		ICHIDZ set to mark provisional open
00EEF9  1               ;*		ICPTLZ,ICPTHZ points to PTL (special PUT-BY:
00EEF9  1               ;*		ICSPR in calling IOCB set to device name (f:
00EEF9  1               ;*		ICSPR+1 in calling IOCB set to device seria:
00EEF9  1               ;*
00EEF9  1               ;*	Modified:
00EEF9  1               ;*	Registers not saved.
00EEF9  1               ;*
00EEF9  1               ;*	Subroutines called:
00EEF9  1               ;*	PHP performs poll.
00EEF9  1               ;*
00EEF9  1               ;*	ENTRY	JSR	PHO
00EEF9  1               ;*
00EEF9  1               ;*	NOTES
00EEF9  1               ;*		Problem: in the CRASS65 version, ICIDNO was:
00EEF9  1               ;*		zero-page.
00EEF9  1               ;*
00EEF9  1               ;*	MODS
00EEF9  1               ;*		R. S. Scheiman	04/01/82
00EEF9  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00EEF9  1               ;*		   R. K. Nordin	11/01/83
00EEF9  1               
00EEF9  1               
00EEF9  1               PHO	=	*		;entry
00EEF9  1  A0 00        	LDY	#0		;Call for Type 4 Poll with
00EEFB  1  B1 24        	LDA	(ICBALZ),Y	;device name from user
00EEFD  1  A4 21        	LDY	ICDNOZ		;OPEN
00EEFF  1  20 BE E7     	JSR	PHP_
00EF02  1  10 03        	BPL	PHO1		;if poll answered
00EF04  1               
00EF04  1  A0 82        	LDY	#NONDEV		;Return "no device" error
00EF06  1  60           	RTS			;return
00EF07  1               
00EF07  1  A9 7F        PHO1	LDA	#$7F		;"Provisionally" OPEN the I:
00EF09  1  85 20        	STA	ICHIDZ		;(Mark "provisional")
00EF0B  1  A9 25        	LDA	#low (PTL-1)
00EF0D  1  85 26        	STA	ICPTLZ		;(Special put byte routine :
00EF0F  1  A9 EF        	LDA	#high (PTL-1)
00EF11  1  85 27        	STA	ICPTHZ
00EF13  1  AD EC 02     	LDA	DVSTAT+2	;(Peripheral address for lo:
00EF16  1               ;	LDX	ICIDNO
00EF16  1  AE 2E 00     	.BYTE	$AE, low ICIDNO, high ICIDNO ;originally VFD
00EF19  1  9D 4D 03     	STA	ICSPR+1,X
00EF1C  1  A0 00        	LDY	#0
00EF1E  1  B1 24        	LDA	(ICBALZ),Y	;(Device name from user)
00EF20  1  9D 4C 03     	STA	ICSPR,X
00EF23  1  A0 01        	LDY	#SUCCES		;indicate success
00EF25  1  60           	RTS			;return
00EF26  1               ;	SPACE	4,10
00EF26  1               ;**	PTL - Perform PUT-BYTE for Provisionally Open IOCB
00EF26  1               ;*
00EF26  1               ;*	Put byte entry for provisionally opened IOCB's.
00EF26  1               ;*	This routine performs load, relocation, initializat:
00EF26  1               ;*	and finishes OPEN, then calls handler's put byte en:
00EF26  1               ;*
00EF26  1               ;*	Input parameters:
00EF26  1               ;*	A	Byte to output;
00EF26  1               ;*	X	IOCB index (IOCB number times 16);
00EF26  1               ;*	Y	"Function not supported" error code $92.
00EF26  1               ;*	AUX1 and AUX2 in zero-page IOCB are copied from the:
00EF26  1               ;*		IOCB prior to the call to PTL.
00EF26  1               ;*
00EF26  1               ;*	Output parameters:
00EF26  1               ;*	Various errors may be returned if loading fails (ei:
00EF26  1               ;*		did not allow loading by setting HNDLOD fla:
00EF26  1               ;*		was a loading error or calling error);
00EF26  1               ;*	If no loading error, this routine returns nothing--:
00EF26  1               ;*		returned is returned by the loaded PUT-BYTE:
00EF26  1               ;*		is called by this routine after the handler:
00EF26  1               ;*		initialized, and opened.
00EF26  1               ;*
00EF26  1               ;*	Modified:
00EF26  1               ;*	ICIDNO (a CIO variable);
00EF26  1               ;*	all of the zero-page IOCB is copied fromt he callin:
00EF26  1               ;*	normal CIO open-operation variables are affected;
00EF26  1               ;*	after opening, the zero-page IOCB is copied to the :
00EF26  1               ;*	Registers not saved if error return;if handler is l:
00EF26  1               ;*		and opened properly, the caller's A and X r:
00EF26  1               ;*		passed to the loaded handler's PUT-BYTE rou:
00EF26  1               ;*		Y is passed to that routine as $92)--then r:
00EF26  1               ;*		on return is up to handler PUT-BYTE since i:
00EF26  1               ;*		directly to caller.
00EF26  1               ;*
00EF26  1               ;*	Subroutines called:
00EF26  1               ;*	PHL (does loading, initializing and opening--calls :
00EF26  1               ;*	loaded handler's INIT, OPEN, and PUT-BYTE entries a:
00EF26  1               ;*	The PUT-BYTE entry returns directly to the PTL call:
00EF26  1               ;*
00EF26  1               ;*	ENTRY	JSR	PTL
00EF26  1               ;*
00EF26  1               ;*	NOTES
00EF26  1               ;*		Problem: in the CRASS65 version, ICIDNO was:
00EF26  1               ;*		zero-page.
00EF26  1               ;*
00EF26  1               ;*	MODS
00EF26  1               ;*		R. S. Scheiman	04/01/82
00EF26  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00EF26  1               ;*		   R. K. Nordin	11/01/83
00EF26  1               
00EF26  1               
00EF26  1               PTL	=	*	;entry
00EF26  1  48           	PHA		;save byte to output
00EF27  1  8A           	TXA		;IOCB index
00EF28  1  48           	PHA		;save IOCB index
00EF29  1  29 0F        	AND	#$0F	;IOCB index modulo 16
00EF2B  1  D0 10        	BNE	PTL2	;if IOCB not dividable by 16, error
00EF2D  1               
00EF2D  1  E0 80        	CPX	#MAXIOC
00EF2F  1  10 0C        	BPL	PTL2	;if IOCB index invalid
00EF31  1               
00EF31  1  AD E9 02     	LDA	HNDLOD
00EF34  1  D0 0B        	BNE	PTL3	;if user wants loading
00EF36  1               
00EF36  1  A0 82        	LDY	#NONDEV	;indicate nonexistent device error
00EF38  1               
00EF38  1               ;	Return error.
00EF38  1               
00EF38  1  68           PTL1	PLA		;clean stack
00EF39  1  68           	PLA
00EF3A  1  C0 00        	CPY	#0	;indicate failure (set N)
00EF3C  1  60           	RTS		;return
00EF3D  1               
00EF3D  1  A0 86        PTL2	LDY	#BADIOC	;indicate bad IOCB number error
00EF3F  1  30 F7        	BMI	PTL1	;return error
00EF41  1               
00EF41  1               ;	Simulate beginning of CIO, since CIO bypassed.
00EF41  1               
00EF41  1               PTL3
00EF41  1               ;	STX	ICIDNO	;IOCB index
00EF41  1  8E 2E 00     	.BYTE	$8E, low ICIDNO, high ICIDNO ;originally VFD
00EF44  1  A0 00        	LDY	#0	;offset to first byte of page zero :
00EF46  1               
00EF46  1               ;	Copy IOCB to page zero IOCB.
00EF46  1               
00EF46  1  BD 40 03     PTL4	LDA	IOCB,X	;byte of IOCB
00EF49  1  99 20 00     	STA	ZIOCB,Y	;byte of page zero IOCB
00EF4C  1  E8           	INX
00EF4D  1  C8           	INY
00EF4E  1  C0 0C        	CPY	#12
00EF50  1  30 F4        	BMI	PTL4	;if not done
00EF52  1               
00EF52  1  20 29 CA     	JSR	PHL	;load and initialize peripheral han:
00EF55  1  30 E1        	BMI	PTL1	;if error
00EF57  1               
00EF57  1  68           	PLA		;Re-do the put byte call,
00EF58  1  AA           	TAX		;this time calling real handler
00EF59  1  68           	PLA
00EF5A  1  A8           	TAY
00EF5B  1  A5 27        	LDA	ICPTHZ
00EF5D  1  48           	PHA		;(Put byte entry address minus one)
00EF5E  1  A5 26        	LDA	ICPTLZ
00EF60  1  48           	PHA
00EF61  1  98           	TYA
00EF62  1  A0 92        	LDY	#FNCNOT
00EF64  1  60           	RTS		;invoke handler (address on stack)
00EF65  1               ;	SUBTTL	'$EF6B Patch'
00EF65  1               ;	SPACE	4,10
00EF65  1  00 00 00 00  	FIX	$EF6B
00EF69  1  00 00        
00EF6B  1               ;	SPACE	4,10
00EF6B  1               ;**	EF6B - $EF6B Patch
00EF6B  1               ;*
00EF6B  1               ;*	For compatibility with OS Revision B, initiate cass:
00EF6B  1               
00EF6B  1               
00EF6B  1  4C 05 FD     	JMP	ICR	;initiate cassette READ, return
00EF6E  1               ;	SUBTTL	'Keyboard, Editor and Screen Handler, Part 2'
00EF6E  1               ;	SPACE	4,10
00EF6E  1               ;**	SIN - Initialize Screen
00EF6E  1               ;*
00EF6E  1               ;*	ENTRY	JSR	SIN
00EF6E  1               ;*
00EF6E  1               ;*	MODS
00EF6E  1               ;*		Original Author Unknown
00EF6E  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00EF6E  1               ;*		   R. K. Nordin	11/01/83
00EF6E  1               
00EF6E  1               
00EF6E  1               SIN	=	*		;entry
00EF6E  1               
00EF6E  1  A9 FF        	LDA	#$FF		;clear code indicator
00EF70  1  8D FC 02     	STA	CH		;key code
00EF73  1               
00EF73  1  AD E4 02     	LDA	RAMSIZ		;size of RAM
00EF76  1  85 6A        	STA	RAMTOP		;RAM size
00EF78  1               
00EF78  1  A9 40        	LDA	#$40		;CAPS lock indicator
00EF7A  1  8D BE 02     	STA	SHFLOK		;shift/control lock flags
00EF7D  1               
00EF7D  1  A9 51        	LDA	#low TCKD	;table of character key def:
00EF7F  1  85 79        	STA	KEYDEF		;key definition table addre:
00EF81  1  A9 FB        	LDA	#high TCKD
00EF83  1  85 7A        	STA	KEYDEF+1
00EF85  1               
00EF85  1  A9 11        	LDA	#low TFKD	;table of function key defi:
00EF87  1  85 60        	STA	FKDEF		;function key definition ta:
00EF89  1  A9 FC        	LDA	#high TFKD
00EF8B  1  85 61        	STA	FKDEF+1
00EF8D  1               
00EF8D  1  60           	RTS			;return
00EF8E  1               ;	SPACE	4,10
00EF8E  1               ;**	SOP - Perform Screen OPEN
00EF8E  1               ;*
00EF8E  1               ;*	ENTRY	JSR	SOP
00EF8E  1               ;*
00EF8E  1               ;*	MODS
00EF8E  1               ;*		Original Author Unknown
00EF8E  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00EF8E  1               ;*		   R. K. Nordin	11/01/83
00EF8E  1               
00EF8E  1               
00EF8E  1               SOP	=	*	;entry
00EF8E  1               
00EF8E  1               ;	Check mode.
00EF8E  1               
00EF8E  1  A5 2B        	LDA	ICAX2Z
00EF90  1  29 0F        	AND	#$0F
00EF92  1  D0 08        	BNE	COC	;if not mode 0, complete OPEN comma:
00EF94  1               
00EF94  1               ;	Process mode 0.
00EF94  1               
00EF94  1               ;	JMP	EOP	;perform editor OPEN, return
00EF94  1               ;	SPACE	4,10
00EF94  1               ;**	EOP - Perform Editor OPEN
00EF94  1               ;*
00EF94  1               ;*	ENTRY	JSR	EOP
00EF94  1               ;*
00EF94  1               ;*	MODS
00EF94  1               ;*		Original Author Unknown
00EF94  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00EF94  1               ;*		   R. K. Nordin	11/01/83
00EF94  1               
00EF94  1               
00EF94  1               EOP	=	*	;entry
00EF94  1  A5 2A        	LDA	ICAX1Z
00EF96  1  29 0F        	AND	#$0F
00EF98  1  85 2A        	STA	ICAX1Z
00EF9A  1  A9 00        	LDA	#0
00EF9C  1               ;	JMP	COC	;complete OPEN command, return
00EF9C  1               ;	SPACE	4,10
00EF9C  1               ;**	COC - Complete OPEN Command
00EF9C  1               ;*
00EF9C  1               ;*	ENTRY	JSR	COC
00EF9C  1               ;*		A = mode
00EF9C  1               ;*
00EF9C  1               ;*	MODS
00EF9C  1               ;*		Original Author Unknown
00EF9C  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00EF9C  1               ;*		   R. K. Nordin	11/01/83
00EF9C  1               
00EF9C  1               
00EF9C  1               COC	=	*	;entry
00EF9C  1               
00EF9C  1               ;	Check mode.
00EF9C  1               
00EF9C  1  85 57        	STA	DINDEX	;szve mode
00EF9E  1  C9 10        	CMP	#16
00EFA0  1  90 05        	BCC	COC1	;if mode within range
00EFA2  1               
00EFA2  1               ;	Process invalid mode
00EFA2  1               
00EFA2  1  A9 91        	LDA	#BADMOD
00EFA4  1  4C 54 F1     	JMP	COC17
00EFA7  1               
00EFA7  1               ;	Initialize for OPEN.
00EFA7  1               
00EFA7  1  A9 E0        COC1	LDA	#high DCSORG	;high domestic character se:
00EFA9  1  8D F4 02     	STA	CHBAS		;character set base
00EFAC  1  A9 CC        	LDA	#high ICSORG	;high international charact:
00EFAE  1  8D 6B 02     	STA	CHSALT		;alternate character set ba:
00EFB1  1  A9 02        	LDA	#2
00EFB3  1  8D F3 02     	STA	CHACT
00EFB6  1  8D 2F 02     	STA	SDMCTL		;turn off DMA
00EFB9  1  A9 01        	LDA	#SUCCES
00EFBB  1  85 4C        	STA	DSTAT		;clear status
00EFBD  1  A9 C0        	LDA	#$C0		;enable IRQ
00EFBF  1  05 10        	ORA	POKMSK
00EFC1  1  85 10        	STA	POKMSK
00EFC3  1  8D 0E D2     	STA	IRQEN
00EFC6  1               
00EFC6  1               ;	Set DLI status.
00EFC6  1               
00EFC6  1  A9 40        	LDA	#$40		;disable DLI
00EFC8  1  8D 0E D4     	STA	NMIEN
00EFCB  1  2C 6E 02     	BIT	FINE
00EFCE  1  10 0C        	BPL	COC2		;if not fine scrolling (VBL:
00EFD0  1               
00EFD0  1  A9 C4        	LDA	#low FDL
00EFD2  1  8D 00 02     	STA	VDSLST		;DLI vector
00EFD5  1  A9 FC        	LDA	#high FDL
00EFD7  1  8D 01 02     	STA	VDSLST+1
00EFDA  1  A9 C0        	LDA	#$C0
00EFDC  1               
00EFDC  1  8D 0E D4     COC2	STA	NMIEN
00EFDF  1               
00EFDF  1               ;	Clear control.
00EFDF  1               
00EFDF  1  A9 00        	LDA	#0
00EFE1  1  8D 93 02     	STA	TINDEX		;clear text index (must alw:
00EFE4  1  85 64        	STA	ADRESS
00EFE6  1  85 7B        	STA	SWPFLG
00EFE8  1  8D F0 02     	STA	CRSINH
00EFEB  1               
00EFEB  1               ;	Set initial tab stops.
00EFEB  1               
00EFEB  1  A0 0E        	LDY	#14		;offset to last byte of bit:
00EFED  1  A9 01        	LDA	#$01		;tab stop every 8 character:
00EFEF  1               
00EFEF  1  99 A3 02     COC3	STA	TABMAP,Y	;set tab stop
00EFF2  1  88           	DEY
00EFF3  1  10 FA        	BPL	COC3		;if not done
00EFF5  1               
00EFF5  1               ;	Load initialize color register shadows.
00EFF5  1               
00EFF5  1  A2 04        	LDX	#4		;offset to last color regis:
00EFF7  1               
00EFF7  1  BD 08 FB     COC4	LDA	TDSC,X		;default screen color
00EFFA  1  9D C4 02     	STA	COLOR0,X	;set color register shadow
00EFFD  1  CA           	DEX
00EFFE  1  10 F7        	BPL	COC4		;if not done
00F000  1               
00F000  1               ;	Set up.
00F000  1               
00F000  1  A4 6A        	LDY	RAMTOP		;(high) RAM size
00F002  1  88           	DEY			;decrement (high) RAM size
00F003  1  8C 95 02     	STY	TXTMSC+1
00F006  1  A9 60        	LDA	#low ($0000-160)	;low RAM size = 160
00F008  1  8D 94 02     	STA	TXTMSC
00F00B  1  A6 57        	LDX	DINDEX		;mode
00F00D  1  BD 4D EE     	LDA	TAGM,X		;convert to ANTIC code
00F010  1  85 51        	STA	HOLD1		;ANTIC code
00F012  1  A5 6A        	LDA	RAMTOP		;(high) RAM size
00F014  1  85 65        	STA	ADRESS+1
00F016  1               
00F016  1               ;	Allocate memory.
00F016  1               
00F016  1  BC 1D EE     	LDY	TSMA,X		;number of 40-byte blocks t:
00F019  1               
00F019  1  A9 28        COC5	LDA	#40		;40 bytes
00F01B  1  20 7A F5     	JSR	DBS		;perform double byte subtra:
00F01E  1  88           	DEY
00F01F  1  D0 F8        	BNE	COC5		;if not done
00F021  1               
00F021  1               ;	Clear GTIA modes.
00F021  1               
00F021  1  AD 6F 02     	LDA	GPRIOR
00F024  1  29 3F        	AND	#$3F		;clear GTIA modes
00F026  1  85 67        	STA	OPNTMP+1
00F028  1  A8           	TAY
00F029  1               
00F029  1               ;	Determine mode.
00F029  1               
00F029  1  E0 08        	CPX	#8
00F02B  1  90 1F        	BCC	COC7		;if mode < 8
00F02D  1               
00F02D  1  E0 0F        	CPX	#15
00F02F  1  F0 0D        	BEQ	COC6		;if mode 15
00F031  1               
00F031  1  E0 0C        	CPX	#12
00F033  1  B0 17        	BCS	COC7		;if mode >= 12
00F035  1               
00F035  1               ;	Process mode 9, 10 and 11.
00F035  1               
00F035  1  8A           	TXA			;mode
00F036  1  6A           	ROR	A
00F037  1  6A           	ROR	A
00F038  1  6A           	ROR	A
00F039  1  29 C0        	AND	#$C0		;extract 2 low bits (in 2 h:
00F03B  1  05 67        	ORA	OPNTMP+1
00F03D  1  A8           	TAY
00F03E  1               
00F03E  1               ;	Establish line boundary at X000.
00F03E  1               
00F03E  1  A9 10        COC6	LDA	#16		;subtract 16 for page bound:
00F040  1  20 7A F5     	JSR	DBS		;perform double byte subtra:
00F043  1               
00F043  1               ;	Check for mode 11.
00F043  1               
00F043  1  E0 0B        	CPX	#11
00F045  1  D0 05        	BNE	COC7		;if mode 11
00F047  1               
00F047  1               ;	Set GTIA luminance.
00F047  1               
00F047  1  A9 06        	LDA	#6		;GTIA luminance value
00F049  1  8D C8 02     	STA	COLOR4		;background color
00F04C  1               
00F04C  1               ;	Set new priority.
00F04C  1               
00F04C  1  8C 6F 02     COC7	STY	GPRIOR		;new priority
00F04F  1               
00F04F  1               ;	Set memory scan counter.
00F04F  1               
00F04F  1  A5 64        	LDA	ADRESS		;memory scan counter
00F051  1  85 58        	STA	SAVMSC		;save memory scan counter
00F053  1  A5 65        	LDA	ADRESS+1
00F055  1  85 59        	STA	SAVMSC+1
00F057  1               
00F057  1               ;	Wait for VBLANK.
00F057  1               
00F057  1  AD 0B D4     COC8	LDA	VCOUNT
00F05A  1  C9 7A        	CMP	#$7A
00F05C  1  D0 F9        	BNE	COC8		;if VBLANK has not occured
00F05E  1               
00F05E  1               ;	Put display list under RAM.
00F05E  1               
00F05E  1  20 78 F5     	JSR	DSD		;perform double byte single:
00F061  1  BD 5D EE     	LDA	TDLV,X		;display list vulnerability
00F064  1  F0 06        	BEQ	COC9		;if not vulnerable
00F066  1               
00F066  1  A9 FF        	LDA	#$FF
00F068  1  85 64        	STA	ADRESS
00F06A  1  C6 65        	DEC	ADRESS+1	;drop down 1 page
00F06C  1               
00F06C  1  20 65 F5     COC9	JSR	DDD		;perform double byte double:
00F06F  1  A5 64        	LDA	ADRESS		;end of display list
00F071  1  85 68        	STA	SAVADR		;save address
00F073  1  A5 65        	LDA	ADRESS+1
00F075  1  85 69        	STA	SAVADR+1
00F077  1               
00F077  1               ;	Set up.
00F077  1               
00F077  1  A9 41        	LDA	#$41		;ANTIC wait for VBLANK and :
00F079  1  20 70 F5     	JSR	SDI		;store data indirect
00F07C  1  86 66        	STX	OPNTMP
00F07E  1  A9 18        	LDA	#24
00F080  1  8D BF 02     	STA	BOTSCR	;screen bottom
00F083  1               
00F083  1               ;	Check for modes 9 ,10 and 11.
00F083  1               
00F083  1  A5 57        	LDA	DINDEX		;mode
00F085  1  C9 0C        	CMP	#12
00F087  1  B0 04        	BCS	COC10		;if mode >= 12, mixed mode :
00F089  1               
00F089  1  C9 09        	CMP	#9
00F08B  1  B0 39        	BCS	COC12		;if mode >= 9, mixed mode n:
00F08D  1               
00F08D  1               ;	Check for mixed mode.
00F08D  1               
00F08D  1  A5 2A        COC10	LDA	ICAX1Z
00F08F  1  29 10        	AND	#MXDMOD
00F091  1  F0 33        	BEQ	COC12		;if not mixed mode
00F093  1               
00F093  1               ;	Process mixed mode.
00F093  1               
00F093  1  A9 04        	LDA	#4
00F095  1  8D BF 02     	STA	BOTSCR	;screen bottom
00F098  1  A2 02        	LDX	#2
00F09A  1  AD 6E 02     	LDA	FINE
00F09D  1  F0 03        	BEQ	COC11		;if not fine scrolling
00F09F  1               
00F09F  1  20 A0 F5     	JSR	SSE		;set scrolling display list:
00F0A2  1               
00F0A2  1  A9 02        COC11	LDA	#$02
00F0A4  1  20 69 F5     	JSR	SDF		;store data indirect for fi:
00F0A7  1  CA           	DEX
00F0A8  1  10 F8        	BPL	COC11		;if not done
00F0AA  1               
00F0AA  1               ;	Reload MSC for text.
00F0AA  1               
00F0AA  1  A4 6A        	LDY	RAMTOP		;(high) RAM size
00F0AC  1  88           	DEY			;decrement (high) RAM size
00F0AD  1  98           	TYA
00F0AE  1  20 70 F5     	JSR	SDI		;store data indirect
00F0B1  1  A9 60        	LDA	#low ($0000-160)	;low RAM size = 160
00F0B3  1  20 70 F5     	JSR	SDI		;store data indirect
00F0B6  1  A9 42        	LDA	#$42		;fine scrolling
00F0B8  1  20 69 F5     	JSR	SDF		;store data indirect
00F0BB  1  18           	CLC
00F0BC  1  A9 10        	LDA	#MXDMOD
00F0BE  1  65 66        	ADC	OPNTMP
00F0C0  1  A8           	TAY
00F0C1  1  BE 2D EE     	LDX	TDLE,Y
00F0C4  1  D0 15        	BNE	COC13
00F0C6  1               
00F0C6  1               ;	Check mode.
00F0C6  1               
00F0C6  1  A4 66        COC12	LDY	OPNTMP
00F0C8  1  BE 2D EE     	LDX	TDLE,Y		;number of display list ent:
00F0CB  1  A5 57        	LDA	DINDEX		;mode
00F0CD  1  D0 0C        	BNE	COC13		;if not mode 0
00F0CF  1               
00F0CF  1               ;	Check for fine scrolling.
00F0CF  1               
00F0CF  1  AD 6E 02     	LDA	FINE		;fine scrolling flag
00F0D2  1  F0 07        	BEQ	COC13		;if not fine scrolling
00F0D4  1               
00F0D4  1               ;	Process fine scrolling.
00F0D4  1               
00F0D4  1  20 A0 F5     	JSR	SSE		;set scrolling display list:
00F0D7  1  A9 22        	LDA	#$22
00F0D9  1  85 51        	STA	HOLD1
00F0DB  1               
00F0DB  1               ;	Continue.
00F0DB  1               
00F0DB  1  A5 51        COC13	LDA	HOLD1
00F0DD  1  20 70 F5     	JSR	SDI		;store data indirect
00F0E0  1  CA           	DEX
00F0E1  1  D0 F8        	BNE	COC13		;if not done
00F0E3  1               
00F0E3  1               ;	Determine mode.
00F0E3  1               
00F0E3  1  A5 57        	LDA	DINDEX		;mode
00F0E5  1  C9 08        	CMP	#8
00F0E7  1  90 26        	BCC	COC16		;if mode < 8
00F0E9  1               
00F0E9  1  C9 0F        	CMP	#15
00F0EB  1  F0 04        	BEQ	COC14		;if mode 15
00F0ED  1               
00F0ED  1  C9 0C        	CMP	#12
00F0EF  1  B0 1E        	BCS	COC16		;if mode >= 12
00F0F1  1               
00F0F1  1               ;	Process modes 8, 9, 10, 11 and 15.
00F0F1  1               
00F0F1  1  A2 5D        COC14	LDX	#93		;remaining number of DLE's
00F0F3  1  A5 6A        	LDA	RAMTOP		;(high) RAM size
00F0F5  1  38           	SEC
00F0F6  1  E9 10        	SBC	#high $1000	;subtract 4K
00F0F8  1  20 70 F5     	JSR	SDI		;store data indirect
00F0FB  1  A9 00        	LDA	#low $0000
00F0FD  1  20 70 F5     	JSR	SDI		;store data indirect
00F100  1  A5 51        	LDA	HOLD1		;ANTIC MSC code
00F102  1  09 40        	ORA	#$40
00F104  1  20 70 F5     	JSR	SDI		;store data indirect
00F107  1               
00F107  1  A5 51        COC15	LDA	HOLD1		;remaining DLE's
00F109  1  20 70 F5     	JSR	SDI		;store data indirect
00F10C  1  CA           	DEX
00F10D  1  D0 F8        	BNE	COC15		;if DLE's remain
00F10F  1               
00F10F  1               ;	Complete display list with LMS.
00F10F  1               
00F10F  1  A5 59        COC16	LDA	SAVMSC+1	;high saved memory scan cou:
00F111  1  20 70 F5     	JSR	SDI		;store data indirect
00F114  1  A5 58        	LDA	SAVMSC		;low saved memory scan coun:
00F116  1  20 70 F5     	JSR	SDI		;store data indirect
00F119  1  A5 51        	LDA	HOLD1
00F11B  1  09 40        	ORA	#$40
00F11D  1  20 70 F5     	JSR	SDI		;store data indirect
00F120  1  A9 70        	LDA	#$70		;8 blank lines
00F122  1  20 70 F5     	JSR	SDI		;store data indirect
00F125  1  A9 70        	LDA	#$70		;8 blank lines
00F127  1  20 70 F5     	JSR	SDI		;store data indirect
00F12A  1  A5 64        	LDA	ADRESS		;display list address
00F12C  1  8D 30 02     	STA	SDLSTL		;save display list address
00F12F  1  A5 65        	LDA	ADRESS+1
00F131  1  8D 31 02     	STA	SDLSTL+1
00F134  1  A9 70        	LDA	#$70		;8 blank lines
00F136  1  20 70 F5     	JSR	SDI		;store data indirect
00F139  1  A5 64        	LDA	ADRESS		;display list address
00F13B  1  8D E5 02     	STA	MEMTOP		;update top of memory
00F13E  1  A5 65        	LDA	ADRESS+1
00F140  1  8D E6 02     	STA	MEMTOP+1
00F143  1  A0 01        	LDY	#1		;offset
00F145  1  AD 30 02     	LDA	SDLSTL		;saved display list address
00F148  1  91 68        	STA	(SAVADR),Y
00F14A  1  C8           	INY
00F14B  1  AD 31 02     	LDA	SDLSTL+1
00F14E  1  91 68        	STA	(SAVADR),Y
00F150  1               
00F150  1               ;	Check status.
00F150  1               
00F150  1  A5 4C        	LDA	DSTAT		;status
00F152  1  10 10        	BPL	COC18		;if no error
00F154  1               
00F154  1               ;	Process error.
00F154  1               
00F154  1  8D EC 03     COC17	STA	DERRF		;screen OPEN error flag
00F157  1  20 94 EF     	JSR	EOP		;perform editor OPEN
00F15A  1  AD EC 03     	LDA	DERRF		;restore status
00F15D  1  A0 00        	LDY	#0		;no screen OPEN error indic:
00F15F  1  8C EC 03     	STY	DERRF		;screen OPEN error flag
00F162  1  A8           	TAY			;status
00F163  1  60           	RTS			;return
00F164  1               
00F164  1               ;	Check clear inhibit.
00F164  1               
00F164  1  A5 2A        COC18	LDA	ICAX1Z
00F166  1  29 20        	AND	#$20		;extract clear inhibit bit
00F168  1  D0 0B        	BNE	COC19		;if clear inhibited
00F16A  1               
00F16A  1               ;	Clear screen.
00F16A  1               
00F16A  1  20 20 F4     	JSR	CSC		;clear screen
00F16D  1  8D 90 02     	STA	TXTROW		;set cursor at top row
00F170  1  A5 52        	LDA	LMARGN		;left margin
00F172  1  8D 91 02     	STA	TXTCOL		;set cursor at left margin
00F175  1               
00F175  1               ;	Exit.
00F175  1               
00F175  1  A9 22        COC19	LDA	#$22		;turn on DMA control
00F177  1  0D 2F 02     	ORA	SDMCTL
00F17A  1  8D 2F 02     	STA	SDMCTL
00F17D  1  4C 0B F2     	JMP	SEC_		;set exit conditions, retur:
00F180  1               ;	SPACE	4,10
00F180  1               ;**	SGB - Perform Screen GET-BYTE
00F180  1               ;*
00F180  1               ;*	ENTRY	JSR	SGB
00F180  1               ;*
00F180  1               ;*	MODS
00F180  1               ;*		Original Author Unknown
00F180  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F180  1               ;*		   R. K. Nordin	11/01/83
00F180  1               
00F180  1               
00F180  1               SGB	=	*	;entry
00F180  1  20 CA F6     	JSR	CCR	;check cursor range
00F183  1  20 8F F1     	JSR	GDC	;get data under cursor
00F186  1  20 6A F7     	JSR	CIA	;convert internal character to ATAS:
00F189  1  20 0A F6     	JSR	SZA	;set zero data and advance cursor
00F18C  1  4C 1E F2     	JMP	SST	;perform screen STATUS, return
00F18F  1               ;	SPACE	4,10
00F18F  1               ;**	GDC - Get Data Under Cursor
00F18F  1               ;*
00F18F  1               ;*	ENTRY	JSR	GDC
00F18F  1               ;*
00F18F  1               ;*	MODS
00F18F  1               ;*		Original Author Unknown
00F18F  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F18F  1               ;*		   R. K. Nordin	11/01/83
00F18F  1               
00F18F  1               
00F18F  1               GDC	=	*	;entry
00F18F  1  20 AC F5     	JSR	CCA	;convert cursor row/column to addre:
00F192  1  B1 64        	LDA	(ADRESS),Y
00F194  1  2D A0 02     	AND	DMASK
00F197  1               
00F197  1  46 6F        GDC1	LSR	SHFAMT	;shift data down to low bits
00F199  1  B0 03        	BCS	GDC2	;if done
00F19B  1               
00F19B  1  4A           	LSR	A
00F19C  1  10 F9        	BPL	GDC1	;continue shifting
00F19E  1               
00F19E  1  8D FA 02     GDC2	STA	CHAR
00F1A1  1  C9 00        	CMP	#0	;restore flags
00F1A3  1  60           F1A3	RTS		;return
00F1A4  1               ;	SPACE	4,10
00F1A4  1               ;**	SPB - Perform Screen PUT-BYTE
00F1A4  1               ;*
00F1A4  1               ;*	ENTRY	JSR	SPB
00F1A4  1               ;*
00F1A4  1               ;*	MODS
00F1A4  1               ;*		Original Author Unknown
00F1A4  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F1A4  1               ;*		   R. K. Nordin	11/01/83
00F1A4  1               
00F1A4  1               
00F1A4  1               SPB	=	*	;entry
00F1A4  1  8D FB 02     	STA	ATACHR
00F1A7  1               
00F1A7  1               ;	JSR	ROD	;restore old data under cursor
00F1A7  1               
00F1A7  1  C9 7D        	CMP	#CLS
00F1A9  1  D0 06        	BNE	SPB1	;if not clear screen
00F1AB  1               
00F1AB  1  20 20 F4     	JSR	CSC	;clear screen
00F1AE  1  4C 0B F2     	JMP	SEC_	;set exit contitions, return
00F1B1  1               
00F1B1  1  20 CA F6     SPB1	JSR	CCR	;check cursor range
00F1B4  1               ;	JMP	CEL	;check EOL, return
00F1B4  1               ;	SPACE	4,10
00F1B4  1               ;**	CEL - Check End of Line
00F1B4  1               ;*
00F1B4  1               ;*	ENTRY	JSR	CEL
00F1B4  1               ;*
00F1B4  1               ;*	MODS
00F1B4  1               ;*		Original Author Unknown
00F1B4  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F1B4  1               ;*		   R. K. Nordin	11/01/83
00F1B4  1               
00F1B4  1               
00F1B4  1               CEL	=	*	;entry
00F1B4  1  AD FB 02     	LDA	ATACHR
00F1B7  1  C9 9B        	CMP	#EOL
00F1B9  1  D0 06        	BNE	CEL1	;if not EOL
00F1BB  1               
00F1BB  1  20 61 F6     	JSR	RWS	;return with scrolling
00F1BE  1  4C 0B F2     	JMP	SEC_	;set exit conditions, return
00F1C1  1               
00F1C1  1  20 CA F1     CEL1	JSR	PLO	;plot point
00F1C4  1  20 0E F6     	JSR	SEA	;set EOL data and advance cursor
00F1C7  1  4C 0B F2     	JMP	SEC_	;set exit conditions, return
00F1CA  1               ;	SPACE	4,10
00F1CA  1               ;**	PLO - Plot Point
00F1CA  1               ;*
00F1CA  1               ;*	ENTRY	JSR	PLO
00F1CA  1               ;*
00F1CA  1               ;*	MODS
00F1CA  1               ;*		Original Author Unknown
00F1CA  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F1CA  1               ;*		   R. K. Nordin	11/01/83
00F1CA  1               
00F1CA  1               
00F1CA  1               PLO	=	*		;entry
00F1CA  1               
00F1CA  1               ;	Wait for start/stop flag clear.
00F1CA  1               
00F1CA  1  AD FF 02     PLO0	LDA	SSFLAG		;start/stop flag
00F1CD  1  D0 FB        	BNE	PLO0		;if start/stop flag non-zer:
00F1CF  1               
00F1CF  1               ;	Save cursor row/column.
00F1CF  1               
00F1CF  1  A2 02        	LDX	#2		;offset to last byte
00F1D1  1               
00F1D1  1  B5 54        PLO1	LDA	ROWCRS,X	;byte of cursor row/column
00F1D3  1  95 5A        	STA	OLDROW,X	;save byte of cursor row/co:
00F1D5  1  CA           	DEX
00F1D6  1  10 F9        	BPL	PLO1		;if not done
00F1D8  1               
00F1D8  1               ;	Convert ATASCII character to internal.
00F1D8  1               
00F1D8  1  AD FB 02     	LDA	ATACHR		;character
00F1DB  1  A8           	TAY			;character
00F1DC  1  2A           	ROL	A
00F1DD  1  2A           	ROL	A
00F1DE  1  2A           	ROL	A
00F1DF  1  2A           	ROL	A
00F1E0  1  29 03        	AND	#3
00F1E2  1  AA           	TAX			;index into TAIC
00F1E3  1  98           	TYA			;character
00F1E4  1  29 9F        	AND	#$9F		;strip off column address
00F1E6  1  1D 49 FB     	ORA	TAIC,X		;or in new column address
00F1E9  1               ;	JMP	SPQ		;display, return
00F1E9  1               ;	SPACE	4,10
00F1E9  1               ;**	SPQ - Display
00F1E9  1               ;*
00F1E9  1               ;*	ENTRY	JSR	SPQ
00F1E9  1               ;*
00F1E9  1               ;*	MODS
00F1E9  1               ;*		Original Author Unknown
00F1E9  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F1E9  1               ;*		   R. K. Nordin	11/01/83
00F1E9  1               
00F1E9  1               
00F1E9  1               SPQ	=	*		;entry
00F1E9  1               
00F1E9  1               ;	Set CHAR.
00F1E9  1               
00F1E9  1  8D FA 02     	STA	CHAR		;character
00F1EC  1               
00F1EC  1               ;	Convert cursor row/column to address.
00F1EC  1               
00F1EC  1  20 AC F5     	JSR	CCA		;convert cursor row/column :
00F1EF  1               
00F1EF  1               ;	Shift up to proper position.
00F1EF  1               
00F1EF  1  AD FA 02     	LDA	CHAR		;character
00F1F2  1               
00F1F2  1  46 6F        SPQ1	LSR	SHFAMT
00F1F4  1  B0 04        	BCS	SPQ2		;if done
00F1F6  1               
00F1F6  1  0A           	ASL	A
00F1F7  1  4C F2 F1     	JMP	SPQ1		;continue shifting
00F1FA  1               
00F1FA  1               ;	Update data.
00F1FA  1               
00F1FA  1  2D A0 02     SPQ2	AND	DMASK
00F1FD  1  85 50        	STA	TMPCHR		;save shifted data
00F1FF  1  AD A0 02     	LDA	DMASK		;display mask
00F202  1  49 FF        	EOR	#$FF		;complement display mask
00F204  1  31 64        	AND	(ADRESS),Y	;mask off old data
00F206  1  05 50        	ORA	TMPCHR		;or in new data
00F208  1  91 64        	STA	(ADRESS),Y	;update data
00F20A  1  60           	RTS			;return
00F20B  1               ;	SPACE	4,10
00F20B  1               ;**	SEC - Set Exit Conditions
00F20B  1               ;*
00F20B  1               ;*	ENTRY	JSR	SEC
00F20B  1               ;*
00F20B  1               ;*	MODS
00F20B  1               ;*		Original Author Unknown
00F20B  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F20B  1               ;*		   R. K. Nordin	11/01/83
00F20B  1               
00F20B  1               
00F20B  1               SEC_	=	*	;entry
00F20B  1  20 8F F1     	JSR	GDC	;get data under cursor
00F20E  1  85 5D        	STA	OLDCHR
00F210  1  A6 57        	LDX	DINDEX	;mode
00F212  1  D0 0A        	BNE	SST	;if graphics, no cursor
00F214  1               
00F214  1  AE F0 02     	LDX	CRSINH	;cursor inhibit flag
00F217  1  D0 05        	BNE	SST	;if cursor inhibited
00F219  1               
00F219  1  49 80        	EOR	#$80	;complement most significant bit
00F21B  1  20 E9 F1     	JSR	SPQ	;display
00F21E  1               ;	JMP	SST	;perform screen status, return
00F21E  1               ;	SPACE	4,10
00F21E  1               ;**	SST - Perform Screen STATUS
00F21E  1               ;*
00F21E  1               ;*	ENTRY	JSR	SST
00F21E  1               ;*
00F21E  1               ;*	MODS
00F21E  1               ;*		Original Author Unknown
00F21E  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F21E  1               ;*		   R. K. Nordin	11/01/83
00F21E  1               
00F21E  1               
00F21E  1               SST	=	*	;entry
00F21E  1  A4 4C        	LDY	DSTAT	;status
00F220  1  4C 26 F2     	JMP	SST1	;continue
00F223  1               ;	SUBTTL	'$F223 Patch'
00F223  1               ;	SPACE	4,10
00F223  1               	FIX	$F223
00F223  1               ;	SPACE	4,10
00F223  1               ;**	F223 - $F223 Patch
00F223  1               ;*
00F223  1               ;*	For compatibility with OS Revision B, perform power-up display.
00F223  1               
00F223  1               
00F223  1               PPD	=	*	;entry
00F223  1  4C FC C8     	JMP	SES	;select and execute self-test
00F226  1               ;	SUBTTL	'Keyboard, Editor and Screen Handler, Part 3'
00F226  1               ;	SPACE	4,10
00F226  1               ;	Continue.
00F226  1               
00F226  1  A9 01        SST1	LDA	#SUCCES	;indicate success
00F228  1  85 4C        	STA	DSTAT	;status
00F22A  1  AD FB 02     	LDA	ATACHR	;data
00F22D  1               ;	JMP	ESP	;return
00F22D  1               ;	SPACE	4,10
00F22D  1               ;**	ESP - Perform Editor SPECIAL
00F22D  1               ;*
00F22D  1               ;*	ESP does nothing.
00F22D  1               ;*
00F22D  1               ;*	ENTRY	JSR	ESP
00F22D  1               ;*
00F22D  1               ;*	MODS
00F22D  1               ;*		Original Author Unknown
00F22D  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F22D  1               ;*		   R. K. Nordin	11/01/83
00F22D  1               
00F22D  1               
00F22D  1               ESP	=	*	;entry
00F22D  1  60           	RTS		;return
00F22E  1               ;	SPACE	4,10
00F22E  1               ;**	ECL - Perform Editor CLOSE
00F22E  1               ;*
00F22E  1               ;*	ENTRY	JSR	ECL
00F22E  1               ;*
00F22E  1               ;*	MODS
00F22E  1               ;*		Original Author Unknown
00F22E  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F22E  1               ;*		   R. K. Nordin	11/01/83
00F22E  1               
00F22E  1               
00F22E  1               ECL	=	*	;entry
00F22E  1               
00F22E  1               ;	Check for fine scrolling.
00F22E  1               
00F22E  1  2C 6E 02     	BIT	FINE	;fine scrolling flag
00F231  1  10 EB        	BPL	SST	;if not fine scrolling, perform STA:
00F233  1               
00F233  1               ;	Process fine scrolling.
00F233  1               
00F233  1  A9 40        	LDA	#$40
00F235  1  8D 0E D4     	STA	NMIEN		;disable DLI
00F238  1  A9 00        	LDA	#0		;clear fine scrolling flag
00F23A  1  8D 6E 02     	STA	FINE
00F23D  1  A9 CE        	LDA	#low RIR	;return from interrupt rout:
00F23F  1  8D 00 02     	STA	VDSLST		;restore initial DLI vector:
00F242  1  A9 C0        	LDA	#high RIR
00F244  1  8D 01 02     	STA	VDSLST+1
00F247  1  4C 94 EF     	JMP	EOP		;perform editor OPEN, retur:
00F24A  1               ;	SPACE	4,10
00F24A  1               ;**	EGB - Perform Editor GET-BYTE
00F24A  1               ;*
00F24A  1               ;*	ENTRY	JSR	EGB
00F24A  1               ;*
00F24A  1               ;*	MODS
00F24A  1               ;*		Original Author Unknown
00F24A  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F24A  1               ;*		   R. K. Nordin	11/01/83
00F24A  1               
00F24A  1               
00F24A  1               EGB	=	*	;entry
00F24A  1               
00F24A  1               ;	Initialize.
00F24A  1               
00F24A  1  20 62 F9     	JSR	SWA	;swap
00F24D  1  20 BC F6     	JSR	CRE	;check cursor range for editor
00F250  1  A5 6B        	LDA	BUFCNT	;buffer count
00F252  1  D0 34        	BNE	EGB4	;if something in the buffer
00F254  1               
00F254  1               ;	Get line.
00F254  1               
00F254  1  A5 54        	LDA	ROWCRS		;cursor row
00F256  1  85 6C        	STA	BUFSTR		;buffer start pointer
00F258  1  A5 55        	LDA	COLCRS		;low cursor column
00F25A  1  85 6D        	STA	BUFSTR+1	;high buffer start pointer
00F25C  1               
00F25C  1  20 FD F2     EGB1	JSR	KGB	;perform keyboard GET-BYTE
00F25F  1  84 4C        	STY	DSTAT	;status
00F261  1  AD FB 02     	LDA	ATACHR	;ATASCII character
00F264  1  C9 9B        	CMP	#EOL
00F266  1  F0 12        	BEQ	EGB3	;if EOL
00F268  1               
00F268  1  20 BE F2     	JSR	PCH	;process character
00F26B  1  20 62 F9     	JSR	SWA	;swap
00F26E  1  A5 63        	LDA	LOGCOL	;logical column
00F270  1  C9 71        	CMP	#113	;column near column 120
00F272  1  D0 03        	BNE	EGB2	; if not near column 120, no beep
00F274  1               
00F274  1  20 56 F5     	JSR	BEL	;beep
00F277  1               
00F277  1  4C 5C F2     EGB2	JMP	EGB1	;process new character
00F27A  1               
00F27A  1               ;	Process EOL.
00F27A  1               
00F27A  1  20 18 F7     EGB3	JSR	ROD		;restore old data under cur:
00F27D  1  20 B1 F8     	JSR	CBC		;compute buffer count
00F280  1  A5 6C        	LDA	BUFSTR		;buffer start pointer
00F282  1  85 54        	STA	ROWCRS		;cursor row
00F284  1  A5 6D        	LDA	BUFSTR+1	;high buffer start pointer
00F286  1  85 55        	STA	COLCRS		;low cursor column
00F288  1               
00F288  1               ;	Check buffer count.
00F288  1               
00F288  1  A5 6B        EGB4	LDA	BUFCNT	;buffer count
00F28A  1  F0 11        	BEQ	EGB6	;if buffer count zero
00F28C  1               
00F28C  1               ;	Decrement and check buffer count.
00F28C  1               
00F28C  1  C6 6B        EGB5	DEC	BUFCNT	;decrement buffer count
00F28E  1  F0 0D        	BEQ	EGB6	;if buffer count zero
00F290  1               
00F290  1               ;	Check status.
00F290  1               
00F290  1  A5 4C        	LDA	DSTAT	;status
00F292  1  30 F8        	BMI	EGB5	;if error, continue decrementing.
00F294  1               
00F294  1               ;	Perform GET-BYTE.
00F294  1               
00F294  1  20 80 F1     	JSR	SGB	;perform screen GET-BYTE
00F297  1  8D FB 02     	STA	ATACHR	;ATASCII character
00F29A  1  4C 62 F9     	JMP	SWA	;swap, return
00F29D  1               
00F29D  1               ;	Exit.
00F29D  1               
00F29D  1  20 61 F6     EGB6	JSR	RWS	;return with scrolling
00F2A0  1  A9 9B        	LDA	#EOL
00F2A2  1  8D FB 02     	STA	ATACHR	;ATASCII character
00F2A5  1  20 0B F2     	JSR	SEC_	;set exit conditions
00F2A8  1  84 4C        	STY	DSTAT	;status
00F2AA  1  4C 62 F9     	JMP	SWA	;swap, return
00F2AD  1               ;	SPACE	4,10
00F2AD  1               ;**	IRA - Invoke Routine Pointed to by ADRESS
00F2AD  1               ;*
00F2AD  1               ;*	ENTRY	JSR	IRA
00F2AD  1               ;*
00F2AD  1               ;*	MODS
00F2AD  1               ;*		Original Author Unknown
00F2AD  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F2AD  1               ;*		   R. K. Nordin	11/01/83
00F2AD  1               
00F2AD  1               
00F2AD  1               IRA	=	*		;entry
00F2AD  1  6C 64 00     	JMP	(ADRESS)	;execute, return
00F2B0  1               ;	SPACE	4,10
00F2B0  1               ;**	EPB - Perform Editor PUT-BYTE
00F2B0  1               ;*
00F2B0  1               ;*	ENTRY	JSR	EPB
00F2B0  1               ;*
00F2B0  1               ;*	MODS
00F2B0  1               ;*		Original Author Unknown
00F2B0  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F2B0  1               ;*		   R. K. Nordin	11/01/83
00F2B0  1               
00F2B0  1               
00F2B0  1               EPB	=	*	;entry
00F2B0  1  8D FB 02     	STA	ATACHR	;ATASCII character
00F2B3  1  20 62 F9     	JSR	SWA	;swap
00F2B6  1  20 BC F6     	JSR	CRE	;check cursor range for editor
00F2B9  1  A9 00        	LDA	#0
00F2BB  1  8D E8 03     	STA	SUPERF	;clear super function flag
00F2BE  1               ;	JMP	PCH	;process character, return
00F2BE  1               ;	SPACE	4,10
00F2BE  1               ;**	PCH - Process Character
00F2BE  1               ;*
00F2BE  1               ;*	PCH displays the character or processes control cha:
00F2BE  1               ;*	super functions (shifted function keys).
00F2BE  1               ;*
00F2BE  1               ;*	ENTRY	JSR	PCH
00F2BE  1               ;*
00F2BE  1               ;*	MODS
00F2BE  1               ;*		Original Author Unknown
00F2BE  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F2BE  1               ;*		   R. K. Nordin	11/01/83
00F2BE  1               
00F2BE  1               
00F2BE  1               PCH	=	*	;entry
00F2BE  1  20 18 F7     	JSR	ROD	;restore old data under cursor
00F2C1  1  20 3C F9     	JSR	CCC	;check for control character
00F2C4  1  F0 09        	BEQ	PCH2	;if control character
00F2C6  1               
00F2C6  1               ;	Display character.
00F2C6  1               
00F2C6  1  0E A2 02     PCH1	ASL	ESCFLG	;escape flag
00F2C9  1  20 B4 F1     	JSR	CEL	;check EOL
00F2CC  1  4C 62 F9     	JMP	SWA	;swap, return
00F2CF  1               
00F2CF  1               ;	Process control character.
00F2CF  1               
00F2CF  1  AD FE 02     PCH2	LDA	DSPFLG	;display flag
00F2D2  1  0D A2 02     	ORA	ESCFLG	;escape flag
00F2D5  1  D0 EF        	BNE	PCH1	;if display or escape, display chara:
00F2D7  1               
00F2D7  1               ;	Continue.
00F2D7  1               
00F2D7  1  0E A2 02     	ASL	ESCFLG
00F2DA  1  E8           	INX
00F2DB  1               
00F2DB  1               ;	Check for super function.
00F2DB  1               
00F2DB  1  AD E8 03     	LDA	SUPERF
00F2DE  1  F0 05        	BEQ	PCH3		;if not super function
00F2E0  1               
00F2E0  1               ;	Adjust for super function.
00F2E0  1               
00F2E0  1  8A           	TXA
00F2E1  1  18           	CLC
00F2E2  1  69 2D        	ADC	#TSFR-TCCR-3
00F2E4  1  AA           	TAX			;adjusted offset
00F2E5  1               
00F2E5  1               ;	Process control character or super function.
00F2E5  1               
00F2E5  1  BD 0D FB     PCH3	LDA	TCCR,X		;low routine address
00F2E8  1  85 64        	STA	ADRESS
00F2EA  1  BD 0E FB     	LDA	TCCR+1,X	;high routine address
00F2ED  1  85 65        	STA	ADRESS+1
00F2EF  1  20 AD F2     	JSR	IRA		;invoke routine pointed to :
00F2F2  1  20 0B F2     	JSR	SEC_		;set exit conditions
00F2F5  1  4C 62 F9     	JMP	SWA		;swap, return
00F2F8  1               ;	SPACE	4,10
00F2F8  1               ;**	IGN - Ignore Character and Perform Keyboard GET-BYT:
00F2F8  1               ;*
00F2F8  1               ;*	ENTRY	JSR	IGN
00F2F8  1               ;*
00F2F8  1               ;*	EXIT
00F2F8  1               ;*		CH = $FF
00F2F8  1               ;*
00F2F8  1               ;*	MODS
00F2F8  1               ;*		Original Author Unknown
00F2F8  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F2F8  1               ;*		   R. K. Nordin	11/01/83
00F2F8  1               
00F2F8  1               
00F2F8  1               IGN	=	*	;entry
00F2F8  1  A9 FF        	LDA	#$FF	;clear code indicator
00F2FA  1  8D FC 02     	STA	CH	;key code
00F2FD  1               ;	JMP	KGB	;perform keyboard GET-BYTE, return
00F2FD  1               ;	SPACE	4,10
00F2FD  1               ;**	KGB - Perform Kayboard GET-BYTE
00F2FD  1               ;*
00F2FD  1               ;*	ENTRY	JSR	KGB
00F2FD  1               ;*
00F2FD  1               ;*	NOTES
00F2FD  1               ;*		Problem: byte wasted by unnecessary TAX nea:
00F2FD  1               ;*
00F2FD  1               ;*	MODS
00F2FD  1               ;*		Original Author Unknown
00F2FD  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F2FD  1               ;*		   R. K. Nordin	11/01/83
00F2FD  1               
00F2FD  1               
00F2FD  1               KGB	=	*	;entry
00F2FD  1               
00F2FD  1               ;	Initialize.
00F2FD  1               
00F2FD  1  A9 00        KGB1	LDA	#0
00F2FF  1  8D E8 03     	STA	SUPERF	;clear super function flag
00F302  1               
00F302  1               ;	Check for special edit read mode.
00F302  1               
00F302  1  A5 2A        	LDA	ICAX1Z
00F304  1  4A           	LSR	A
00F305  1  B0 6F        	BCS	KGB11	;if special edit read mode
00F307  1               
00F307  1               ;	Check for BREAK abort.
00F307  1               
00F307  1  A9 80        	LDA	#BRKABT	;assume BREAK abort
00F309  1  A6 11        	LDX	BRKKEY	;BREAK key flag
00F30B  1  F0 65        	BEQ	KGB10	;if BREAK abort
00F30D  1               
00F30D  1               ;	Check for character.
00F30D  1               
00F30D  1  AD FC 02     	LDA	CH	;key code
00F310  1  C9 FF        	CMP	#$FF	;clear code indicator
00F312  1  F0 E9        	BEQ	KGB1	;if no character
00F314  1               
00F314  1               ;	Process character.
00F314  1               
00F314  1  85 7C        	STA	HOLDCH	;save character
00F316  1  A2 FF        	LDX	#$FF	;clear code indicator
00F318  1  8E FC 02     	STX	CH	;key code
00F31B  1               
00F31B  1               ;	Sound key click if desired.
00F31B  1               
00F31B  1  AE DB 02     	LDX	NOCLIK	;click inhibit flag
00F31E  1  D0 03        	BNE	KGB2	;if click inhibited
00F320  1               
00F320  1  20 83 F9     	JSR	SKC	;sound key click
00F323  1               
00F323  1               ;	Set offset to key definition.
00F323  1               
00F323  1  A8           KGB2	TAY		;save character
00F324  1               
00F324  1               ;	Check for CTRL and SHIFT together.
00F324  1               
00F324  1  C0 C0        	CPY	#$C0
00F326  1  B0 D0        	BCS	IGN	;if CTRL and SHIFT together, ignore
00F328  1               
00F328  1               ;	Convert to ATASCII character.
00F328  1               
00F328  1  B1 79        	LDA	(KEYDEF),Y	;ATASCII character
00F32A  1               
00F32A  1               ;	Set ATASCII character.
00F32A  1               
00F32A  1  8D FB 02     KGB3	STA	ATACHR	;ATASCII character
00F32D  1  AA           	TAX
00F32E  1  30 03        	BMI	KGB4	;if special key
00F330  1               
00F330  1  4C B4 F3     	JMP	KGB17	;process shift/control lock
00F333  1               
00F333  1               ;	Check for null character.
00F333  1               
00F333  1  C9 80        KGB4	CMP	#$80
00F335  1  F0 C1        	BEQ	IGN	;if null, ignore
00F337  1               
00F337  1               ;	Check for inverse video key.
00F337  1               
00F337  1  C9 81        	CMP	#$81
00F339  1  D0 0A        	BNE	KGB5	;if not inverse video key
00F33B  1               
00F33B  1               ;	Process inverse video key.
00F33B  1               
00F33B  1  AD B6 02     	LDA	INVFLG
00F33E  1  49 80        	EOR	#$80
00F340  1  8D B6 02     	STA	INVFLG
00F343  1  B0 B3        	BCS	IGN	;ignore
00F345  1               
00F345  1               ;	Check for CAPS key.
00F345  1               
00F345  1  C9 82        KGB5	CMP	#$82
00F347  1  D0 0C        	BNE	KGB6	;if not CAPS key
00F349  1               
00F349  1               ;	Process CAPS key.
00F349  1               
00F349  1  AD BE 02     	LDA	SHFLOK	;shift/control lock flags
00F34C  1  F0 0B        	BEQ	KGB7	;if no lock, process CAPS lock
00F34E  1               
00F34E  1  A9 00        	LDA	#$00	;no lock indicator
00F350  1  8D BE 02     	STA	SHFLOK	;shoft/control lock flags
00F353  1  F0 A3        	BEQ	IGN	;ignore
00F355  1               
00F355  1               ;	Check for SHIFT-CAPS key.
00F355  1               
00F355  1  C9 83        KGB6	CMP	#$83
00F357  1  D0 07        	BNE	KGB8	;if not SHIFT-CAPS
00F359  1               
00F359  1               ;	Process SHIFT-CAPS key.
00F359  1               
00F359  1  A9 40        KGB7	LDA	#$40	;CAPS lock indicator
00F35B  1  8D BE 02     	STA	SHFLOK	;shift/control lock flags
00F35E  1  D0 98        	BNE	IGN	;ignore
00F360  1               
00F360  1               ;	Check for CTRL-CAPS key.
00F360  1               
00F360  1  C9 84        KGB8	CMP	#$84
00F362  1  D0 08        	BNE	KGB9	;if not CTRL-CAPS
00F364  1               
00F364  1               ;	Process CTRL-CAPS key.
00F364  1               
00F364  1  A9 80        	LDA	#$80	;control lock indicator
00F366  1  8D BE 02     	STA	SHFLOK	;shift/control lock flags
00F369  1  4C F8 F2     	JMP	IGN	;ignore
00F36C  1               
00F36C  1               ;	Check for CTRL-3 key.
00F36C  1               
00F36C  1  C9 85        KGB9	CMP	#$85
00F36E  1  D0 0B        	BNE	KGB12	;if not CTRL-3 key.
00F370  1               
00F370  1               ;	Process CTRL-3 key.
00F370  1               
00F370  1  A9 88        	LDA	#EOFERR
00F372  1               
00F372  1               ;	Set status and BREAK key flag.
00F372  1               
00F372  1  85 4C        KGB10	STA	DSTAT	;status
00F374  1  85 11        	STA	BRKKEY	;BREAK key flag
00F376  1               
00F376  1               ;	Set EOL character.
00F376  1               
00F376  1  A9 9B        KGB11	LDA	#EOL
00F378  1  4C DA F3     	JMP	KGB19	;set ATASCII character
00F37B  1               
00F37B  1               ;	Check for CTRL-F3 key.
00F37B  1               
00F37B  1  C9 89        KGB12	CMP	#$89
00F37D  1  D0 10        	BNE	KGB14	;if not CTRL-F3 key
00F37F  1               
00F37F  1               ;	Process CTRL-F3 key.
00F37F  1               
00F37F  1  AD DB 02     	LDA	NOCLIK	;toggle keyclick status
00F382  1  49 FF        	EOR	#$FF
00F384  1  8D DB 02     	STA	NOCLIK
00F387  1  D0 03        	BNE	KGB13	;if click inhibited
00F389  1               
00F389  1  20 83 F9     	JSR	SKC	;sound key click
00F38C  1               
00F38C  1  4C F8 F2     KGB13	JMP	IGN	;ignore
00F38F  1               
00F38F  1               ;	Check for function key.
00F38F  1               
00F38F  1  C9 8E        KGB14	CMP	#$8E
00F391  1  B0 12        	BCS	KGB16	;if code >= $8E, not a function key
00F393  1               
00F393  1  C9 8A        	CMP	#$8A
00F395  1  90 F5        	BCC	KGB13	;if code < $8A, not a function key,:
00F397  1               
00F397  1               ;	Process function key.
00F397  1               
00F397  1  E9 8A        	SBC	#$8A		;convert $8A - $bD to 0 - 3
00F399  1  06 7C        	ASL	HOLDCH		;saved character
00F39B  1  10 02        	BPL	KGB15		;if no SHIFT
00F39D  1               
00F39D  1  09 04        	ORA	#$04		;convert 0 - 3 to 4 - 7
00F39F  1               
00F39F  1  A8           KGB15	TAY			;offset to function key def:
00F3A0  1  B1 60        	LDA	(FKDEF),Y	;function key
00F3A2  1  4C 2A F3     	JMP	KGB3		;set ATASCII character
00F3A5  1               
00F3A5  1               ;	Check for super function.
00F3A5  1               
00F3A5  1  C9 92        KGB16	CMP	#$92
00F3A7  1  B0 0B        	BCS	KGB17	;if code >= $92, process shift/cont:
00F3A9  1               
00F3A9  1  C9 8E        	CMP	#$8E
00F3AB  1  90 DF        	BCC	KGB13	;if code < $8E, not super function,:
00F3AD  1               
00F3AD  1               ;	Process super function.
00F3AD  1               
00F3AD  1  E9 72        	SBC	#$8E-$1C	;convert $8E - $91 to $1C -:
00F3AF  1  EE E8 03     	INC	SUPERF		;set super function flag
00F3B2  1  D0 26        	BNE	KGB19		;set ATASCII character
00F3B4  1               
00F3B4  1               ;	Process shift/control lock.
00F3B4  1               
00F3B4  1  A5 7C        KGB17	LDA	HOLDCH	;saved character
00F3B6  1  C9 40        	CMP	#$40
00F3B8  1  B0 15        	BCS	KGB18	;if not lower case
00F3BA  1               
00F3BA  1  AD FB 02     	LDA	ATACHR	;ATASCII character
00F3BD  1  C9 61        	CMP	#'a'
00F3BF  1  90 0E        	BCC	KGB18	;if < "a", do not process
00F3C1  1               
00F3C1  1  C9 7B        	CMP	#'z'+1
00F3C3  1  B0 0A        	BCS	KGB18	;if > "z", do not process
00F3C5  1               
00F3C5  1  AD BE 02     	LDA	SHFLOK	;shift/control lock flags
00F3C8  1  F0 05        	BEQ	KGB18	;if no lock
00F3CA  1               
00F3CA  1  05 7C        	ORA	HOLDCH	;modify character
00F3CC  1  4C 23 F3     	JMP	KGB2	;reprocess character
00F3CF  1               
00F3CF  1               ;	Invert character, if necessary.
00F3CF  1               
00F3CF  1  20 3C F9     KGB18	JSR	CCC	;check for control character
00F3D2  1  F0 09        	BEQ	KGB20	;if control character, do not inver:
00F3D4  1               
00F3D4  1  AD FB 02     	LDA	ATACHR	;ATASCII character
00F3D7  1  4D B6 02     	EOR	INVFLG	;invert character
00F3DA  1               
00F3DA  1               ;	Set ATASCII character.
00F3DA  1               
00F3DA  1  8D FB 02     KGB19	STA	ATACHR	;ATASCII character
00F3DD  1               ;	Exit
00F3DD  1               
00F3DD  1  4C 1E F2     KGB20	JMP	SST	;perform screen status, return
00F3E0  1               ;	SPACE	4,10
00F3E0  1               ;**	ESC - Escape
00F3E0  1               ;*
00F3E0  1               ;*	ENTRY	JSR	ESC
00F3E0  1               ;*
00F3E0  1               ;*	MODS
00F3E0  1               ;*		Original Author Unknown
00F3E0  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F3E0  1               ;*		   R. K. Nordin	11/01/83
00F3E0  1               
00F3E0  1               
00F3E0  1               ESC	=	*	;entry
00F3E0  1  A9 80        	LDA	#$80	;indicate escape detected
00F3E2  1  8D A2 02     	STA	ESCFLG	;escape flag
00F3E5  1  60           	RTS		;return
00F3E6  1               ;	SPACE	4,10
00F3E6  1               ;**	CUP - Move Cursor Up
00F3E6  1               ;*
00F3E6  1               ;*	ENTRY	JSR	CUP
00F3E6  1               ;*
00F3E6  1               ;*	MODS
00F3E6  1               ;*		Original Author Unknown
00F3E6  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F3E6  1               ;*		   R. K. Nordin	11/01/83
00F3E6  1               
00F3E6  1               
00F3E6  1               CUP	=	*	;entry
00F3E6  1  C6 54        	DEC	ROWCRS	;decrement cursor row
00F3E8  1  10 06        	BPL	CUP2	;if row positive
00F3EA  1               
00F3EA  1  AE BF 02     	LDX	BOTSCR	;screen bottom
00F3ED  1  CA           	DEX		;screen bottom - 1
00F3EE  1               
00F3EE  1  86 54        CUP1	STX	ROWCRS	;update cursor row
00F3F0  1               
00F3F0  1  4C 0C F9     CUP2	JMP	SBS	;set buffer start and logical colum:
00F3F3  1               ;	SPACE	4,10
00F3F3  1               ;**	CDN - Move Cursor Down
00F3F3  1               ;*
00F3F3  1               ;*	ENTRY	JSR	CDN
00F3F3  1               ;*
00F3F3  1               ;*	MODS
00F3F3  1               ;*		Original Author Unknown
00F3F3  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F3F3  1               ;*		   R. K. Nordin	11/01/83
00F3F3  1               
00F3F3  1               
00F3F3  1               CDN	=	*	;entry
00F3F3  1  E6 54        	INC	ROWCRS	;increment cursor row
00F3F5  1  A5 54        	LDA	ROWCRS	;cursor row
00F3F7  1  CD BF 02     	CMP	BOTSCR	;screen bottom
00F3FA  1  90 F4        	BCC	CUP2	;if at bottom, set buffer start, re:
00F3FC  1               
00F3FC  1  A2 00        	LDX	#0
00F3FE  1  F0 EE        	BEQ	CUP1	;update cursor row, return
00F400  1               ;	SPACE	4,10
00F400  1               ;**	CLF - Move Cursor Left
00F400  1               ;*
00F400  1               ;*	ENTRY	JSR	CLF
00F400  1               ;*
00F400  1               ;*	MODS
00F400  1               ;*		Original Author Unknown
00F400  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F400  1               ;*		   R. K. Nordin	11/01/83
00F400  1               
00F400  1               
00F400  1               CLF	=	*	;entry
00F400  1  C6 55        	DEC	COLCRS	;decrement low cursor column
00F402  1  A5 55        	LDA	COLCRS	;low cursor column
00F404  1  30 04        	BMI	CRM	;if negative, move cursor to margin:
00F406  1               
00F406  1  C5 52        	CMP	LMARGN	;left margin
00F408  1  B0 04        	BCS	SCC1	;if at left margin, set logical col:
00F40A  1               
00F40A  1               ;	JMP	CRM	;move cursor to right margin, retur:
00F40A  1               ;	SPACE	4,10
00F40A  1               ;**	CRM - Move Cursor to Right Margin
00F40A  1               ;*
00F40A  1               ;*	ENTRY	JSR	CRM
00F40A  1               ;*
00F40A  1               ;*	MODS
00F40A  1               ;*		Original Author Unknown
00F40A  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F40A  1               ;*		   R. K. Nordin	11/01/83
00F40A  1               
00F40A  1               
00F40A  1               CRM	=	*	;entry
00F40A  1  A5 53        	LDA	RMARGN	;right margin
00F40C  1               ;	JMP	SCC	;set cursor column, return
00F40C  1               ;	SPACE	4,10
00F40C  1               ;**	SCC - Set Cursor Column
00F40C  1               ;*
00F40C  1               ;*	ENTRY	JSR	SCC
00F40C  1               ;*
00F40C  1               ;*	MODS
00F40C  1               ;*		Original Author Unknown
00F40C  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F40C  1               ;*		   R. K. Nordin	11/01/83
00F40C  1               
00F40C  1               
00F40C  1               SCC	=	*	;entry
00F40C  1  85 55        	STA	COLCRS	;set low cursor column
00F40E  1               
00F40E  1  4C 8E F8     SCC1	JMP	SLC	;set logical column, return
00F411  1               ;	SPACE	4,10
00F411  1               ;**	CRT - Move Cursor Right
00F411  1               ;*
00F411  1               ;*	ENTRY	JSR	CRT
00F411  1               ;*
00F411  1               ;*	MODS
00F411  1               ;*		Original Author Unknown
00F411  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F411  1               ;*		   R. K. Nordin	11/01/83
00F411  1               
00F411  1               
00F411  1               CRT	=	*	;entry
00F411  1  E6 55        	INC	COLCRS	;increment low cursor column
00F413  1  A5 55        	LDA	COLCRS	;low cursor column
00F415  1  C5 53        	CMP	RMARGN	;right margin
00F417  1  90 F5        	BCC	SCC1	;if before right margin, process, r:
00F419  1               
00F419  1  F0 F3        	BEQ	SCC1	;if at right margin
00F41B  1               
00F41B  1               ;	JMP	CLM	;move cursor to left margin, return
00F41B  1               ;	SPACE	4,10
00F41B  1               ;**	CLM - Move Cursor to Left Margin
00F41B  1               ;*
00F41B  1               ;*	ENTRY	JSR	CLM
00F41B  1               ;*
00F41B  1               ;*	MODS
00F41B  1               ;*		Original Author Unknown
00F41B  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F41B  1               ;*		   R. K. Nordin	11/01/83
00F41B  1               
00F41B  1               
00F41B  1               CLM	=	*	;entry
00F41B  1  A5 52        	LDA	LMARGN	;left margin
00F41D  1  4C 0C F4     	JMP	SCC	;set cursor column, return
00F420  1               ;	SPACE	4,10
00F420  1               ;**	CSC - Clear Screen
00F420  1               ;*
00F420  1               ;*	ENTRY	JSR	CSC
00F420  1               ;*
00F420  1               ;*	MODS
00F420  1               ;*		Original Author Unknown
00F420  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F420  1               ;*		   R. K. Nordin	11/01/83
00F420  1               
00F420  1               
00F420  1               CSC	=	*	;entry
00F420  1               
00F420  1               ;	Set memory scan counter address.
00F420  1               
00F420  1  20 A6 F9     	JSR	SMS	;set memory scan counter ad:
00F423  1               
00F423  1               ;	Clear address.
00F423  1               
00F423  1  A4 64        	LDY	ADRESS
00F425  1  A9 00        	LDA	#0
00F427  1  85 64        	STA	ADRESS
00F429  1               
00F429  1  91 64        CSC1	STA	(ADRESS),Y
00F42B  1  C8           	INY
00F42C  1  D0 FB        	BNE	CSC1		;if not done with page
00F42E  1               
00F42E  1  E6 65        	INC	ADRESS+1
00F430  1  A6 65        	LDX	ADRESS+1
00F432  1  E4 6A        	CPX	RAMTOP		;(high) RAM size
00F434  1  90 F3        	BCC	CSC1		;if not done
00F436  1               
00F436  1               ;	Clean up logical line bit map
00F436  1               
00F436  1               ;	LDY	#0		;offset to first byte of bi:
00F436  1  A9 FF        	LDA	#$FF
00F438  1               
00F438  1  99 B2 02     CSC2	STA	LOGMAP,Y	;byte of logical line bit m:
00F43B  1  C8           	INY
00F43C  1  C0 04        	CPY	#4		;4 bytes
00F43E  1  90 F8        	BCC	CSC2		;if not done
00F440  1               
00F440  1               ;	Exit.
00F440  1               
00F440  1               ;	JMP	CHM		;move cursor home, return
00F440  1               ;	SPACE	4,10
00F440  1               ;**	CHM - Move Cursor Home
00F440  1               ;*
00F440  1               ;*	ENTRY	JSR	CHM
00F440  1               ;*
00F440  1               ;*	MODS
00F440  1               ;*		Original Author Unknown
00F440  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F440  1               ;*		   R. K. Nordin	11/01/83
00F440  1               
00F440  1               
00F440  1               CHM	=	*		;entry
00F440  1  20 97 F9     	JSR	SCL		;set cursor at left edge
00F443  1  85 63        	STA	LOGCOL		;logical column
00F445  1  85 6D        	STA	BUFSTR+1	;high buffer start
00F447  1  A9 00        	LDA	#0
00F449  1  85 54        	STA	ROWCRS		;cursor row
00F44B  1  85 56        	STA	COLCRS+1	;high cursor column
00F44D  1  85 6C        	STA	BUFSTR		;low buffer start pointer
00F44F  1  60           	RTS			;return
00F450  1               ;	SPACE	4,10
00F450  1               ;**	BSP - Backspace
00F450  1               ;*
00F450  1               ;*	ENTRY	JSR	BSP
00F450  1               ;*
00F450  1               ;*	MODS
00F450  1               ;*		Original Author Unknown
00F450  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F450  1               ;*		   R. K. Nordin	11/01/83
00F450  1               
00F450  1               
00F450  1               BSP	=	*	;entry
00F450  1  A5 63        	LDA	LOGCOL	;logical column
00F452  1  C5 52        	CMP	LMARGN	;left margin
00F454  1  F0 21        	BEQ	BSP3	;if at left margin
00F456  1               
00F456  1  A5 55        	LDA	COLCRS	;low cursor column
00F458  1  C5 52        	CMP	LMARGN	;left margin
00F45A  1  D0 03        	BNE	BSP1	;if not atleft margin
00F45C  1               
00F45C  1  20 23 F9     	JSR	DWQ	;see if line should be deleted
00F45F  1               
00F45F  1  20 00 F4     BSP1	JSR	CLF	;move cursor left
00F462  1  A5 55        	LDA	COLCRS	;low cursor column
00F464  1  C5 53        	CMP	RMARGN	;right margin
00F466  1  D0 07        	BNE	BSP2	;if not at right margin
00F468  1               
00F468  1  A5 54        	LDA	ROWCRS	;cursor low
00F46A  1  F0 03        	BEQ	BSP2	;if row zero
00F46C  1               
00F46C  1  20 E6 F3     	JSR	CUP	;move cursor up
00F46F  1               
00F46F  1  A9 20        BSP2	LDA	#' '
00F471  1  8D FB 02     	STA	ATACHR	;ATASCII character
00F474  1  20 CA F1     	JSR	PLO	;plot point
00F477  1               
00F477  1  4C 8E F8     BSP3	JMP	SLC	;set logical column, return
00F47A  1               ;	SPACE	4,10
00F47A  1               ;**	TAB - Tab
00F47A  1               ;*
00F47A  1               ;*	ENTRY	JSR	TAB
00F47A  1               ;*
00F47A  1               ;*	MODS
00F47A  1               ;*		Original Author Unknown
00F47A  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F47A  1               ;*		   R. K. Nordin	11/01/83
00F47A  1               
00F47A  1               
00F47A  1               TAB	=	*	;entry
00F47A  1               
00F47A  1  20 11 F4     TAB1	JSR	CRT	;move cursor right
00F47D  1  A5 55        	LDA	COLCRS	;low cursor column
00F47F  1  C5 52        	CMP	LMARGN	;left margin
00F481  1  D0 08        	BNE	TAB2	;if not at left margin
00F483  1               
00F483  1  20 65 F6     	JSR	RET	;return
00F486  1  20 58 F7     	JSR	BLG	;get bit from logical line bit map
00F489  1  B0 07        	BCS	TAB3	;if end of logical line
00F48B  1               
00F48B  1               ;	Check for tab stop.
00F48B  1               
00F48B  1  A5 63        TAB2	LDA	LOGCOL	;logical column
00F48D  1  20 5D F7     	JSR	BMG	;set bit from bit map
00F490  1  90 E8        	BCC	TAB1	;if not tab stop, keep looking
00F492  1               
00F492  1               ;	Set logical lolumn
00F492  1               
00F492  1  4C 8E F8     TAB3	JMP	SLC	;set logical column, return
00F495  1               ;	SPACE	4,10
00F495  1               ;**	STB - Set Tab
00F495  1               ;*
00F495  1               ;*	ENTRY	JSR	STB
00F495  1               ;*
00F495  1               ;*	MODS
00F495  1               ;*		Original Author Unknown
00F495  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F495  1               ;*		   R. K. Nordin	11/01/83
00F495  1               
00F495  1               
00F495  1               STB	=	*	;entry
00F495  1  A5 63        	LDA	LOGCOL	;logical column
00F497  1  4C 3E F7     	JMP	BMS	;set bit in bit map, retrun
00F49A  1               ;	SPACE	4,10
00F49A  1               ;**	CTB - Clear Tab
00F49A  1               ;*
00F49A  1               ;*	ENTRY	JSR	CTB
00F49A  1               ;*
00F49A  1               ;*	MODS
00F49A  1               ;*		Original Author Unknown
00F49A  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F49A  1               ;*		   R. K. Nordin	11/01/83
00F49A  1               
00F49A  1               
00F49A  1               CTB	=	*	;entry
00F49A  1  A5 63        	LDA	LOGCOL	;logical column
00F49C  1  4C 4A F7     	JMP	BMC	;clear bit in bit map, return
00F49F  1               ;	SPACE	4,10
00F49F  1               ;**	ICH - Insert Character
00F49F  1               ;*
00F49F  1               ;*	ENTRY	JSR	ICH
00F49F  1               ;*
00F49F  1               ;*	MODS
00F49F  1               ;*		Original Author Unknown
00F49F  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F49F  1               ;*		   R. K. Nordin	11/01/83
00F49F  1               
00F49F  1               
00F49F  1               ICH	=	*	;entry
00F49F  1  20 4C F9     	JSR	SRC	;save row and column
00F4A2  1  20 8F F1     	JSR	GDC	;get data under cursor
00F4A5  1  85 7D        	STA	INSDAT
00F4A7  1  A9 00        	LDA	#0
00F4A9  1  8D BB 02     	STA	SCRFLG
00F4AC  1               
00F4AC  1  20 E9 F1     ICH1	JSR	SPQ	;store data
00F4AF  1  A5 63        	LDA	LOGCOL	;logical column
00F4B1  1  48           	PHA		;save logical column
00F4B2  1  20 12 F6     	JSR	ACC	;advance cursor column
00F4B5  1  68           	PLA		;saved logical column
00F4B6  1  C5 63        	CMP	LOGCOL	;logical column
00F4B8  1  B0 0C        	BCS	ICH2	;if saved logical column >= logical:
00F4BA  1               
00F4BA  1  A5 7D        	LDA	INSDAT
00F4BC  1  48           	PHA
00F4BD  1  20 8F F1     	JSR	GDC	;get data under cursor
00F4C0  1  85 7D        	STA	INSDAT
00F4C2  1  68           	PLA
00F4C3  1  4C AC F4     	JMP	ICH1	;continue
00F4C6  1               
00F4C6  1               ;	Exit.
00F4C6  1               
00F4C6  1  20 57 F9     ICH2	JSR	RRC	;restore row and column
00F4C9  1               
00F4C9  1  CE BB 02     ICH3	DEC	SCRFLG
00F4CC  1  30 04        	BMI	ICH4	;if scroll occured
00F4CE  1               
00F4CE  1  C6 54        	DEC	ROWCRS	;decrement cursor row
00F4D0  1  D0 F7        	BNE	ICH3	;continue
00F4D2  1               
00F4D2  1  4C 8E F8     ICH4	JMP	SLC	;set logical column, return
00F4D5  1               ;	SPACE	4,10
00F4D5  1               ;**	DCH - Delete Character
00F4D5  1               ;*
00F4D5  1               ;*	ENTRY	JSR	DCH
00F4D5  1               ;*
00F4D5  1               ;*	MODS
00F4D5  1               ;*		Original Author Unknown
00F4D5  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F4D5  1               ;*		   R. K. Nordin	11/01/83
00F4D5  1               
00F4D5  1               
00F4D5  1               DCH	=	*		;entry
00F4D5  1               
00F4D5  1               ;	Save row and column.
00F4D5  1               
00F4D5  1  20 4C F9     	JSR	SRC		;save row and column
00F4D8  1               
00F4D8  1               ;	Get data to the right of cursor.
00F4D8  1               
00F4D8  1  20 AC F5     DCH1	JSR	CCA	;convert cursor row/column to addre:
00F4DB  1  A5 64        	LDA	ADRESS
00F4DD  1  85 68        	STA	SAVADR	;save address
00F4DF  1  A5 65        	LDA	ADRESS+1
00F4E1  1  85 69        	STA	SAVADR+1
00F4E3  1  A5 63        	LDA	LOGCOL	;logical column
00F4E5  1  48           	PHA		;save lgical column
00F4E6  1  20 0A F6     	JSR	SZA	;set zero data and advance cursor
00F4E9  1  68           	PLA		;saved logical column
00F4EA  1  C5 63        	CMP	LOGCOL	;logical column
00F4EC  1  B0 10        	BCS	DCH2	;if saved logical column >= logical
00F4EE  1               
00F4EE  1  A5 54        	LDA	ROWCRS		;cursor row
00F4F0  1  CD BF 02     	CMP	BOTSCR		;screen bottom
00F4F3  1  B0 09        	BCS	DCH2		;if row off screem, exit
00F4F5  1               
00F4F5  1  20 8F F1     	JSR	GDC		;get data under cursor
00F4F8  1  A0 00        	LDY	#0
00F4FA  1  91 68        	STA	(SAVADR),Y	;put data in previous posit:
00F4FC  1  F0 DA        	BEQ	DCH1		;continue
00F4FE  1               
00F4FE  1  A0 00        DCH2	LDY	#0
00F500  1  98           	TYA
00F501  1  91 68        	STA	(SAVADR),Y	;clear last position
00F503  1  20 18 F9     	JSR	DQQ		;try to delete a line
00F506  1  20 57 F9     	JSR	RRC		;restore row and column
00F509  1  4C 8E F8     	JMP	SLC		;set logical column, return
00F50C  1               ;	SPACE	4,10
00F50C  1               ;**	ILN - Insert Line
00F50C  1               ;*
00F50C  1               ;*	ENTRY	JSR	ILN
00F50C  1               ;*
00F50C  1               ;*	MODS
00F50C  1               ;*		Original Author Unknown
00F50C  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F50C  1               ;*		   R. K. Nordin	11/01/83
00F50C  1               
00F50C  1               
00F50C  1               ILN	=	*	;entry
00F50C  1  38           	SEC
00F50D  1               ;	JMP	ILN1
00F50D  1               ;	SPACE	4,10
00F50D  1               ;**	ILN1 - Insert Line
00F50D  1               ;*
00F50D  1               ;*	ENTRY	JSR	ILN1
00F50D  1               ;*
00F50D  1               ;*	MODS
00F50D  1               ;*		Original Author Unknown
00F50D  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F50D  1               ;*		   R. K. Nordin	11/01/83
00F50D  1               
00F50D  1               
00F50D  1               ILN1	=	*	;entry
00F50D  1  20 C2 F7     	JSR	ELL	;extend logical line
00F510  1  A5 52        	LDA	LMARGN	;left margin
00F512  1  85 55        	STA	COLCRS	;low cursor column
00F514  1  20 AC F5     	JSR	CCA	;convert cursor row/column to addre:
00F517  1  20 8E F7     	JSR	MLN	;move line
00F51A  1  20 E2 F7     	JSR	CLN	;clear current line
00F51D  1  4C 8E F8     	JMP	SLC	;set logical column, return
00F520  1               ;	SPACE	4,10
00F520  1               ;**	DLN - Delete Line
00F520  1               ;*
00F520  1               ;*	ENTRY	JSR	DLN
00F520  1               ;*
00F520  1               ;*	MODS
00F520  1               ;*		Original Author Unknown
00F520  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F520  1               ;*		   R. K. Nordin	11/01/83
00F520  1               
00F520  1               
00F520  1               DLN	=	*	;entry
00F520  1  20 8E F8     	JSR	SLC	;set logical column
00F523  1  A4 51        	LDY	HOLD1
00F525  1  84 54        	STY	ROWCRS	;cursor row
00F527  1               ;	JMP	DLN1
00F527  1               ;	SPACE	4,10
00F527  1               ;**	DLN1 - Delete Line
00F527  1               ;*
00F527  1               ;*	ENTRY	JSR	DLN1
00F527  1               ;*
00F527  1               ;*	MODS
00F527  1               ;*		Original Author Unknown
00F527  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F527  1               ;*		   R. K. Nordin	11/01/83
00F527  1               
00F527  1               
00F527  1               DLN1	=	*		;entry
00F527  1               
00F527  1  A4 54        DLN0	LDY	ROWCRS		;cursor row
00F529  1               
00F529  1  98           DLN2	TYA
00F52A  1  38           	SEC
00F52B  1  20 5B F7     	JSR	BLG2		;get next bit
00F52E  1  08           	PHP
00F52F  1  98           	TYA
00F530  1  18           	CLC
00F531  1  69 78        	ADC	#8*(LOGMAP-TABMAP)	;add offset for log:
00F533  1  28           	PLP
00F534  1  20 3C F7     	JSR	BMP		;put bit in bit map
00F537  1  C8           	INY
00F538  1  C0 18        	CPY	#24
00F53A  1  D0 ED        	BNE	DLN2		;if not done
00F53C  1               
00F53C  1  AD B4 02     	LDA	LOGMAP+2
00F53F  1  09 01        	ORA	#1		;set least significant bit
00F541  1  8D B4 02     	STA	LOGMAP+2	;update logical line bit ma:
00F544  1  A9 00        	LDA	#0		;delete line of data
00F546  1  85 55        	STA	COLCRS		;low cursor column
00F548  1  20 AC F5     	JSR	CCA		;convert cursor row/column :
00F54B  1  20 2A F8     	JSR	SSD		;scroll screen for delete
00F54E  1               
00F54E  1               ;	Check for new logical line.
00F54E  1               
00F54E  1  20 58 F7     	JSR	BLG		;get bit from logical line :
00F551  1  90 D4        	BCC	DLN0		;if not new logical line
00F553  1               
00F553  1               ;	Move cursor to left margin.
00F553  1               
00F553  1  4C 1B F4     	JMP	CLM		;move cursor to left margin:
00F556  1               ;	SPACE	4,10
00F556  1               ;**	BEL - Sound Bell
00F556  1               ;*
00F556  1               ;*	ENTRY	JSR	BEL
00F556  1               ;*
00F556  1               ;*	MODS
00F556  1               ;*		Original Author Unknown
00F556  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F556  1               ;*		   R. K. Nordin	11/01/83
00F556  1               
00F556  1               
00F556  1               BEL	=	*	;entry
00F556  1  A0 20        	LDY	#$20
00F558  1               
00F558  1  20 83 F9     BEL1	JSR	SKC	;sound key click
00F55B  1  88           	DEY
00F55C  1  10 FA        	BPL	BEL1	;if not done
00F55E  1               
00F55E  1  60           	RTS		;return
00F55F  1               ;	SPACE	4,10
00F55F  1               ;**	CBT - Move Cursor to Bottom
00F55F  1               ;*
00F55F  1               ;*	ENTRY	JSR	CBT
00F55F  1               ;*
00F55F  1               ;*	MODS
00F55F  1               ;*		Original Author Unknown
00F55F  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F55F  1               ;*		   R. K. Nordin	11/01/83
00F55F  1               
00F55F  1               
00F55F  1               CBT	=	*	;entry
00F55F  1  20 40 F4     	JSR	CHM	;move cursor home
00F562  1  4C E6 F3     	JMP	CUP	;move cursor up, return
00F565  1               ;	SPACE	4,10
00F565  1               ;**	DDD - Perform Double Byte Double Decrement
00F565  1               ;*
00F565  1               ;*	ENTRY	JSR	DDD
00F565  1               ;*
00F565  1               ;*	MODS
00F565  1               ;*		Original Author Unknown
00F565  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F565  1               ;*		   R. K. Nordin	11/01/83
00F565  1               
00F565  1               
00F565  1               DDD	=	*	;entry
00F565  1  A9 02        	LDA	#2	;indicate subtracting 2
00F567  1  D0 11        	BNE	DBS	;perform double byte subtract, retu:
00F569  1               ;	SPACE	4,10
00F569  1               ;**	SDF - Store Data Indirect for Fine Scrolling
00F569  1               ;*
00F569  1               ;*	ENTRY	JSR	SDF
00F569  1               ;*
00F569  1               ;*	MODS
00F569  1               ;*		Original Author Unknown
00F569  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F569  1               ;*		   R. K. Nordin	11/01/83
00F569  1               
00F569  1               
00F569  1               SDF	=	*	;entry
00F569  1  AC 6E 02     	LDY	FINE
00F56C  1  F0 02        	BEQ	SDI	;if not fine scrolling
00F56E  1               
00F56E  1  09 20        	ORA	#$20	;enable vertical scroll
00F570  1               ;	JMP	SDI	;store data indirect, return
00F570  1               ;	SPACE	4,10
00F570  1               ;**	SDI - Store Data Indirect
00F570  1               ;*
00F570  1               ;*	ENTRY	JSR	SDI
00F570  1               ;*
00F570  1               ;*	MODS
00F570  1               ;*		Original Author Unknown
00F570  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F570  1               ;*		   R. K. Nordin	11/01/83
00F570  1               
00F570  1               
00F570  1               SDI	=	*	;entry
00F570  1               
00F570  1               ;	Check current status.
00F570  1               
00F570  1  A4 4C        	LDY	DSTAT	;status
00F572  1  30 2B        	BMI	DBS3	;if error, return
00F574  1               
00F574  1               ;	Store data.
00F574  1               
00F574  1  A0 00        	LDY	#0
00F576  1  91 64        	STA	(ADRESS),Y
00F578  1               
00F578  1               ;	Decrement.
00F578  1               
00F578  1               ;	JMP	DSD	;perform double byte single decreme:
00F578  1               ;	SPACE	4,10
00F578  1               ;**	DSD - Perform Double Byte Single Decrement
00F578  1               ;*
00F578  1               ;*	ENTRY	JSR	DSD
00F578  1               ;*
00F578  1               ;*	MODS
00F578  1               ;*		Original Author Unknown
00F578  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F578  1               ;*		   R. K. Nordin	11/01/83
00F578  1               
00F578  1               
00F578  1               DSD	=	*	;entry
00F578  1  A9 01        	LDA	#1	;indicate subtracting 1
00F57A  1               ;	JMP	DBS	;perform double byte subtract, retu:
00F57A  1               ;	SPACE	4,10
00F57A  1               ;**	DBS - Perform Double Byte Subtract
00F57A  1               ;*
00F57A  1               ;*	ENTRY	JSR	DBS
00F57A  1               ;*
00F57A  1               ;*	MODS
00F57A  1               ;*		Original Author Unknown
00F57A  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F57A  1               ;*		   R. K. Nordin	11/01/83
00F57A  1               
00F57A  1               
00F57A  1               DBS	=	*	;entry
00F57A  1               
00F57A  1               ;	Initialize.
00F57A  1               
00F57A  1  8D 9E 02     	STA	SUBTMP
00F57D  1               
00F57D  1               ;	Check current status.
00F57D  1               
00F57D  1  A5 4C        	LDA	DSTAT		;status
00F57F  1  30 1E        	BMI	DBS3		;if error
00F581  1               
00F581  1               ;	Subtract.
00F581  1               
00F581  1  A5 64        	LDA	ADRESS
00F583  1  38           	SEC
00F584  1  ED 9E 02     	SBC	SUBTMP
00F587  1  85 64        	STA	ADRESS
00F589  1  B0 02        	BCS	DBS1		;if no borrow
00F58B  1               
00F58B  1  C6 65        	DEC	ADRESS+1	;adjust high byte
00F58D  1               
00F58D  1               ;	Check for overwriting APPMHI.
00F58D  1               
00F58D  1  A5 0F        DBS1	LDA	APPMHI+1
00F58F  1  C5 65        	CMP	ADRESS+1
00F591  1  90 0C        	BCC	DBS3		;if not overwriting APPMHI
00F593  1               
00F593  1  D0 06        	BNE	DBS2		;if overwriting APPMHI, err:
00F595  1               
00F595  1  A5 0E        	LDA	APPMHI
00F597  1  C5 64        	CMP	ADRESS
00F599  1  90 04        	BCC	DBS3		;if not overwriting APPMHI
00F59B  1               
00F59B  1               ;	Process error.
00F59B  1               
00F59B  1  A9 93        DBS2	LDA	#SCRMEM		;indicate insufficient memo:
00F59D  1  85 4C        	STA	DSTAT		;status
00F59F  1               
00F59F  1               ;	Exit.
00F59F  1               
00F59F  1  60           DBS3	RTS		;return
00F5A0  1               ;	SPACE	4,10
00F5A0  1               ;**	SSE - Set Scrolling Display List Entry
00F5A0  1               ;*
00F5A0  1               ;*	Store extra line in display list for fine scrolling:
00F5A0  1               ;*
00F5A0  1               ;*	ENTRY	JSR	SSE
00F5A0  1               ;*
00F5A0  1               ;*	MODS
00F5A0  1               ;*		H. Stewart	06/01/82
00F5A0  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F5A0  1               ;*		   R. K. Nordin	11/01/83
00F5A0  1               
00F5A0  1               
00F5A0  1               SSE	=	*	;entry
00F5A0  1  A9 02        	LDA	#$02
00F5A2  1  20 70 F5     	JSR	SDI	;store data indirect
00F5A5  1  A9 A2        	LDA	#$A2	;DLI on last visible line
00F5A7  1  20 70 F5     	JSR	SDI	;store data indirect
00F5AA  1  CA           	DEX
00F5AB  1  60           	RTS		;return
00F5AC  1               ;	SPACE	4,10
00F5AC  1               ;**	CCA - Convert Cursor Row/Column to Address
00F5AC  1               ;*
00F5AC  1               ;*	ENTRY	JSR	CCA
00F5AC  1               ;*
00F5AC  1               ;*	MODS
00F5AC  1               ;*		L. Winner	06/01/82
00F5AC  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F5AC  1               ;*		   R. K. Nordin	11/01/83
00F5AC  1               
00F5AC  1               
00F5AC  1               CCA	=	*		;entry
00F5AC  1  A2 01        	LDX	#1
00F5AE  1  86 66        	STX	MLTTMP		;initialize
00F5B0  1  CA           	DEX
00F5B1  1  86 65        	STX	ADRESS+1	;clear high address
00F5B3  1  A5 54        	LDA	ROWCRS		;cursor row position
00F5B5  1  0A           	ASL	A		;2 times row position
00F5B6  1  26 65        	ROL	ADRESS+1
00F5B8  1  0A           	ASL	A		;4 time row position
00F5B9  1  26 65        	ROL	ADRESS+1
00F5BB  1  65 54        	ADC	ROWCRS		;add to get 5 times row pos:
00F5BD  1  85 64        	STA	ADRESS
00F5BF  1  90 02        	BCC	CCA1
00F5C1  1               
00F5C1  1  E6 65        	INC	ADRESS+1
00F5C3  1               
00F5C3  1  A4 57        CCA1	LDY	DINDEX		;mode
00F5C5  1  BE 6D EE     	LDX	TLSC,Y		;left shift count
00F5C8  1               
00F5C8  1  06 64        CCA2	ASL	ADRESS		;ADRESS = ADRESS*X
00F5CA  1  26 65        	ROL	ADRESS+1	;divide
00F5CC  1  CA           	DEX
00F5CD  1  D0 F9        	BNE	CCA2
00F5CF  1               
00F5CF  1  A5 56        	LDA	COLCRS+1	;high cursor column
00F5D1  1  4A           	LSR	A		;save least significant bit
00F5D2  1  A5 55        	LDA	COLCRS		;low cursor column
00F5D4  1  BE 9D EE     	LDX	TRSC,Y		;right shift count
00F5D7  1  F0 06        	BEQ	CCA4		;if no shift
00F5D9  1               
00F5D9  1  6A           CCA3	ROR	A		;roll in carry
00F5DA  1  06 66        	ASL	MLTTMP		;shift index
00F5DC  1  CA           	DEX
00F5DD  1  D0 FA        	BNE	CCA3
00F5DF  1               
00F5DF  1  65 64        CCA4	ADC	ADRESS		;add address
00F5E1  1  90 02        	BCC	CCA5		;if no carry
00F5E3  1               
00F5E3  1  E6 65        	INC	ADRESS+1	;adjuct high address
00F5E5  1               
00F5E5  1  18           CCA5	CLC
00F5E6  1  65 58        	ADC	SAVMSC		;add saved memory scan coun:
00F5E8  1  85 64        	STA	ADRESS		;update address
00F5EA  1  85 5E        	STA	OLDADR		;save address
00F5EC  1  A5 65        	LDA	ADRESS+1
00F5EE  1  65 59        	ADC	SAVMSC+1
00F5F0  1  85 65        	STA	ADRESS+1
00F5F2  1  85 5F        	STA	OLDADR+1
00F5F4  1               
00F5F4  1  BE 9D EE     	LDX	TRSC,Y
00F5F7  1  BD 04 FB     	LDA	TMSK,X
00F5FA  1  25 55        	AND	COLCRS		;and in low cursor column
00F5FC  1  65 66        	ADC	OPNTMP
00F5FE  1  A8           	TAY
00F5FF  1  B9 AC EE     	LDA	TDSM-1,Y	;display mask
00F602  1  8D A0 02     	STA	DMASK		;display mask
00F605  1  85 6F        	STA	SHFAMT
00F607  1  A0 00        	LDY	#0
00F609  1               
00F609  1  60           CCA6	RTS			;return
00F60A  1               ;	SPACE	4,10
00F60A  1               ;**	SZA - Set Zero Data and Advance Cursor Column
00F60A  1               ;*
00F60A  1               ;*	ENTRY	JSR	SZA
00F60A  1               ;*
00F60A  1               ;*	MODS
00F60A  1               ;*		Original Author Unknown
00F60A  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F60A  1               ;*		   R. K. Nordin	11/01/83
00F60A  1               
00F60A  1               
00F60A  1               SZA	=	*	;entry
00F60A  1  A9 00        	LDA	#0
00F60C  1  F0 02        	BEQ	SDA	;set data and advance cursor
00F60E  1               ;	SPACE	4,10
00F60E  1               ;**	SEA - Set EOL Data and Advance Cursor Column
00F60E  1               ;*
00F60E  1               ;*	ENTRY	JSR	SEA
00F60E  1               ;*
00F60E  1               ;*	MODS
00F60E  1               ;*		Original Author Unknown
00F60E  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F60E  1               ;*		   R. K. Nordin	11/01/83
00F60E  1               
00F60E  1               
00F60E  1               SEA	=	*	;entry
00F60E  1  A9 9B        	LDA	#EOL	;special case eliminator
00F610  1               ;	JMP	SDA	;set data and advance cursor, retur:
00F610  1               ;	SPACE	4,10
00F610  1               ;**	SDA - Set Data and Advance Cursor Column
00F610  1               ;*
00F610  1               ;*	ENTRY	JSR	SDA
00F610  1               ;*
00F610  1               ;*	MODS
00F610  1               ;*		Original Author Unknown
00F610  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F610  1               ;*		   R. K. Nordin	11/01/83
00F610  1               
00F610  1               
00F610  1               SDA	=	*	;entry
00F610  1  85 7D        	STA	INSDAT	;set data
00F612  1               ;	JMP	ACC	;advance cursor column, return
00F612  1               ;	SPACE	4,10
00F612  1               ;**	ACC - Advance Cursor Column
00F612  1               ;*
00F612  1               ;*	ENTRY	JSR	ACC
00F612  1               ;*
00F612  1               ;*	MODS
00F612  1               ;*		Original Author Unknown
00F612  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F612  1               ;*		   R. K. Nordin	11/01/83
00F612  1               
00F612  1               
00F612  1               ACC	=	*		;entry
00F612  1  E6 63        	INC	LOGCOL		;increment logical column
00F614  1  E6 55        	INC	COLCRS		;increment low cursor colum:
00F616  1  D0 02        	BNE	ACC1		;if no carry
00F618  1               
00F618  1  E6 56        	INC	COLCRS+1	;adjust high cursor column
00F61A  1               
00F61A  1  A5 55        ACC1	LDA	COLCRS		;low cursor column
00F61C  1  A6 57        	LDX	DINDEX		;mode
00F61E  1  DD 7D EE     	CMP	TMCC,X
00F621  1  F0 0A        	BEQ	ACC2		;if equal, process EOL
00F623  1               
00F623  1  E0 00        	CPX	#0
00F625  1  D0 E2        	BNE	CCA6		;if not mode 0, exit
00F627  1               
00F627  1  C5 53        	CMP	RMARGN		;right margin
00F629  1  F0 DE        	BEQ	CCA6		;if at right margin, exit
00F62B  1               
00F62B  1  90 DC        	BCC	CCA6		;if before right margin, ex:
00F62D  1               
00F62D  1  E0 08        ACC2	CPX	#8
00F62F  1  D0 04        	BNE	ACC3		;if not mode 8
00F631  1               
00F631  1  A5 56        	LDA	COLCRS+1	;high cursor column
00F633  1  F0 D4        	BEQ	CCA6		;if only at 64
00F635  1               
00F635  1  A5 57        ACC3	LDA	DINDEX		;mode
00F637  1  D0 2C        	BNE	RET		;if mode 0, exit
00F639  1               
00F639  1  A5 63        	LDA	LOGCOL		;logical column
00F63B  1  C9 51        	CMP	#81
00F63D  1  90 0A        	BCC	ACC4		;if < 81, definitely not li:
00F63F  1               
00F63F  1  A5 7D        	LDA	INSDAT
00F641  1  F0 22        	BEQ	RET		;if non-zero, do not do log:
00F643  1               
00F643  1  20 61 F6     	JSR	RWS		;return with scrolling
00F646  1  4C AB F6     	JMP	RET5		;return
00F649  1               
00F649  1  20 65 F6     ACC4	JSR	RET		;return
00F64C  1  A5 54        	LDA	ROWCRS		;cursor row
00F64E  1  18           	CLC
00F64F  1  69 78        	ADC	#8*(LOGMAP-TABMAP)	;add offset for log:
00F651  1  20 5D F7     	JSR	BMG		;ger bit from bit map
00F654  1  90 08        	BCC	ACC5
00F656  1               
00F656  1  A5 7D        	LDA	INSDAT
00F658  1  F0 04        	BEQ	ACC5		;if zero, do not extend
00F65A  1               
00F65A  1  18           	CLC
00F65B  1  20 0D F5     	JSR	ILN1		;insert line
00F65E  1               
00F65E  1  4C 8E F8     ACC5	JMP	SLC		;set logical column, return
00F661  1               ;	SPACE	4,10
00F661  1               ;**	RWS - Return with Scrolling
00F661  1               ;*
00F661  1               ;*	ENTRY	JSR	RWS
00F661  1               ;*
00F661  1               ;*	MODS
00F661  1               ;*		Original Author Unknown
00F661  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F661  1               ;*		   R. K. Nordin	11/01/83
00F661  1               
00F661  1               
00F661  1               RWS	=	*	;entry
00F661  1  A9 9B        	LDA	#EOL	;select scrolling
00F663  1  85 7D        	STA	INSDAT
00F665  1               ;	JMP	RET	;return, return .
00F665  1               ;	SPACE	4,10
00F665  1               ;**	RET - Return
00F665  1               ;*
00F665  1               ;*	ENTRY	JSR	RET
00F665  1               ;*
00F665  1               ;*	MODS
00F665  1               ;*		Original Author Unknown
00F665  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F665  1               ;*		   R. K. Nordin	11/01/83
00F665  1               
00F665  1               
00F665  1               RET	=	*		;entry
00F665  1  20 97 F9     	JSR	SCL		;set cursor at left edge
00F668  1  A9 00        	LDA	#0
00F66A  1  85 56        	STA	COLCRS+1	;high cursor column
00F66C  1  E6 54        	INC	ROWCRS		;increment cursor row
00F66E  1  A6 57        	LDX	DINDEX
00F670  1  A0 18        	LDY	#24		;assume 24 lines
00F672  1  24 7B        	BIT	SWPFLG
00F674  1  10 05        	BPL	RET1		;if normal
00F676  1               
00F676  1  A0 04        	LDY	#4		;substitute 4 lines
00F678  1  98           	TYA
00F679  1  D0 03        	BNE	RET2
00F67B  1               
00F67B  1  BD 8D EE     RET1	LDA	TMRC,X	;mode row count
00F67E  1               
00F67E  1  C5 54        RET2	CMP	ROWCRS	;cursor row
00F680  1  D0 29        	BNE	RET5
00F682  1               
00F682  1  8C 9D 02     	STY	HOLD3
00F685  1  8A           	TXA		;mode
00F686  1  D0 23        	BNE	RET5	;if mode not 0, do not scroll
00F688  1               
00F688  1  A5 7D        	LDA	INSDAT
00F68A  1  F0 1F        	BEQ	RET5	;if zero, do not scroll
00F68C  1               
00F68C  1               ;	If EOL, roll in a 0.
00F68C  1               
00F68C  1  C9 9B        	CMP	#EOL	;to extend bottom logical line
00F68E  1  F0 01        	BEQ	RET3	;if EOL
00F690  1               
00F690  1  18           	CLC
00F691  1               
00F691  1  20 F7 F7     RET3	JSR	SCR
00F694  1  EE BB 02     	INC	SCRFLG
00F697  1  C6 6C        	DEC	BUFSTR
00F699  1  10 02        	BPL	RET4
00F69B  1               
00F69B  1  E6 6C        	INC	BUFSTR
00F69D  1               
00F69D  1  CE 9D 02     RET4	DEC	HOLD3
00F6A0  1  AD B2 02     	LDA	LOGMAP
00F6A3  1  38           	SEC		;indicate for partial line
00F6A4  1  10 EB        	BPL	RET3	;if partial logical line
00F6A6  1               
00F6A6  1  AD 9D 02     	LDA	HOLD3
00F6A9  1  85 54        	STA	ROWCRS	;cursor row
00F6AB  1               
00F6AB  1  4C 8E F8     RET5	JMP	SLC	;set logical column, return
00F6AE  1               ;	SPACE	4,10
00F6AE  1               ;**	SEP - Subtract End Point
00F6AE  1               ;*
00F6AE  1               ;*	ENTRY	JSR	SEP
00F6AE  1               ;*		X = 0, if row or 2, if column
00F6AE  1               ;*
00F6AE  1               ;*	MODS
00F6AE  1               ;*		Original Author Unknown
00F6AE  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F6AE  1               ;*		   R. K. Nordin	11/01/83
00F6AE  1               
00F6AE  1               
00F6AE  1               SEP	=	*		;entry
00F6AE  1  38           	SEC
00F6AF  1  B5 70        	LDA	ROWAC,X		;low value from which to su:
00F6B1  1  E5 74        	SBC	ENDPT
00F6B3  1  95 70        	STA	ROWAC,X		;new low value
00F6B5  1  B5 71        	LDA	ROWAC+1,X	;hogh value from which to s:
00F6B7  1  E5 75        	SBC	ENDPT+1
00F6B9  1  95 71        	STA	ROWAC+1,X	;new high value
00F6BB  1  60           	RTS			;return
00F6BC  1               ;	SPACE	4,10
00F6BC  1               ;**	CRE - Check Cursor Range for Editor
00F6BC  1               ;*
00F6BC  1               ;*	ENTRY	JSR	SEP
00F6BC  1               ;*
00F6BC  1               ;*	MODS
00F6BC  1               ;*		Original Author Unknown
00F6BC  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F6BC  1               ;*		   R. K. Nordin	11/01/83
00F6BC  1               
00F6BC  1               
00F6BC  1               CRE	=	*	;entry
00F6BC  1               
00F6BC  1               ;	Check for mixed mode.
00F6BC  1               
00F6BC  1  AD BF 02     	LDA	BOTSCR
00F6BF  1  C9 04        	CMP	#4	;mixed mode indicator
00F6C1  1  F0 07        	BEQ	CCR	;if mixed mode, check cursor range,:
00F6C3  1               
00F6C3  1               ;	Check for mode 0.
00F6C3  1               
00F6C3  1  A5 57        	LDA	DINDEX	;mode
00F6C5  1  F0 03        	BEQ	CCR	;if mode 0, check ursor usage
00F6C7  1               
00F6C7  1               ;	Open editor.
00F6C7  1               
00F6C7  1  20 94 EF     	JSR	EOP	;perform editor OPEN
00F6CA  1               ;	JMP	CCR	;check cursor range, return
00F6CA  1               ;	SPACE	4,10
00F6CA  1               ;**	CCR - Check Cursor Range
00F6CA  1               ;*
00F6CA  1               ;*	ENTRY	JSR	CCR
00F6CA  1               ;*
00F6CA  1               ;*	MODS
00F6CA  1               ;*		Original Author Unknown
00F6CA  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F6CA  1               ;*		   R. K. Nordin	11/01/83
00F6CA  1               
00F6CA  1               
00F6CA  1               CCR	=	*		;entry
00F6CA  1  A9 27        	LDA	#39
00F6CC  1  C5 53        	CMP	RMARGN		;right margin
00F6CE  1  B0 02        	BCS	CCR1		;if 39 >= right margin
00F6D0  1               
00F6D0  1  85 53        	STA	RMARGN		;set right margin
00F6D2  1               
00F6D2  1  A6 57        CCR1	LDX	DINDEX
00F6D4  1  BD 8D EE     	LDA	TMRC,X		;mode row count
00F6D7  1  C5 54        	CMP	ROWCRS		;cursor row
00F6D9  1  90 2A        	BCC	CCR5		;if count > row position, e:
00F6DB  1               
00F6DB  1  F0 28        	BEQ	CCR5		;if count = row position, e:
00F6DD  1               
00F6DD  1  E0 08        	CPX	#8
00F6DF  1  D0 0A        	BNE	CCR2		;if not mode 8
00F6E1  1               
00F6E1  1  A5 56        	LDA	COLCRS+1	;high cursor column
00F6E3  1  F0 13        	BEQ	CCR4		;if high cursor column zero
00F6E5  1               
00F6E5  1  C9 01        	CMP	#1
00F6E7  1  D0 1C        	BNE	CCR5		;if >1, bad
00F6E9  1               
00F6E9  1  F0 04        	BEQ	CCR3		;if 1, check low
00F6EB  1               
00F6EB  1  A5 56        CCR2	LDA	COLCRS+1	;high cursor column
00F6ED  1  D0 16        	BNE	CCR5		;if high cursor column non-:
00F6EF  1               
00F6EF  1  BD 7D EE     CCR3	LDA	TMCC,X		;mode column count
00F6F2  1  C5 55        	CMP	COLCRS		;low cursor column
00F6F4  1  90 0F        	BCC	CCR5		;if count > column position:
00F6F6  1               
00F6F6  1  F0 0D        	BEQ	CCR5		;if count = column position:
00F6F8  1               
00F6F8  1  A9 01        CCR4	LDA	#SUCCES		;success indicator
00F6FA  1  85 4C        	STA	DSTAT		;indicate success
00F6FC  1  A9 80        	LDA	#BRKABT		;assume BREAK abort
00F6FE  1  A6 11        	LDX	BRKKEY		;BREAK key status
00F700  1  85 11        	STA	BRKKEY		;clear BREAK key status
00F702  1  F0 06        	BEQ	CCR6		;if BREAK
00F704  1               
00F704  1  60           	RTS			;return
00F705  1               
00F705  1               ;	Process range error.
00F705  1               
00F705  1  20 40 F4     CCR5	JSR	CHM		;move cursor home
00F708  1  A9 8D        	LDA	#CRSROR		;indicate cursor overrange
00F70A  1               
00F70A  1               ;	Exit.
00F70A  1               
00F70A  1  85 4C        CCR6	STA	DSTAT		;status
00F70C  1  68           	PLA			;clean stack for return to :
00F70D  1  68           	PLA
00F70E  1  A5 7B        	LDA	SWPFLG
00F710  1  10 03        	BPL	CCR7		;if not swapped
00F712  1               
00F712  1  4C 62 F9     	JMP	SWA		;swap, return
00F715  1               
00F715  1  4C 1E F2     CCR7	JMP	SST		;return (to CIO)
00F718  1               ;	SPACE	4,10
00F718  1               ;**	ROD - Restore Old Data under Cursor
00F718  1               ;*
00F718  1               ;*	ENTRY	JSR	ROD
00F718  1               ;*
00F718  1               ;*	MODS
00F718  1               ;*		Original Author Unknown
00F718  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F718  1               ;*		   R. K. Nordin	11/01/83
00F718  1               
00F718  1               
00F718  1               ROD	=	*		;entry
00F718  1  A0 00        	LDY	#0
00F71A  1  A5 5F        	LDA	OLDADR+1
00F71C  1  F0 04        	BEQ	ROD1		;if page zero
00F71E  1               
00F71E  1  A5 5D        	LDA	OLDCHR		;old data
00F720  1  91 5E        	STA	(OLDADR),Y
00F722  1               
00F722  1  60           ROD1	RTS			;return
00F723  1               ;	SPACE	4,10
00F723  1               ;**	BMI - Initialize for Bit Map Operation
00F723  1               ;*
00F723  1               ;*	BMI sets the bit mask in BITMSK and byte offset in :
00F723  1               ;*
00F723  1               ;*	ENTRY	JSR	BMI
00F723  1               ;*
00F723  1               ;*	MODS
00F723  1               ;*		Original Author Unknown
00F723  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F723  1               ;*		   R. K. Nordin	11/01/83
00F723  1               
00F723  1               
00F723  1               BMI_	=	*	;entry
00F723  1  48           	PHA		;save logical column
00F724  1  29 07        	AND	#7	;logical column modulo 8
00F726  1  AA           	TAX		;offset to bit mask
00F727  1  BD B4 EE     	LDA	TBTM,X	;bit mask
00F72A  1  85 6E        	STA	BITMSK	;set bit mask
00F72C  1  68           	PLA		;logical column
00F72D  1  4A           	LSR	A
00F72E  1  4A           	LSR	A
00F72F  1  4A           	LSR	A	;logical column divided by 8
00F730  1  AA           	TAX		;offset
00F731  1  60           	RTS		;return
00F732  1               ;	SPACE	4,10
00F732  1               ;**	BLR - Rotate Logical Line Bit Map Left
00F732  1               ;*
00F732  1               ;*	BLR rotates the logical line bit map left, scrollin:
00F732  1               ;*	logical lines up.
00F732  1               ;*
00F732  1               ;*	ENTRY	JSR	BLR
00F732  1               ;*
00F732  1               ;*	MODS
00F732  1               ;*		Original Author Unknown
00F732  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F732  1               ;*		   R. K. Nordin	11/01/83
00F732  1               
00F732  1               
00F732  1               BLR	=	*		;entry
00F732  1  2E B4 02     	ROL	LOGMAP+2
00F735  1  2E B3 02     	ROL	LOGMAP+1
00F738  1  2E B2 02     	ROL	LOGMAP
00F73B  1  60           	RTS			;return
00F73C  1               ;	SPACE	4,10
00F73C  1               ;**	BMP - Put Bit in Bit Map
00F73C  1               ;*
00F73C  1               ;*	PUT CARRY INTO BITMAP
00F73C  1               ;*
00F73C  1               ;*	ENTRY	JSR	BMP
00F73C  1               ;*
00F73C  1               ;*	MODS
00F73C  1               ;*		Original Author Unknown
00F73C  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F73C  1               ;*		   R. K. Nordin	11/01/83
00F73C  1               
00F73C  1               
00F73C  1               BMP	=	*	;entry
00F73C  1  90 0C        	BCC	BMC	;if C clear, clear bit in bit map,:
00F73E  1               
00F73E  1               ;	JMP	BMS	;set bit in bit map, return
00F73E  1               ;	SPACE	4,10
00F73E  1               ;**	BMS - Set Bit in Bit Map
00F73E  1               ;*
00F73E  1               ;*	ENTRY	JSR	BMS
00F73E  1               ;*
00F73E  1               ;*	MODS
00F73E  1               ;*		Original Author Unknown
00F73E  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F73E  1               ;*		   R. K. Nordin	11/01/83
00F73E  1               
00F73E  1               
00F73E  1               BMS	=	*		;entry
00F73E  1  20 23 F7     	JSR	BMI_		;initialize for bit mask op:
00F741  1  BD A3 02     	LDA	TABMAP,X
00F744  1  05 6E        	ORA	BITMSK		;set bit
00F746  1  9D A3 02     	STA	TABMAP,X	;update bit map
00F749  1  60           	RTS			;return
00F74A  1               ;	SPACE	4,10
00F74A  1               ;**	BMC - Clear Bit in Bit Map
00F74A  1               ;*
00F74A  1               ;*	ENTRY	JSR	BMC
00F74A  1               ;*
00F74A  1               ;*	MODS
00F74A  1               ;*		Original Author Unknown
00F74A  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F74A  1               ;*		   R. K. Nordin	11/01/83
00F74A  1               
00F74A  1               
00F74A  1               BMC	=	*		;entry
00F74A  1  20 23 F7     	JSR	BMI_		;initialize for bit mask op:
00F74D  1  A5 6E        	LDA	BITMSK
00F74F  1  49 FF        	EOR	#$FF
00F751  1  3D A3 02     	AND	TABMAP,X	;clear bit
00F754  1  9D A3 02     	STA	TABMAP,X	;update bit map
00F757  1  60           	RTS			;return
00F758  1               ;	SPACE	4,10
00F758  1               ;**	BLG - Get Bit from Logical Line Bit Map
00F758  1               ;*
00F758  1               ;*	ENTRY	JSR	BLG
00F758  1               ;*
00F758  1               ;*	MODS
00F758  1               ;*		Original Author Unknown
00F758  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F758  1               ;*		   R. K. Nordin	11/01/83
00F758  1               
00F758  1               
00F758  1               BLG	=	*	;entry
00F758  1  A5 54        	LDA	ROWCRS	;cursor row
00F75A  1               ;	JMP	BLG1
00F75A  1               ;	SPACE	4,10
00F75A  1               ;**	BLG1 - Get Bit from Logical Line Bit Map
00F75A  1               ;*
00F75A  1               ;*	ENTRY	JSR	BLG1
00F75A  1               ;*
00F75A  1               ;*	MODS
00F75A  1               ;*		Original Author Unknown
00F75A  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F75A  1               ;*		   R. K. Nordin	11/01/83
00F75A  1               
00F75A  1               
00F75A  1               BLG1	=	*	;entry
00F75A  1  18           	CLC
00F75B  1               ;	JMP	BLG2
00F75B  1               ;	SPACE	4,10
00F75B  1               ;**	BLG2 - Get Bit from Logical Line Bit Map
00F75B  1               ;*
00F75B  1               ;*	ENTRY	JSR	BLG2
00F75B  1               ;*
00F75B  1               ;*	MODS
00F75B  1               ;*		Original Author Unknown
00F75B  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F75B  1               ;*		   R. K. Nordin	11/01/83
00F75B  1               
00F75B  1               
00F75B  1               BLG2	=	*	;entry
00F75B  1  69 78        	ADC	#8*(LOGMAP-TABMAP)	;add offset for log:
00F75D  1               ;	JMP	BMG	;get bit from bit map, return
00F75D  1               ;	SPACE	4,10
00F75D  1               ;**	BMG - Get Bit from Bit Map
00F75D  1               ;*
00F75D  1               ;*	ENTRY	JSR	BMG
00F75D  1               ;*
00F75D  1               ;*	MODS
00F75D  1               ;*		Original Author Unknown
00F75D  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F75D  1               ;*		   R. K. Nordin	11/01/83
00F75D  1               
00F75D  1               
00F75D  1               BMG	=	*	;entry
00F75D  1  20 23 F7     	JSR	BMI_	;initialize for bit mask operation
00F760  1  18           	CLC
00F761  1  BD A3 02     	LDA	TABMAP,X
00F764  1  25 6E        	AND	BITMSK
00F766  1  F0 01        	BEQ	BMG1
00F768  1               
00F768  1  38           	SEC
00F769  1               
00F769  1  60           BMG1	RTS		;return
00F76A  1               ;	SPACE	4,10
00F76A  1               ;**	CIA - Convert Internal Character to ATASCII
00F76A  1               ;*
00F76A  1               ;*	ENTRY	JSR	CIA
00F76A  1               ;*
00F76A  1               ;*	MODS
00F76A  1               ;*		Original Author Unknown
00F76A  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F76A  1               ;*		   R. K. Nordin	11/01/83
00F76A  1               
00F76A  1               
00F76A  1               CIA	=	*	;entry
00F76A  1               
00F76A  1               ;	Initialize.
00F76A  1               
00F76A  1  AD FA 02     	LDA	CHAR
00F76D  1               
00F76D  1               ;	Check mode.
00F76D  1               
00F76D  1  A4 57        	LDY	DINDEX	;mode
00F76F  1  C0 0E        	CPY	#14
00F771  1  B0 17        	BCS	CIA2	;if mode >= 14
00F773  1               
00F773  1  C0 0C        	CPY	#12
00F775  1  B0 04        	BCS	CIA1	;if mode 12 or 13
00F777  1               
00F777  1  C0 03        	CPY	#3
00F779  1  B0 0F        	BCS	CIA2	;if mode >= 3
00F77B  1               
00F77B  1               ;	Convert internal character to ATASCII.
00F77B  1               
00F77B  1  2A           CIA1	ROL	A
00F77C  1  2A           	ROL	A
00F77D  1  2A           	ROL	A
00F77E  1  2A           	ROL	A
00F77F  1  29 03        	AND	#3
00F781  1  AA           	TAX
00F782  1  AD FA 02     	LDA	CHAR	;character
00F785  1  29 9F        	AND	#$9F	;strip off cloumn address
00F787  1  1D 4D FB     	ORA	TIAC,X	;or in new column address
00F78A  1               
00F78A  1               ;	Exit.
00F78A  1               
00F78A  1  8D FB 02     CIA2	STA	ATACHR	;ATASCII character
00F78D  1               
00F78D  1  60           CIA3	RTS		;return
00F78E  1               ;	SPACE	4,10
00F78E  1               ;**	MLN - Move Line
00F78E  1               ;*
00F78E  1               ;*	ENTRY	JSR	MLN
00F78E  1               ;*
00F78E  1               ;*	MODS
00F78E  1               ;*		Original Author Unknown
00F78E  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F78E  1               ;*		   R. K. Nordin	11/01/83
00F78E  1               
00F78E  1               
00F78E  1               MLN	=	*		;entry
00F78E  1               
00F78E  1               ; Initialize.
00F78E  1               
00F78E  1  A6 6A        	LDX	RAMTOP		;(high) RAM size
00F790  1  CA           	DEX			;decrement (high) RAM size
00F791  1  86 69        	STX	FRMADR+1	;high source address
00F793  1  86 67        	STX	TOADR+1		;high destination address
00F795  1  A9 B0        	LDA	#low ($0000-80)	;low RAM size - 80
00F797  1  85 68        	STA	FRMADR		;low source address
00F799  1  A9 D8        	LDA	#low ($0000-40)	;low RAM size - 40
00F79B  1  85 66        	STA	TOADR		;low destination address
00F79D  1               
00F79D  1  A6 54        	LDX	ROWCRS		;cursor row
00F79F  1               
00F79F  1               ;	Check for completion.
00F79F  1               
00F79F  1  E8           MLN1	INX
00F7A0  1  EC BF 02     	CPX	BOTSCR		;screen bottom
00F7A3  1  F0 E8        	BEQ	CIA3		;if done, return
00F7A5  1               
00F7A5  1               ;	Move line.
00F7A5  1               
00F7A5  1  A0 27        	LDY	#39		;offset to last byte
00F7A7  1               
00F7A7  1  B1 68        MLN2	LDA	(FRMADR),Y	;byte of source
00F7A9  1  91 66        	STA	(TOADR),Y	;byte of destination
00F7AB  1  88           	DEY
00F7AC  1  10 F9        	BPL	MLN2		;if not done
00F7AE  1               
00F7AE  1               ;	Adjust source and destination addresses.
00F7AE  1               
00F7AE  1  38           	SEC
00F7AF  1  A5 68        	LDA	FRMADR		;source address
00F7B1  1  85 66        	STA	TOADR		;update destination address
00F7B3  1  E9 28        	SBC	#low 40		;subtract 40
00F7B5  1  85 68        	STA	FRMADR		;update.source address
00F7B7  1  A5 69        	LDA	FRMADR+1
00F7B9  1  85 67        	STA	TOADR+1
00F7BB  1  E9 00        	SBC	#high 40
00F7BD  1  85 69        	STA	FRMADR+1
00F7BF  1               
00F7BF  1               ;	Continue.
00F7BF  1               
00F7BF  1  4C 9F F7     	JMP	MLN1		;continue
00F7C2  1               ;	SPACE	4,10
00F7C2  1               ;**	ELL - Extend Logical Line
00F7C2  1               ;*
00F7C2  1               ;*	ENTRY	JSR	ELL
00F7C2  1               ;*
00F7C2  1               ;*	MODS
00F7C2  1               ;*		Original Author Unknown
00F7C2  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F7C2  1               ;*		   R. K. Nordin	11/01/83
00F7C2  1               
00F7C2  1               
00F7C2  1               ELL	=	*	;entry
00F7C2  1  08           	PHP		;save bit
00F7C3  1  A0 16        	LDY	#22
00F7C5  1               
00F7C5  1  98           ELL1	TYA
00F7C6  1  20 5A F7     	JSR	BLG1
00F7C9  1  08           	PHP
00F7CA  1  98           	TYA
00F7CB  1  18           	CLC
00F7CC  1  69 79        	ADC	#8*(LOGMAP-TABMAP)+1	;add offset for log:
00F7CE  1  28           	PLP
00F7CF  1  20 3C F7     	JSR	BMP	;put bit in bit map
00F7D2  1  88           	DEY
00F7D3  1  30 04        	BMI	ELL2
00F7D5  1               
00F7D5  1  C4 54        	CPY	ROWCRS	;cursor row
00F7D7  1  B0 EC        	BCS	ELL1
00F7D9  1               
00F7D9  1  A5 54        ELL2	LDA	ROWCRS	;cursor row
00F7DB  1  18           	CLC
00F7DC  1  69 78        	ADC	#8*(LOGMAP-TABMAP)	;add offset for log:
00F7DE  1  28           	PLP
00F7DF  1  4C 3C F7     	JMP	BMP	;put bit in bit map, return
00F7E2  1               ;	SPACE	4,10
00F7E2  1               ;**	CLN - Clear Line
00F7E2  1               ;*
00F7E2  1               ;*	ENTRY	JSR	CLN
00F7E2  1               ;*
00F7E2  1               ;*	MODS
00F7E2  1               ;*		Original Author Unknown
00F7E2  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F7E2  1               ;*		   R. K. Nordin	11/01/83
00F7E2  1               
00F7E2  1               
00F7E2  1               CLN	=	*	;entry
00F7E2  1  A5 52        	LDA	LMARGN	;left margin
00F7E4  1  85 55        	STA	COLCRS	;low cursor column
00F7E6  1  20 AC F5     	JSR	CCA	;convert cursor row/column to addre:
00F7E9  1  38           	SEC
00F7EA  1  A5 53        	LDA	RMARGN	;right margin
00F7EC  1  E5 52        	SBC	LMARGN	;subtract left margin
00F7EE  1  A8           	TAY		;screen width
00F7EF  1  A9 00        	LDA	#0
00F7F1  1               
00F7F1  1  91 64        CLN1	STA	(ADRESS),Y
00F7F3  1  88           	DEY
00F7F4  1  10 FB        	BPL	CLN1	;if not done
00F7F6  1               
00F7F6  1  60           	RTS		;return
00F7F7  1               ;	SPACE	4,10
00F7F7  1               ;**	SCR - Scroll
00F7F7  1               ;*
00F7F7  1               ;*	ENTRY	JSR	SCR
00F7F7  1               ;*
00F7F7  1               ;*	MODS
00F7F7  1               ;*		Original Author Unknown
00F7F7  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F7F7  1               ;*		   R. K. Nordin	11/01/83
00F7F7  1               
00F7F7  1               
00F7F7  1               SCR	=	*	;entry
00F7F7  1               
00F7F7  1               ;	Initialize.
00F7F7  1               
00F7F7  1  20 32 F7     	JSR	BLR	;rotate logical line bit map left
00F7FA  1               
00F7FA  1               ;	Check for fine scrolling.
00F7FA  1               
00F7FA  1  AD 6E 02     	LDA	FINE
00F7FD  1  F0 28        	BEQ	SCR5	;if not fine scrolling
00F7FF  1               
00F7FF  1  AD 6C 02     SCR1	LDA	VSFLAG	;vertical scroll count
00F802  1  D0 FB        	BNE	SCR1	;if prior scroll not yet done
00F804  1               
00F804  1  A9 08        	LDA	#8
00F806  1  8D 6C 02     	STA	VSFLAG	;vertical scroll count
00F809  1               
00F809  1               ;	Wait forscroll to complete.
00F809  1               
00F809  1  AD 6C 02     SCR2	LDA	VSFLAG	;vertical scroll count
00F80C  1  C9 01        	CMP	#1	;start of last scan
00F80E  1  D0 F9        	BNE	SCR2	;if not done waiting
00F810  1               
00F810  1  AD 0B D4     SCR3	LDA	VCOUNT
00F813  1  C9 40        	CMP	#$40
00F815  1  B0 F9        	BCS	SCR3	;if not done waiting for safe place
00F817  1               
00F817  1  A2 0D        	LDX	#$0D
00F819  1  AD BF 02     	LDA	BOTSCR
00F81C  1  C9 04        	CMP	#4
00F81E  1  D0 02        	BNE	SCR4	;if not split screen
00F820  1               
00F820  1  A2 70        	LDX	#$70
00F822  1               
00F822  1  EC 0B D4     SCR4	CPX	VCOUNT
00F825  1  B0 FB        	BCS	SCR4	;if not done waiting
00F827  1               
00F827  1               ;	Exit.
00F827  1               
00F827  1  20 A6 F9     SCR5	JSR	SMS	;set memory scan counter address
00F82A  1               ;	JMP	SSD	;scroll screen for delete, return
00F82A  1               ;	SPACE	4,10
00F82A  1               ;**	SSD - Scroll Screen for Delete
00F82A  1               ;*
00F82A  1               ;*	ENTRY	JSR	SSD
00F82A  1               ;*
00F82A  1               ;*	MODS
00F82A  1               ;*		Original Author Unknown
00F82A  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F82A  1               ;*		   R. K. Nordin	11/01/83
00F82A  1               
00F82A  1               
00F82A  1               SSD	=	*		;entry
00F82A  1               
00F82A  1               ;	Initialize
00F82A  1               
00F82A  1  A5 64        	LDA	ADRESS		;address
00F82C  1  A6 65        	LDX	ADRESS+1
00F82E  1               
00F82E  1               ;	Calculate number of bytes to move.
00F82E  1               
00F82E  1  E8           SSD1	INX
00F82F  1  E4 6A        	CPX	RAMTOP
00F831  1  F0 06        	BEQ	SSD2		;if at RAMTOP
00F833  1               
00F833  1  38           	SEC
00F834  1  E9 10        	SBC	#$10
00F836  1  4C 2E F8     	JMP	SSD1		;continue
00F839  1               
00F839  1  69 27        SSD2	ADC	#39		;(CLC and ADC #40)
00F83B  1  D0 0A        	BNE	SSD3		;if byte count non-zero
00F83D  1               
00F83D  1  A6 65        	LDX	ADRESS+1
00F83F  1  E8           	INX
00F840  1  E4 6A        	CPX	RAMTOP
00F842  1  F0 38        	BEQ	SSD6		;if at RAMTOP
00F844  1               
00F844  1  18           	CLC
00F845  1  69 10        	ADC	#$10
00F847  1               
00F847  1               ;	Adjust address.
00F847  1               
00F847  1  A8           SSD3	TAY			;number of bytes
00F848  1  85 7E        	STA	COUNTR
00F84A  1  38           	SEC
00F84B  1  A5 64        	LDA	ADRESS
00F84D  1  E5 7E        	SBC	COUNTR		;subtract
00F84F  1  85 64        	STA	ADRESS		;update low address
00F851  1  B0 02        	BCS	SSD4		;if no borrow
00F853  1               
00F853  1  C6 65        	DEC	ADRESS+1	;adjust high address
00F855  1               
00F855  1               ;	Move data down.
00F855  1               
00F855  1  A5 64        SSD4	LDA	ADRESS
00F857  1  18           	CLC
00F858  1  69 28        	ADC	#40
00F85A  1  85 7E        	STA	COUNTR		;address + 40
00F85C  1  A5 65        	LDA	ADRESS+1
00F85E  1  69 00        	ADC	#0
00F860  1  85 7F        	STA	COUNTR+1
00F862  1               
00F862  1  B1 7E        SSD5	LDA	(COUNTR),Y	;byte to move
00F864  1  91 64        	STA	(ADRESS),Y	;move byte
00F866  1  C8           	INY
00F867  1  D0 F9        	BNE	SSD5		;if not done (256-=16 times)
00F869  1               
00F869  1  A0 10        	LDY	#256-240
00F86B  1  A5 64        	LDA	ADRESS
00F86D  1  C9 D8        	CMP	#<-40
00F86F  1  F0 0B        	BEQ	SSD6		;if all done
00F871  1               
00F871  1  18           	CLC
00F872  1  69 F0        	ADC	#240
00F874  1  85 64        	STA	ADRESS		;update low address
00F876  1  90 DD        	BCC	SSD4		;if no carry
00F878  1               
00F878  1  E6 65        	INC	ADRESS+1	;adjust high address
00F87A  1  D0 D9        	BNE	SSD4		;continue
00F87C  1               
00F87C  1               ;	Clear last line.
00F87C  1               
00F87C  1  A6 6A        SSD6	LDX	RAMTOP
00F87E  1  CA           	DEX
00F87F  1  86 7F        	STX	COUNTR+1
00F881  1  A2 D8        	LDX	#<-40
00F883  1  86 7E        	STX	COUNTR
00F885  1  A9 00        	LDA	#0
00F887  1  A0 27        	LDY	#39
00F889  1               
00F889  1  91 7E        SSD7	STA	(COUNTR),Y	;clear byte of last line
00F88B  1  88           	DEY
00F88C  1  10 FB        	BPL	SSD7		;if not done
00F88E  1               
00F88E  1               ;	JMP	SLC		;set logical column, return
00F88E  1               ;	SPACE	4,10
00F88E  1               ;**	SLC - Set Logical Column
00F88E  1               ;*
00F88E  1               ;*	ENTRY	JSR	SLC
00F88E  1               ;*
00F88E  1               ;*	MODS
00F88E  1               ;*		Original Author Unknown
00F88E  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F88E  1               ;*		   R. K. Nordin	11/01/83
00F88E  1               
00F88E  1               
00F88E  1               SLC	=	*	;entry
00F88E  1               
00F88E  1               ;	Initialize.
00F88E  1               
00F88E  1  A9 00        	LDA	#0
00F890  1  85 63        	STA	LOGCOL	;initialize logical column
00F892  1  A5 54        	LDA	ROWCRS	;cursor row
00F894  1  85 51        	STA	HOLD1	;working row
00F896  1               
00F896  1               ;	Search for beginning of line.
00F896  1               
00F896  1  A5 51        SLC1	LDA	HOLD1	;add in row component
00F898  1  20 5A F7     	JSR	BLG1
00F89B  1  B0 0C        	BCS	SLC2	;if beginning of line found
00F89D  1               
00F89D  1  A5 63        	LDA	LOGCOL	;logical column
00F89F  1  18           	CLC
00F8A0  1  69 28        	ADC	#40	;add number of characters per line
00F8A2  1  85 63        	STA	LOGCOL	;update logical column
00F8A4  1  C6 51        	DEC	HOLD1	;decrement working row
00F8A6  1  4C 96 F8     	JMP	SLC1	;continue
00F8A9  1               
00F8A9  1               ;	Add in cursor column.
00F8A9  1               
00F8A9  1  18           SLC2	CLC
00F8AA  1  A5 63        	LDA	LOGCOL	;logical column
00F8AC  1  65 55        	ADC	COLCRS	;add low cursor column
00F8AE  1  85 63        	STA	LOGCOL	;update logical column
00F8B0  1  60           	RTS		;return
00F8B1  1               ;	SPACE	4,10
00F8B1  1               ;**	CBC - Compute Buffer Count
00F8B1  1               ;*
00F8B1  1               ;*	CBC computes the buffer count as the number of byte:
00F8B1  1               ;*	buffer start to the end of the logical line (with t:
00F8B1  1               ;*	spaces removed).
00F8B1  1               ;*
00F8B1  1               ;*	ENTRY	JSR	CBC
00F8B1  1               ;*
00F8B1  1               ;*	MODS
00F8B1  1               ;*		Original Author Unknown
00F8B1  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F8B1  1               ;*		   R. K. Nordin	11/01/83
00F8B1  1               
00F8B1  1               
00F8B1  1               CBC	=	*	;entry
00F8B1  1               
00F8B1  1               ;	Initialize.
00F8B1  1               
00F8B1  1  20 4C F9     	JSR	SRC		;save row and column
00F8B4  1  A5 63        	LDA	LOGCOL		;logical column
00F8B6  1  48           	PHA			;save logical column
00F8B7  1  A5 6C        	LDA	BUFSTR		;start of buffer
00F8B9  1  85 54        	STA	ROWCRS		;cursor row
00F8BB  1  A5 6D        	LDA	BUFSTR+1
00F8BD  1  85 55        	STA	COLCRS		;low cursor column
00F8BF  1  A9 01        	LDA	#1
00F8C1  1  85 6B        	STA	BUFCNT		;initialize buffer count
00F8C3  1               
00F8C3  1               ;	Determine last line on screen.
00F8C3  1               
00F8C3  1  A2 17        CBC1	LDX	#23		;normal last line on screen
00F8C5  1  A5 7B        	LDA	SWPFLG
00F8C7  1  10 02        	BPL	CBC2		;if not swapped
00F8C9  1               
00F8C9  1  A2 03        	LDX	#3		;last line on screen
00F8CB  1               
00F8CB  1               ;	Check for cursor on last line of screen.
00F8CB  1               
00F8CB  1  E4 54        CBC2	CPX	ROWCRS	;cursor row
00F8CD  1  D0 0B        	BNE	CBC3	;if cursor on last line
00F8CF  1               
00F8CF  1  A5 55        	LDA	COLCRS	;low cursor column
00F8D1  1  C5 53        	CMP	RMARGN	;right margin
00F8D3  1  D0 05        	BNE	CBC3	;if not at right margin
00F8D5  1               
00F8D5  1  E6 6B        	INC	BUFCNT	;fake SEA to avoid scrolling
00F8D7  1  4C EA F8     	JMP	CBC4
00F8DA  1               
00F8DA  1  20 0A F6     CBC3	JSR	SZA	;set zero data and advance cursor
00F8DD  1  E6 6B        	INC	BUFCNT
00F8DF  1  A5 63        	LDA	LOGCOL	;logical column
00F8E1  1  C5 52        	CMP	LMARGN	;left margin
00F8E3  1  D0 DE        	BNE	CBC1	;if not yet at left margin
00F8E5  1               
00F8E5  1  C6 54        	DEC	ROWCRS	;decrement cursor row
00F8E7  1  20 00 F4     	JSR	CLF	;move cursor left
00F8EA  1               
00F8EA  1  20 8F F1     CBC4	JSR	GDC	;get data under cursor
00F8ED  1  D0 17        	BNE	CBC6	;if non-zero, quit
00F8EF  1               
00F8EF  1  C6 6B        	DEC	BUFCNT	;DECREMENT COUNTER
00F8F1  1  A5 63        	LDA	LOGCOL	;logical column
00F8F3  1  C5 52        	CMP	LMARGN	;left margin
00F8F5  1  F0 0F        	BEQ	CBC6	;if beginning of logical line, exit
00F8F7  1               
00F8F7  1  20 00 F4     	JSR	CLF	;move cursor left
00F8FA  1  A5 55        	LDA	COLCRS	;low cursor column
00F8FC  1  C5 53        	CMP	RMARGN	;right margin
00F8FE  1  D0 02        	BNE	CBC5	;if cursor column not right margin
00F900  1               
00F900  1  C6 54        	DEC	ROWCRS	;decrement cursor row
00F902  1               
00F902  1  A5 6B        CBC5	LDA	BUFCNT
00F904  1  D0 E4        	BNE	CBC4	;if BUFCNT non-zero, continue
00F906  1               
00F906  1  68           CBC6	PLA		;saved logical column
00F907  1  85 63        	STA	LOGCOL	;restore logical column
00F909  1  4C 57 F9     	JMP	RRC	;restore row and column, return
00F90C  1               ;	SPACE	4,10
00F90C  1               ;**	SBS - Set Bufer Start and Logical Column
00F90C  1               ;*
00F90C  1               ;*	ENTRY	JSR	SBS
00F90C  1               ;*
00F90C  1               ;*	MODS
00F90C  1               ;*		Original Author Unknown
00F90C  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F90C  1               ;*		   R. K. Nordin	11/01/83
00F90C  1               
00F90C  1               
00F90C  1               SBS	=	*		;entry
00F90C  1  20 8E F8     	JSR	SLC		;set logical column
00F90F  1  A5 51        	LDA	HOLD1
00F911  1  85 6C        	STA	BUFSTR
00F913  1  A5 52        	LDA	LMARGN		;left margin
00F915  1  85 6D        	STA	BUFSTR+1
00F917  1               
00F917  1  60           SBS1	RTS			;return
00F918  1               ;	SPACE	4,10
00F918  1               ;**	DQQ - Delete Line
00F918  1               ;*
00F918  1               ;*	ENTRY	JSR	DQQ
00F918  1               ;*
00F918  1               ;*	MODS
00F918  1               ;*		Original Author Unknown
00F918  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F918  1               ;*		   R. K. Nordin	11/01/83
00F918  1               
00F918  1               
00F918  1               DQQ	=	*	;entry
00F918  1  A5 63        	LDA	LOGCOL	;logical column
00F91A  1  C5 52        	CMP	LMARGN	;left margin
00F91C  1  D0 02        	BNE	DQQ1	;if not at left margin
00F91E  1               
00F91E  1  C6 54        	DEC	ROWCRS	;decrement cursor row
00F920  1  20 8E F8     DQQ1	JSR	SLC	;set logical column
00F923  1               ;	JMP	DWQ
00F923  1               ;	SPACE	4,10
00F923  1               ;**	DWQ - Delete Line
00F923  1               ;*
00F923  1               ;*	ENTRY	JSR	DWQ
00F923  1               ;*
00F923  1               ;*	MODS
00F923  1               ;*		Original Author Unknown
00F923  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F923  1               ;*		   R. K. Nordin	11/01/83
00F923  1               
00F923  1               
00F923  1               DWQ	=	*	;entry
00F923  1               
00F923  1               ;	Check for left margin.
00F923  1               
00F923  1  A5 63        	LDA	LOGCOL	;logical column
00F925  1  C5 52        	CMP	LMARGN	;left margin
00F927  1  F0 EE        	BEQ	SBS1	;if at left margin, return
00F929  1               
00F929  1  20 AC F5     	JSR	CCA	;convert cursor row/column to addre:
00F92C  1  A5 53        	LDA	RMARGN	;right margin
00F92E  1  38           	SEC
00F92F  1  E5 52        	SBC	LMARGN	;subtract left margin
00F931  1  A8           	TAY		;offset to last byte
00F932  1               
00F932  1  B1 64        DWQ1	LDA	(ADRESS),Y
00F934  1  D0 E1        	BNE	SBS1
00F936  1               
00F936  1  88           	DEY
00F937  1  10 F9        	BPL	DWQ1	;if not done
00F939  1               
00F939  1  4C 27 F5     	JMP	DLN1	;delete line, return
00F93C  1               ;	SPACE	4,10
00F93C  1               ;**	CCC - Check for Control Character
00F93C  1               ;*
00F93C  1               ;*	ENTRY	JSR	CCC
00F93C  1               ;*
00F93C  1               ;*	MODS
00F93C  1               ;*		Original Author Unknown
00F93C  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F93C  1               ;*		   R. K. Nordin	11/01/83
00F93C  1               
00F93C  1               
00F93C  1               CCC	=	*	;entry
00F93C  1               
00F93C  1  A2 2D        	LDX	#TCCRL-3	;offset to last entry
00F93E  1               
00F93E  1  BD 0D FB     CCC1	LDA	TCCR,X		;control character
00F941  1  CD FB 02     	CMP	ATACHR		;ATASCII character
00F944  1  F0 05        	BEQ	CCC2		;if character found, exit
00F946  1               
00F946  1  CA           	DEX
00F947  1  CA           	DEX
00F948  1  CA           	DEX
00F949  1  10 F3        	BPL	CCC1		;if not done, continue sear:
00F94B  1               
00F94B  1  60           CCC2	RTS			;return
00F94C  1               ;	SPACE	4,10
00F94C  1               ;**	SRC - Save Row and Column
00F94C  1               ;*
00F94C  1               ;*	ENTRY	JSR	SRC
00F94C  1               ;*
00F94C  1               ;*	MODS
00F94C  1               ;*		Original Author Unknown
00F94C  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F94C  1               ;*		   R. K. Nordin	11/01/83
00F94C  1               
00F94C  1               
00F94C  1               SRC	=	*		;entry
00F94C  1  A2 02        	LDX	#2		;offset to last byte
00F94E  1               
00F94E  1  B5 54        SRC1	LDA	ROWCRS,X	;byte of cursor row/column
00F950  1  9D B8 02     	STA	TMPROW,X	;save byte of cursor row/co:
00F953  1  CA           	DEX
00F954  1  10 F8        	BPL	SRC1		;if not done
00F956  1               
00F956  1  60           	RTS			;return
00F957  1               ;	SPACE	4,10
00F957  1               ;**	RRC - Restore Row and Column
00F957  1               ;*
00F957  1               ;*	ENTRY	JSR	RRC
00F957  1               ;*
00F957  1               ;*	MODS
00F957  1               ;*		Original Author Unknown
00F957  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F957  1               ;*		   R. K. Nordin	11/01/83
00F957  1               
00F957  1               
00F957  1               RRC	=	*		;entry
00F957  1  A2 02        	LDX	#2		;offset to last byte
00F959  1               
00F959  1  BD B8 02     RRC1	LDA	TMPROW,X	;byte of saved cursor row/c:
00F95C  1  95 54        	STA	ROWCRS,X	;byte of row/column
00F95E  1  CA           	DEX
00F95F  1  10 F8        	BPL	RRC1		;if not done
00F961  1               
00F961  1  60           	RTS			;return
00F962  1               ;	SPACE	4,10
00F962  1               ;**	SWA - Swap Cursor Position with Regular Cursor Posi:
00F962  1               ;*
00F962  1               ;*	ENTRY	JSR	SWA
00F962  1               ;*
00F962  1               ;*	MODS
00F962  1               ;*		Original Author Unknown
00F962  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F962  1               ;*		   R. K. Nordin	11/01/83
00F962  1               
00F962  1               
00F962  1               SWA	=	*		;entry
00F962  1               
00F962  1               ;	Check for split screen.
00F962  1               
00F962  1  AD BF 02     	LDA	BOTSCR		;screen bottom
00F965  1  C9 18        	CMP	#24		;normal indicator
00F967  1  F0 17        	BEQ	SWA2		;if not split screen
00F969  1               
00F969  1               ;	Swap cursor parameters.
00F969  1               
00F969  1  A2 0B        	LDX	#11		;offset to last byte
00F96B  1               
00F96B  1  B5 54        SWA1	LDA	ROWCRS,X	;destination cursor paramet:
00F96D  1  48           	PHA			;save cursor parameter
00F96E  1  BD 90 02     	LDA	TXTROW,X	;source cursor parameter
00F971  1  95 54        	STA	ROWCRS,X	;update destination cursor :
00F973  1  68           	PLA			;saved cursor parameter
00F974  1  9D 90 02     	STA	TXTROW,X	;update source cursor param:
00F977  1  CA           	DEX
00F978  1  10 F1        	BPL	SWA1		;if not done
00F97A  1               
00F97A  1               ;	Complement swap flag.
00F97A  1               
00F97A  1  A5 7B        	LDA	SWPFLG		;swap flag
00F97C  1  49 FF        	EOR	#$FF		;complement swap flag
00F97E  1  85 7B        	STA	SWPFLG		;update swap flag
00F980  1               
00F980  1               ;	Exit.
00F980  1               
00F980  1  4C 1E F2     SWA2	JMP	SST	;perform pscreen STATUS, return
00F983  1               ;	SPACE	4,10
00F983  1               ;**	SKC - Sound Key Click
00F983  1               ;*
00F983  1               ;*	ENTRY	JSR	SKC
00F983  1               ;*
00F983  1               ;*	MODS
00F983  1               ;*		Original Author Unknown
00F983  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F983  1               ;*		   R. K. Nordin	11/01/83
00F983  1               
00F983  1               
00F983  1               SKC	=	*	;entry
00F983  1               
00F983  1               ;	Initialize.
00F983  1               
00F983  1  A2 7E        	LDX	#2*63	;2 times trip count
00F985  1  48           	PHA		;save A
00F986  1               
00F986  1               ;	Turn loudspeaker on.
00F986  1               
00F986  1  8E 1F D0     SKC1	STX	CONSOL	;turn loudspeaker on
00F989  1               
00F989  1               ;	Wait for VBLANK (loudspeaker off).
00F989  1               
00F989  1  AD 0B D4     	LDA	VCOUNT	;vertical line counter
00F98C  1               
00F98C  1  CD 0B D4     SKC2	CMP	VCOUNT	;current vertical line counter
00F98F  1  F0 FB        	BEQ	SKC2	;if vertical line not changed
00F991  1               
00F991  1               ;	Decrement and check trip count.
00F991  1               
00F991  1  CA           	DEX
00F992  1  CA           	DEX
00F993  1  10 F1        	BPL	SKC1	;if not done
00F995  1               
00F995  1               ;	Exit.
00F995  1               
00F995  1  68           	PLA		;restore A
00F996  1  60           	RTS		;return
00F997  1               ;	SPACE	4,10
00F997  1               ;**	SCL - Set Cursor at Left Edge
00F997  1               ;*
00F997  1               ;*	ENTRY	JSR	SCL
00F997  1               ;*
00F997  1               ;*	MODS
00F997  1               ;*		Original Author Unknown
00F997  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F997  1               ;*		   R. K. Nordin	11/01/83
00F997  1               
00F997  1               
00F997  1               SCL	=	*	;entry
00F997  1               
00F997  1  A9 00        	LDA	#0	;assume 0
00F999  1               
00F999  1  A6 7B        	LDX	SWPFLG	;swap flag
00F99B  1  D0 04        	BNE	SCL1	;if not swapped
00F99D  1               
00F99D  1  A6 57        	LDX	DINDEX	;mode
00F99F  1  D0 02        	BNE	SCL2	;if not mode 0
00F9A1  1               
00F9A1  1  A5 52        SCL1	LDA	LMARGN	;use left margin instead of 0
00F9A3  1               
00F9A3  1  85 55        SCL2	STA	COLCRS	;set low cursor column
00F9A5  1  60           	RTS		;return
00F9A6  1               ;	SPACE	4,10
00F9A6  1               ;**	SMS - Set Memory Scan Counter Address
00F9A6  1               ;*
00F9A6  1               ;*	ENTRY	JSR	SMS
00F9A6  1               ;*
00F9A6  1               ;*	MODS
00F9A6  1               ;*		Original Author Unknown
00F9A6  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F9A6  1               ;*		   R. K. Nordin	11/01/83
00F9A6  1               
00F9A6  1               
00F9A6  1               SMS	=	*		;entry
00F9A6  1  A5 58        	LDA	SAVMSC		;saved low memory scan coun:
00F9A8  1  85 64        	STA	ADRESS		;saved low address
00F9AA  1  A5 59        	LDA	SAVMSC+1	;saved high memory scan cou:
00F9AC  1  85 65        	STA	ADRESS+1	;set high address
00F9AE  1  60           	RTS			;return
00F9AF  1               ;	SPACE	4,10
00F9AF  1               ;**	SSP - Perform Screen SPECIAL
00F9AF  1               ;*
00F9AF  1               ;*	SSP draws a line from OLDROW/OLDCOL to NEWROW/NEWCO:
00F9AF  1               ;*
00F9AF  1               ;*	ENTRY	JSR	SSP
00F9AF  1               ;*
00F9AF  1               ;*	MODS
00F9AF  1               ;*		A. Miller
00F9AF  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00F9AF  1               ;*		   R. K. Nordin	11/01/83
00F9AF  1               
00F9AF  1               
00F9AF  1               SSP	=	*		;entry
00F9AF  1               
00F9AF  1               ;	Determine command.
00F9AF  1               
00F9AF  1  A2 00        	LDX	#0		;assume no fill
00F9B1  1  A5 22        	LDA	ICCOMZ		;command
00F9B3  1  C9 11        	CMP	#$11		;DRAW command
00F9B5  1  F0 08        	BEQ	SSP2		;if DRAW command
00F9B7  1               
00F9B7  1  C9 12        	CMP	#$12		;FILL command
00F9B9  1  F0 03        	BEQ	SSP1		;if FILL command
00F9BB  1               
00F9BB  1  A0 84        	LDY	#NVALID		;invalid command error
00F9BD  1  60           	RTS			;return
00F9BE  1               
00F9BE  1  E8           SSP1	INX			;indicate fill
00F9BF  1               
00F9BF  1  8E B7 02     SSP2	STX	FILFLG		;right fill flag
00F9C2  1               
00F9C2  1               ;	Set destination row/column.
00F9C2  1               
00F9C2  1  A5 54        	LDA	ROWCRS		;cursor row
00F9C4  1  8D F5 02     	STA	NEWROW
00F9C7  1  A5 55        	LDA	COLCRS		;cursor column
00F9C9  1  8D F6 02     	STA	NEWCOL
00F9CC  1  A5 56        	LDA	COLCRS+1
00F9CE  1  8D F7 02     	STA	NEWCOL+1
00F9D1  1               
00F9D1  1               ;	Compute row increment and difference.
00F9D1  1               
00F9D1  1  A9 01        	LDA	#1		;assume increment +1
00F9D3  1  8D F8 02     	STA	ROWINC		;row increment
00F9D6  1  8D F9 02     	STA	COLINC		;column increment
00F9D9  1  38           	SEC
00F9DA  1  AD F5 02     	LDA	NEWROW		;destination row
00F9DD  1  E5 5A        	SBC	OLDROW		;subtract source row
00F9DF  1  85 76        	STA	DELTAR		;row difference
00F9E1  1  B0 0E        	BCS	SSP3		;if difference positive
00F9E3  1               
00F9E3  1               ;	Set row increment to -1 and complement row differen:
00F9E3  1               
00F9E3  1  A9 FF        	LDA	#$FF		;increment -1
00F9E5  1  8D F8 02     	STA	ROWINC		;update row increment
00F9E8  1  A5 76        	LDA	DELTAR		;row difference
00F9EA  1  49 FF        	EOR	#$FF
00F9EC  1  18           	CLC
00F9ED  1  69 01        	ADC	#1		;add 1 for 2's complement
00F9EF  1  85 76        	STA	DELTAR		;update row difference
00F9F1  1               
00F9F1  1               ;	Compute column increment and difference.
00F9F1  1               
00F9F1  1  38           SSP3	SEC
00F9F2  1  AD F6 02     	LDA	NEWCOL		;destination column
00F9F5  1  E5 5B        	SBC	OLDCOL		;source column
00F9F7  1  85 77        	STA	DELTAC		;column difference
00F9F9  1  AD F7 02     	LDA	NEWCOL+1
00F9FC  1  E5 5C        	SBC	OLDCOL+1
00F9FE  1  85 78        	STA	DELTAC+1
00FA00  1  B0 17        	BCS	SSP4		;if difference positive
00FA02  1               
00FA02  1               ;	Set column increment to -1 and complement column di:
00FA02  1               
00FA02  1  A9 FF        	LDA	#$FF		;increment -1
00FA04  1  8D F9 02     	STA	COLINC		;update column increment
00FA07  1  A5 77        	LDA	DELTAC		;column difference
00FA09  1  49 FF        	EOR	#$FF		;absolute value of column d:
00FA0B  1  85 77        	STA	DELTAC		;update column difference
00FA0D  1  A5 78        	LDA	DELTAC+1
00FA0F  1  49 FF        	EOR	#$FF
00FA11  1  85 78        	STA	DELTAC+1
00FA13  1  E6 77        	INC	DELTAC		;add 1 for 2's complement
00FA15  1  D0 02        	BNE	SSP4		;if no carry
00FA17  1               
00FA17  1  E6 78        	INC	DELTAC+1	;adjust for 2's complement
00FA19  1               
00FA19  1  A2 02        SSP4	LDX	#2		;offset to last byte
00FA1B  1  A0 00        	LDY	#0
00FA1D  1  84 73        	STY	COLAC+1		;zero high working column
00FA1F  1               
00FA1F  1  98           SSP5	TYA
00FA20  1  95 70        	STA	ROWAC,X		;zero byte of working row/c:
00FA22  1  B5 5A        	LDA	OLDROW,X	;byte of source row/column
00FA24  1  95 54        	STA	ROWCRS,X	;byte of cursor row/column
00FA26  1  CA           	DEX
00FA27  1  10 F6        	BPL	SSP5		;if not done
00FA29  1               
00FA29  1               ;	Determine difference.
00FA29  1               
00FA29  1  A5 77        	LDA	DELTAC		;low column difference
00FA2B  1  E8           	INX			;offset to working row
00FA2C  1  A8           	TAY			;low column difference
00FA2D  1  A5 78        	LDA	DELTAC+1	;high column difference
00FA2F  1  85 7F        	STA	COUNTR+1	;initialize high iteration :
00FA31  1  85 75        	STA	ENDPT+1		;initialize high end point
00FA33  1  D0 0B        	BNE	SSP6		;if high column difference :
00FA35  1               
00FA35  1  A5 77        	LDA	DELTAC		;low column difference
00FA37  1  C5 76        	CMP	DELTAR		;row difference
00FA39  1  B0 05        	BCS	SSP6		;if column difference > row:
00FA3B  1               
00FA3B  1  A5 76        	LDA	DELTAR		;row difference
00FA3D  1  A2 02        	LDX	#2		;offset to working column
00FA3F  1  A8           	TAY			;row difference
00FA40  1               
00FA40  1  98           SSP6	TYA			;low maximum difference
00FA41  1  85 7E        	STA	COUNTR		;low iteration counter
00FA43  1  85 74        	STA	ENDPT		;low end point
00FA45  1  48           	PHA			;save low end point
00FA46  1  A5 75        	LDA	ENDPT+1		;high end point
00FA48  1  4A           	LSR	A		;C = LSB of high end point
00FA49  1  68           	PLA			;saved low end point
00FA4A  1  6A           	ROR	A
00FA4B  1  95 70        	STA	ROWAC,X		;low working row or column
00FA4D  1               
00FA4D  1               ;	Check for iteration counter zero.
00FA4D  1               
00FA4D  1  A5 7E        SSP7	LDA	COUNTR		;low iteration counter
00FA4F  1  05 7F        	ORA	COUNTR+1	;or in high iteration count:
00FA51  1  D0 03        	BNE	SSP8		;if iteration counter is no:
00FA53  1               
00FA53  1  4C 01 FB     	JMP	SSP19		;exit
00FA56  1               
00FA56  1               ;	Update working row.
00FA56  1               
00FA56  1  18           SSP8	CLC
00FA57  1  A5 70        	LDA	ROWAC		;working row
00FA59  1  65 76        	ADC	DELTAR		;row difference
00FA5B  1  85 70        	STA	ROWAC		;update working row
00FA5D  1  90 02        	BCC	SSP9		;if no carry
00FA5F  1               
00FA5F  1  E6 71        	INC	ROWAC+1		;adjust high working row
00FA61  1               
00FA61  1  A5 71        SSP9	LDA	ROWAC+1		;high working row
00FA63  1  C5 75        	CMP	ENDPT+1		;high end point
00FA65  1  90 15        	BCC	SSP11		;if high working row < high:
00FA67  1               
00FA67  1  D0 06        	BNE	SSP10		;if high working row > high:
00FA69  1               
00FA69  1  A5 70        	LDA	ROWAC		;low working row
00FA6B  1  C5 74        	CMP	ENDPT		;low end point
00FA6D  1  90 0D        	BCC	SSP11		;if low working row < low e:
00FA6F  1               
00FA6F  1  18           SSP10	CLC
00FA70  1  A5 54        	LDA	ROWCRS		;cursor row
00FA72  1  6D F8 02     	ADC	ROWINC		;add row increment
00FA75  1  85 54        	STA	ROWCRS		;update cursor row
00FA77  1  A2 00        	LDX	#0		;indicate subtract from wor:
00FA79  1  20 AE F6     	JSR	SEP		;subtract end pointer
00FA7C  1               
00FA7C  1  18           SSP11	CLC
00FA7D  1  A5 72        	LDA	COLAC		;low working column
00FA7F  1  65 77        	ADC	DELTAC		;add column difference
00FA81  1  85 72        	STA	COLAC		;update working column
00FA83  1  A5 73        	LDA	COLAC+1
00FA85  1  65 78        	ADC	DELTAC+1
00FA87  1  85 73        	STA	COLAC+1
00FA89  1  C5 75        	CMP	ENDPT+1		;high end point
00FA8B  1  90 28        	BCC	SSP15		;if high working column < h:
00FA8D  1               
00FA8D  1  D0 06        	BNE	SSP12		;if high working column > h:
00FA8F  1               
00FA8F  1  A5 72        	LDA	COLAC		;low working column
00FA91  1  C5 74        	CMP	ENDPT		;low end point
00FA93  1  90 20        	BCC	SSP15		;if low working column < lo:
00FA95  1               
00FA95  1  2C F9 02     SSP12	BIT	COLINC		;column increment
00FA98  1  10 10        	BPL	SSP13		;if column increment positi:
00FA9A  1               
00FA9A  1  C6 55        	DEC	COLCRS		;decrement low cursor colum:
00FA9C  1  A5 55        	LDA	COLCRS		;low cursor column
00FA9E  1  C9 FF        	CMP	#$FF
00FAA0  1  D0 0E        	BNE	SSP14
00FAA2  1               
00FAA2  1  A5 56        	LDA	COLCRS+1	;high cursor column
00FAA4  1  F0 0A        	BEQ	SSP14		;if zero, do not decrement
00FAA6  1               
00FAA6  1  C6 56        	DEC	COLCRS+1	;decrement high cursor colu:
00FAA8  1  10 06        	BPL	SSP14
00FAAA  1               
00FAAA  1  E6 55        SSP13	INC	COLCRS		;increment low cursor colum:
00FAAC  1  D0 02        	BNE	SSP14		;if no carry
00FAAE  1               
00FAAE  1  E6 56        	INC	COLCRS+1	;adjust high cursor column
00FAB0  1               
00FAB0  1  A2 02        SSP14	LDX	#2		;indicate subtract from wor:
00FAB2  1  20 AE F6     	JSR	SEP		;subtract end pointer
00FAB5  1               
00FAB5  1               ;	Plot point.
00FAB5  1               
00FAB5  1  20 CA F6     SSP15	JSR	CCR		;check cursor range
00FAB8  1  20 CA F1     	JSR	PLO		;plot point
00FABB  1               
00FABB  1               ;	Check for right fill.
00FABB  1               
00FABB  1  AD B7 02     	LDA	FILFLG		;right fill flag
00FABE  1  F0 2F        	BEQ	SSP18		;if no right fill
00FAC0  1               
00FAC0  1               ;	Process right fill.
00FAC0  1               
00FAC0  1  20 4C F9     	JSR	SRC		;save row and column
00FAC3  1  AD FB 02     	LDA	ATACHR		;plot point
00FAC6  1  8D BC 02     	STA	HOLD4		;save plot point
00FAC9  1               
00FAC9  1  A5 54        SSP16	LDA	ROWCRS		;cursor row
00FACB  1  48           	PHA			;save cursor row
00FACC  1  20 12 F6     	JSR	ACC		;advance cursor column
00FACF  1  68           	PLA			;saved cursor row
00FAD0  1  85 54        	STA	ROWCRS		;restore cursor row
00FAD2  1  20 CA F6     	JSR	CCR		;check cursor range
00FAD5  1  20 8F F1     	JSR	GDC		;get data under cursor
00FAD8  1  D0 0C        	BNE	SSP17		;if non-zero data encounter:
00FADA  1               
00FADA  1  AD FD 02     	LDA	FILDAT		;fill data
00FADD  1  8D FB 02     	STA	ATACHR		;plot point
00FAE0  1  20 CA F1     	JSR	PLO		;plot point
00FAE3  1  4C C9 FA     	JMP	SSP16		;continue
00FAE6  1               
00FAE6  1  AD BC 02     SSP17	LDA	HOLD4		;saved plot point
00FAE9  1  8D FB 02     	STA	ATACHR		;restore plot point
00FAEC  1  20 57 F9     	JSR	RRC		;restore row and column
00FAEF  1               
00FAEF  1               ;	Subtract 1 from iteration counter.
00FAEF  1               
00FAEF  1  38           SSP18	SEC
00FAF0  1  A5 7E        	LDA	COUNTR		;iteration counter
00FAF2  1  E9 01        	SBC	#1		;subtract 1
00FAF4  1  85 7E        	STA	COUNTR		;update iteration counter
00FAF6  1  A5 7F        	LDA	COUNTR+1
00FAF8  1  E9 00        	SBC	#0
00FAFA  1  85 7F        	STA	COUNTR+1
00FAFC  1               
00FAFC  1               ;	Check for completion.
00FAFC  1               
00FAFC  1  30 03        	BMI	SSP19	;if iteration counter negative, exi:
00FAFE  1               
00FAFE  1  4C 4D FA     	JMP	SSP7	;continue
00FB01  1               
00FB01  1               ;	Exit.
00FB01  1               
00FB01  1  4C 1E F2     SSP19	JMP	SST	;perform screen STATUS, return
00FB04  1               ;	SPACE	4,10
00FB04  1               ;**	TMSK - Table of Bit Masks
00FB04  1               
00FB04  1               
00FB04  1  00 01 03 07  TMSK	DB	$00	;0 - mask for no bits
00FB08  1               	DB	$01	;1 - mask for lower 1 bit
00FB08  1               	DB	$03	;2 - mask for lower 2 bits
00FB08  1               	DB	$07	;3 - mask for lower 3 bits
00FB08  1               ;	SPACE	4,10
00FB08  1               ;**	TDSC - Table of Default Screen Colors
00FB08  1               
00FB08  1               
00FB08  1  28 CA 94 46  TDSC	DB	$28	;default playfield 0 color
00FB0C  1  00           
00FB0D  1               	DB	$CA	;default playfield 1 color
00FB0D  1               	DB	$94	;default playfield 2 color
00FB0D  1               	DB	$46	;default playfield 3 color
00FB0D  1               	DB	$00	;default background color
00FB0D  1               ;	SPACE	4,10
00FB0D  1               ;**	TCCR - Table of Control Character Routines
00FB0D  1               ;*
00FB0D  1               ;*	Each entry is 3 bytes. The first byte is the contr:
00FB0D  1               ;*	character; the second and third bytes are the addre:
00FB0D  1               ;*	the routine which processes the control character.
00FB0D  1               
00FB0D  1               
00FB0D  1  1B E0 F3     TCCR	DB	$1B
00FB10  1               	DW	ESC	;escape
00FB10  1               
00FB10  1  1C E6 F3     	DB	$1C
00FB13  1               	DW	CUP	;move cursor up
00FB13  1               
00FB13  1  1D F3 F3     	DB	$1D
00FB16  1               	DW	CDN	;move cursor down
00FB16  1               
00FB16  1  1E 00 F4     	DB	$1E
00FB19  1               	DW	CLF	;move cursor left
00FB19  1               
00FB19  1  1F 11 F4     	DB	$1F
00FB1C  1               	DW	CRT	;move cursor right
00FB1C  1               
00FB1C  1  7D 20 F4     	DB	$7D
00FB1F  1               	DW	CSC	;clear screen
00FB1F  1               
00FB1F  1  7E 50 F4     	DB	$7E
00FB22  1               	DW	BSP	;backspace
00FB22  1               
00FB22  1  7F 7A F4     	DB	$7F
00FB25  1               	DW	TAB	;tab
00FB25  1               
00FB25  1  9B 61 F6     	DB	$9B
00FB28  1               	DW	RWS	;return with scrolling
00FB28  1               
00FB28  1  9C 20 F5     	DB	$9C
00FB2B  1               	DW	DLN	;delete line
00FB2B  1               
00FB2B  1  9D 0C F5     	DB	$9D
00FB2E  1               	DW	ILN	;insert line
00FB2E  1               
00FB2E  1  9E 9A F4     	DB	$9E
00FB31  1               	DW	CTB	;clear tab
00FB31  1               
00FB31  1  9F 95 F4     	DB	$9F
00FB34  1               	DW	STB	;set tab
00FB34  1               
00FB34  1  FD 56 F5     	DB	$FD
00FB37  1               	DW	BEL	;sound bell
00FB37  1               
00FB37  1  FE D5 F4     	DB	$FE
00FB3A  1               	DW	DCH	;delete character
00FB3A  1               
00FB3A  1  FF 9F F4     	DB	$FF
00FB3D  1               	DW	ICH	;insert character
00FB3D  1               
00FB3D  1               TCCRL	=	*-TCCR	;length
00FB3D  1               ;	SPACE	4,10
00FB3D  1               ;**	TSFR - Table of Super Function (Shifted Function Ke:
00FB3D  1               ;*
00FB3D  1               ;*	Each entry is 3 bytes. The first byte is the super:
00FB3D  1               ;*	character; the second and third bytes are the addre:
00FB3D  1               ;*	routine which processes the super function.
00FB3D  1               
00FB3D  1               
00FB3D  1  1C 40 F4     TSFR	DB	$1C
00FB40  1               	DW	CHM	;move cursor home
00FB40  1               
00FB40  1  1D 5F F5     	DB	$1D
00FB43  1               	DW	CBT	;move cursor to bottom
00FB43  1               
00FB43  1  1E 1B F4     	DB	$1E
00FB46  1               	DW	CLM	;move cursor to left margin
00FB46  1               
00FB46  1  1F 0A F4     	DB	$1F
00FB49  1               	DW	CRM	;move cursor to right margin
00FB49  1               ;	SPACE	4,10
00FB49  1               ;**	TAIC - Table of ATASCII to Internal Conversion Cons:
00FB49  1               
00FB49  1               
00FB49  1  40 00 20 60  TAIC	DB	$40	;0
00FB4D  1               	DB	$00	;1
00FB4D  1               	DB	$20	;2
00FB4D  1               	DB	$60	;3
00FB4D  1               ;	SPACE	4,10
00FB4D  1               ;**	TIAC - Table of Internal to ATASCII Conversion Cons:
00FB4D  1               
00FB4D  1               
00FB4D  1  20 40 00 60  TIAC	DB	$20	;0
00FB51  1               	DB	$40	;1
00FB51  1               	DB	$00	;2
00FB51  1               	DB	$60	;3
00FB51  1               ;	SPACE	4,10
00FB51  1               ;**	TCKD - Table of Character Key Definitions
00FB51  1               ;*
00FB51  1               ;*	Entry n is the ATASCII equivalent of key code n.
00FB51  1               
00FB51  1               
00FB51  1               TCKD	=	*
00FB51  1               
00FB51  1               ;	Lower Case Characters
00FB51  1               
00FB51  1  6C 6A 3B 8A  	DB	$6C	;$00 - l
00FB55  1  8B 6B 2B 2A  
00FB59  1  6F 80 70 75  
00FB61  1               	DB	$6A	;$01 - j
00FB61  1               	DB	$3B	;$02 - semicolon
00FB61  1               	DB	$8A	;$03 - F1
00FB61  1               	DB	$8B	;$04 - F2
00FB61  1               	DB	$6B	;$05 - k
00FB61  1               	DB	$2B	;$06 - +
00FB61  1               	DB	$2A	;$07 - *
00FB61  1               	DB	$6F	;$08 - o
00FB61  1               	DB	$80	;$09 - (invalid)
00FB61  1               	DB	$70	;$0A - p
00FB61  1               	DB	$75	;$0B - u
00FB61  1               	DB	$9B	;$0C - return
00FB61  1               	DB	$69	;$0D - i
00FB61  1               	DB	$2D	;$0E - -
00FB61  1               	DB	$3D	;$0F - =
00FB61  1               
00FB61  1  76 80 63 8C  	DB	$76	;$10 - v
00FB65  1  8D 62 78 7A  
00FB69  1  34 80 33 36  
00FB71  1               	DB	$80	;$11 - (invalid)
00FB71  1               	DB	$63	;$12 - c
00FB71  1               	DB	$8C	;$13 - F3
00FB71  1               	DB	$8D	;$14 - F4
00FB71  1               	DB	$62	;$15 - b
00FB71  1               	DB	$78	;$16 - x
00FB71  1               	DB	$7A	;$17 - z
00FB71  1               	DB	$34	;$18 - 4
00FB71  1               	DB	$80	;$19 - (invalid)
00FB71  1               	DB	$33	;$1A - 3
00FB71  1               	DB	$36	;$1B - 6
00FB71  1               	DB	$1B	;$1C - escape
00FB71  1               	DB	$35	;$1D - 5
00FB71  1               	DB	$32	;$1E - 2
00FB71  1               	DB	$31	;$1F - 1
00FB71  1               
00FB71  1  2C 20 2E 6E  	DB	$2C	;$20 - comma
00FB75  1  80 6D 2F 81  
00FB79  1  72 80 65 79  
00FB81  1               	DB	$20	;$21 - space
00FB81  1               	DB	$2E	;$22 - period
00FB81  1               	DB	$6E	;$23 - n
00FB81  1               	DB	$80	;$24 - (invalid)
00FB81  1               	DB	$6D	;$25 - m
00FB81  1               	DB	$2F	;$26 - /
00FB81  1               	DB	$81	;$27 - inverse
00FB81  1               	DB	$72	;$28 - r
00FB81  1               	DB	$80	;$29 - (invalid)
00FB81  1               	DB	$65	;$2A - e
00FB81  1               	DB	$79	;$2B - y
00FB81  1               	DB	$7F	;$2C - tab
00FB81  1               	DB	$74	;$2D - t
00FB81  1               	DB	$77	;$2E - w
00FB81  1               	DB	$71	;$2F - q
00FB81  1               
00FB81  1  39 80 30 37  	DB	$39	;$30 - 9
00FB85  1  7E 38 3C 3E  
00FB89  1  66 68 64 80  
00FB91  1               	DB	$80	;$31 - (invalid)
00FB91  1               	DB	$30	;$32 - 0
00FB91  1               	DB	$37	;$33 - 7
00FB91  1               	DB	$7E	;$34 - backspace
00FB91  1               	DB	$38	;$35 - 8
00FB91  1               	DB	$3C	;$36 - <
00FB91  1               	DB	$3E	;$37 - >
00FB91  1               	DB	$66	;$38 - f
00FB91  1               	DB	$68	;$39 - h
00FB91  1               	DB	$64	;$3A - d
00FB91  1               	DB	$80	;$3B - (invalid)
00FB91  1               	DB	$82	;$3C - CAPS
00FB91  1               	DB	$67	;$3D - g
00FB91  1               	DB	$73	;$3E - s
00FB91  1               	DB	$61	;$3F - a
00FB91  1               
00FB91  1               ;	Upper Case Characters
00FB91  1               
00FB91  1  4C 4A 3A 8A  	DB	$4C	;$40 - L
00FB95  1  8B 4B 5C 5E  
00FB99  1  4F 80 50 55  
00FBA1  1               	DB	$4A	;$41 - J
00FBA1  1               	DB	$3A	;$42 - colon
00FBA1  1               	DB	$8A	;$43 - SHIFT-F1
00FBA1  1               	DB	$8B	;$44 - SHIFT-F2
00FBA1  1               	DB	$4B	;$45 - K
00FBA1  1               	DB	$5C	;$46 - \
00FBA1  1               	DB	$5E	;$47 - ^
00FBA1  1               	DB	$4F	;$48 - O
00FBA1  1               	DB	$80	;$49 - (invalid)
00FBA1  1               	DB	$50	;$4A - P
00FBA1  1               	DB	$55	;$4B - U
00FBA1  1               	DB	$9B	;$4C - SHIFT-return
00FBA1  1               	DB	$49	;$4D - I
00FBA1  1               	DB	$5F	;$4E - _
00FBA1  1               	DB	$7C	;$4F - |
00FBA1  1               
00FBA1  1  56 80 43 8C  	DB	$56	;$50 - V
00FBA5  1  8D 42 58 5A  
00FBA9  1  24 80 23 26  
00FBB1  1               	DB	$80	;$51 - (invalid)
00FBB1  1               	DB	$43	;$52 - C
00FBB1  1               	DB	$8C	;$53 - SHIFT-F3
00FBB1  1               	DB	$8D	;$54 - SHIFT-F4
00FBB1  1               	DB	$42	;$55 - B
00FBB1  1               	DB	$58	;$56 - X
00FBB1  1               	DB	$5A	;$57 - Z
00FBB1  1               	DB	$24	;$58 - $
00FBB1  1               	DB	$80	;$59 - (invalid)
00FBB1  1               	DB	$23	;$5A - #
00FBB1  1               	DB	$26	;$5B - &
00FBB1  1               	DB	$1B	;$5C - SHIFT-escape
00FBB1  1               	DB	$25	;$5D - %
00FBB1  1               	DB	$22	;$5E - "
00FBB1  1               	DB	$21	;$5F - !
00FBB1  1               
00FBB1  1  5B 20 5D 4E  	DB	$5B	;$60 - [
00FBB5  1  80 4D 3F 81  
00FBB9  1  52 80 45 59  
00FBC1  1               	DB	$20	;$61 - SHIFT-space
00FBC1  1               	DB	$5D	;$62 - ]
00FBC1  1               	DB	$4E	;$63 - N
00FBC1  1               	DB	$80	;$64 - (invalid)
00FBC1  1               	DB	$4D	;$65 - M
00FBC1  1               	DB	$3F	;$66 - ?
00FBC1  1               	DB	$81	;$67 - SHIFT-inverse
00FBC1  1               	DB	$52	;$68 - R
00FBC1  1               	DB	$80	;$69 - (invalid)
00FBC1  1               	DB	$45	;$6A - E
00FBC1  1               	DB	$59	;$6B - Y
00FBC1  1               	DB	$9F	;$6C - SHIFT-tab
00FBC1  1               	DB	$54	;$6D - T
00FBC1  1               	DB	$57	;$6E - W
00FBC1  1               	DB	$51	;$6F - Q
00FBC1  1               
00FBC1  1  28 80 29 27  	DB	$28	;$70 - (
00FBC5  1  9C 40 7D 9D  
00FBC9  1  46 48 44 80  
00FBD1  1               	DB	$80	;$71 - (invalid)
00FBD1  1               	DB	$29	;$72 - )
00FBD1  1               	DB	$27	;$73 - '
00FBD1  1               	DB	$9C	;$74 - SHIFT-delete
00FBD1  1               	DB	$40	;$75 - @
00FBD1  1               	DB	$7D	;$76 - SHIFT-clear
00FBD1  1               	DB	$9D	;$77 - SHIFT-insert
00FBD1  1               	DB	$46	;$78 - F
00FBD1  1               	DB	$48	;$79 - H
00FBD1  1               	DB	$44	;$7A - D
00FBD1  1               	DB	$80	;$7B - (invalid)
00FBD1  1               	DB	$83	;$7C - SHIFT-CAPS
00FBD1  1               	DB	$47	;$7D - G
00FBD1  1               	DB	$53	;$7E - S
00FBD1  1               	DB	$41	;$7F - A
00FBD1  1               
00FBD1  1               ;	Control Characters
00FBD1  1               
00FBD1  1  0C 0A 7B 80  	DB	$0C	;$80 - CTRL-L
00FBD5  1  80 0B 1E 1F  
00FBD9  1  0F 80 10 15  
00FBE1  1               	DB	$0A	;$81 - CTRL-J
00FBE1  1               	DB	$7B	;$82 - CTRL-semicolon
00FBE1  1               	DB	$80	;$83 - (invalid)
00FBE1  1               	DB	$80	;$84 - (invalid)
00FBE1  1               	DB	$0B	;$85 - CTRL-K
00FBE1  1               	DB	$1E	;$86 - CTRL-left arrow
00FBE1  1               	DB	$1F	;$87 - CTRL-right arrow
00FBE1  1               	DB	$0F	;$88 - CTRL-O
00FBE1  1               	DB	$80	;$89 - (invalid)
00FBE1  1               	DB	$10	;$8A - CTRL-P
00FBE1  1               	DB	$15	;$8B - CTRL-U
00FBE1  1               	DB	$9B	;$8C - CTRL-return
00FBE1  1               	DB	$09	;$8D - CTRL-I
00FBE1  1               	DB	$1C	;$8E - CTRL-up arrow
00FBE1  1               	DB	$1D	;$8F - CTRL-down arrow
00FBE1  1               
00FBE1  1  16 80 03 89  	DB	$16	;$90 - CTRL-V
00FBE5  1  80 02 18 1A  
00FBE9  1  80 80 85 80  
00FBF1  1               	DB	$80	;$91 - (invalid)
00FBF1  1               	DB	$03	;$92 - CTRL-C
00FBF1  1               	DB	$89	;$93 - CTRL-F3
00FBF1  1               	DB	$80	;$94 - (invalid)
00FBF1  1               	DB	$02	;$95 - CTRL-B
00FBF1  1               	DB	$18	;$96 - CTRL-X
00FBF1  1               	DB	$1A	;$97 - CTRL-Z
00FBF1  1               	DB	$80	;$98 - (invalid)
00FBF1  1               	DB	$80	;$99 - (invalid)
00FBF1  1               	DB	$85	;$9A - CTRL-3
00FBF1  1               	DB	$80	;$9B - (invalid)
00FBF1  1               	DB	$1B	;$9C - CTRL-escape
00FBF1  1               	DB	$80	;$9D - (invalid)
00FBF1  1               	DB	$FD	;$9E - CTRL-2
00FBF1  1               	DB	$80	;$9F - (invalid)
00FBF1  1               
00FBF1  1  00 20 60 0E  	DB	$00	;$A0 - CTRL-comma
00FBF5  1  80 0D 80 81  
00FBF9  1  12 80 05 19  
00FC01  1               	DB	$20	;$A1 - CTRL-space
00FC01  1               	DB	$60	;$A2 - CTRL-period
00FC01  1               	DB	$0E	;$A3 - CTRL-N
00FC01  1               	DB	$80	;$A4 - (invalid)
00FC01  1               	DB	$0D	;$A5 - CTRL-M
00FC01  1               	DB	$80	;$A6 - (invalid)
00FC01  1               	DB	$81	;$A7 - CTRL-inverse
00FC01  1               	DB	$12	;$A8 - CTRL-R
00FC01  1               	DB	$80	;$A9 - (invalid)
00FC01  1               	DB	$05	;$AA - CTRL-E
00FC01  1               	DB	$19	;$AB - CTRL-Y
00FC01  1               	DB	$9E	;$AC - CTRL-tab
00FC01  1               	DB	$14	;$AD - CTRL-T
00FC01  1               	DB	$17	;$AE - CTRL-W
00FC01  1               	DB	$11	;$AF - CTRL-Q
00FC01  1               
00FC01  1  80 80 80 80  	DB	$80	;$B0 - (invalid)
00FC05  1  FE 80 7D FF  
00FC09  1  06 08 04 80  
00FC11  1               	DB	$80	;$B1 - (invalid)
00FC11  1               	DB	$80	;$B2 - (invalid)
00FC11  1               	DB	$80	;$B3 - (invalid)
00FC11  1               	DB	$FE	;$B4 - CTRL-delete
00FC11  1               	DB	$80	;$B5 - (invalid)
00FC11  1               	DB	$7D	;$B6 - CTRL-clear
00FC11  1               	DB	$FF	;$B7 - CTRL-insert
00FC11  1               	DB	$06	;$B8 - CTRL-F
00FC11  1               	DB	$08	;$B9 - CTRL-H
00FC11  1               	DB	$04	;$BA - CTRL-D
00FC11  1               	DB	$80	;$BB - (invalid)
00FC11  1               	DB	$84	;$BC - CTRL-CAPS
00FC11  1               	DB	$07	;$BD - CTRL-G
00FC11  1               	DB	$13	;$BE - CTRL-S
00FC11  1               	DB	$01	;$BF - CTRL-A
00FC11  1               ;	SPACE	4,10
00FC11  1               ;**	TFKD - Table of Function Key Definitions
00FC11  1               ;*
00FC11  1               ;*	Entry n is the ATASCII equivalent of adjusted funct:
00FC11  1               ;*	code n.
00FC11  1               
00FC11  1               
00FC11  1  1C 1D 1E 1F  TFKD	DB	$1C	;0 - F1 key
00FC15  1               	DB	$1D	;1 - F2 key
00FC15  1               	DB	$1E	;2 - F3 key
00FC15  1               	DB	$1F	;3 - F3 key
00FC15  1               
00FC15  1  8E 8F 90 91  	DB	$8E	;4 - SHIFT-F1 key
00FC19  1               	DB	$8F	;5 - SHIFT-F2 key
00FC19  1               	DB	$90	;6 - SHIFT-F3 key
00FC19  1               	DB	$91	;7 - SHIFT-F4 key
00FC19  1               ;	SPACE	4,10
00FC19  1               ;**	KIR - Process Keyboard IRQ
00FC19  1               ;*
00FC19  1               ;*	ENTRY	JMP	KIR
00FC19  1               ;*
00FC19  1               ;*	EXIT
00FC19  1               ;*		Exits via RTI
00FC19  1               ;*
00FC19  1               ;*	MODS
00FC19  1               ;*		Original Author Unknown
00FC19  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00FC19  1               ;*		   R. K. Nordin	11/01/83
00FC19  1               
00FC19  1               
00FC19  1               KIR	=	*	;entry
00FC19  1               
00FC19  1               ;	Initialize.
00FC19  1               
00FC19  1  8A           	TXA
00FC1A  1  48           	PHA		;save X
00FC1B  1  98           	TYA
00FC1C  1  48           	PHA		;save Y
00FC1D  1  AC 01 D3     	LDY	PORTB	;port B memory control
00FC20  1  AD 09 D2     	LDA	KBCODE	;keyboard code
00FC23  1  CD F2 02     	CMP	CH1	;last key code
00FC26  1  D0 05        	BNE	KIR1	;if not last key code
00FC28  1               
00FC28  1  AE F1 02     	LDX	KEYDEL	;keyboard debounce delay
00FC2B  1  D0 49        	BNE	KIR8	;if delay not expired, tread as bou:
00FC2D  1               
00FC2D  1               ;	Check for CTRL-F1.
00FC2D  1               
00FC2D  1  AE 6D 02     KIR1	LDX	KEYDIS	;save keyboard disable flag
00FC30  1  C9 83        	CMP	#CNTLF1
00FC32  1  D0 13        	BNE	KIR4	;if not CTRL-F1
00FC34  1               
00FC34  1               ;	Process CTRL-F1
00FC34  1               
00FC34  1  8A           	TXA		;keyboard disable flag
00FC35  1  49 FF        	EOR	#$FF	;complelent keyboard disable flag
00FC37  1  8D 6D 02     	STA	KEYDIS	;update keyboard disable flag
00FC3A  1  D0 05        	BNE	KIR2	;if keyboard disabled
00FC3C  1               
00FC3C  1  98           	TYA		;port B memory control
00FC3D  1  09 04        	ORA	#$04	;turn off LED 1
00FC3F  1  D0 03        	BNE	KIR3	;update port B memory control
00FC41  1               
00FC41  1  98           KIR2	TYA		;port B memory control
00FC42  1  29 FB        	AND	#$FB	;turn on LED 1
00FC44  1               
00FC44  1  A8           KIR3	TAY		;updated port B memory control
00FC45  1  B0 26        	BCS	KIR7	;reset keyboard controls
00FC47  1               
00FC47  1               ;	Check keyboard disable.
00FC47  1               
00FC47  1  8A           KIR4	TXA		;keyboard disable flag
00FC48  1  D0 3D        	BNE	KIR9	;if keyboard disabled, exit
00FC4A  1               
00FC4A  1               ;	Get character.
00FC4A  1               
00FC4A  1  AD 09 D2     	LDA	KBCODE	;keyyboard code
00FC4D  1  AA           	TAX		;character
00FC4E  1               
00FC4E  1               ;	Check for CTRL-1.
00FC4E  1               
00FC4E  1  C9 9F        	CMP	#CNTL1
00FC50  1  D0 0A        	BNE	KIR5	;if not CTRL-1
00FC52  1               
00FC52  1               ;	Process CTRL-1.
00FC52  1               
00FC52  1  AD FF 02     	LDA	SSFLAG	;start/stop flag
00FC55  1  49 FF        	EOR	#$FF	;complement start/stop flag
00FC57  1  8D FF 02     	STA	SSFLAG	;update start/stop flag
00FC5A  1  B0 11        	BCS	KIR7	;make CTRL-1 invisible
00FC5C  1               
00FC5C  1               ;	Check character.
00FC5C  1               
00FC5C  1  29 3F        KIR5	AND	#$3F	;mask off shift and control bits
00FC5E  1  C9 11        	CMP	#HELP
00FC60  1  D0 2E        	BNE	KIR10	;if not HELP key
00FC62  1               
00FC62  1               ;	Process HELP.
00FC62  1               
00FC62  1  8E DC 02     	STX	HELPFG	;indicate HELP key pressed
00FC65  1  F0 06        	BEQ	KIR7	;reset keyboard controls
00FC67  1               
00FC67  1               ;	Process character.
00FC67  1               
00FC67  1  8E FC 02     KIR6	STX	CH	;key code
00FC6A  1  8E F2 02     	STX	CH1	;reset previous key code
00FC6D  1               
00FC6D  1               ;	Reset keyboard controls.
00FC6D  1               
00FC6D  1  A9 03        KIR7	LDA	#3
00FC6F  1  8D F1 02     	STA	KEYDEL	;re-initialize for debounce
00FC72  1  A9 00        	LDA	#0
00FC74  1  85 4D        	STA	ATRACT	;clear attract-mode timer/flag
00FC76  1               
00FC76  1               ;	Prepare to exit.
00FC76  1               
00FC76  1  AD D9 02     KIR8	LDA	KRPDEL	;auto-repeat delay
00FC79  1  8D 2B 02     	STA	SRTIMR	;reset software key repeat timer
00FC7C  1  AD 2F 02     	LDA	SDMCTL	;DMA control
00FC7F  1  D0 06        	BNE	KIR9	;if DMA not disabled, exit
00FC81  1               
00FC81  1  AD DD 02     	LDA	DMASAV	;saved DMA control
00FC84  1  8D 2F 02     	STA	SDMCTL	;DMA control
00FC87  1               
00FC87  1               ;	Exit.
00FC87  1               
00FC87  1  8C 01 D3     KIR9	STY	PORTB	;update port B memory control
00FC8A  1  68           	PLA		;saved Y
00FC8B  1  A8           	TAY		;restore Y
00FC8C  1  68           	PLA		;saved X
00FC8D  1  AA           	TAX		;restore X
00FC8E  1  68           	PLA		;restore A
00FC8F  1  40           	RTI		;return
00FC90  1               
00FC90  1               ;	Check for CTRL-F2 or CTRL-F4.
00FC90  1               
00FC90  1  E0 84        KIR10	CPX	#CNTLF2
00FC92  1  F0 21        	BEQ	KIR12	;if CTRL-F2
00FC94  1               
00FC94  1  E0 94        	CPX	#CNTLF4
00FC96  1  D0 CF        	BNE	KIR6	;if not CTRL-F4
00FC98  1               
00FC98  1               ;	Process CTRL-F4.
00FC98  1               
00FC98  1  AD F4 02     	LDA	CHBAS	;character set base
00FC9B  1  AE 6B 02     	LDX	CHSALT	;character set alternate
00FC9E  1  8D 6B 02     	STA	CHSALT	;update character set alternate
00FCA1  1  8E F4 02     	STX	CHBAS	;update character set base
00FCA4  1               
00FCA4  1  E0 CC        	CPX	#high ICSORG	;high international charact:
00FCA6  1  F0 06        	BEQ	KIR11		;if international character:
00FCA8  1               
00FCA8  1  98           	TYA		;port B memory control
00FCA9  1  09 08        	ORA	#$08	;turn off LED 2
00FCAB  1  A8           	TAY		;updated port B memory control
00FCAC  1  D0 BF        	BNE	KIR7	;reset keyboard controls
00FCAE  1               
00FCAE  1  98           KIR11	TYA		;port B memory control
00FCAF  1  29 F7        	AND	#$F7	;turn on LED 2
00FCB1  1  A8           	TAY		;updated port B memory control
00FCB2  1  4C 6D FC     	JMP	KIR7	;reset keyboard controls
00FCB5  1               
00FCB5  1               ;	Process CTRL-F2.
00FCB5  1               
00FCB5  1  AD 2F 02     KIR12	LDA	SDMCTL	;DMA control
00FCB8  1  F0 CD        	BEQ	KIR9	;if disabled, exit
00FCBA  1               
00FCBA  1  8D DD 02     	STA	DMASAV	;save DMA state
00FCBD  1  A9 00        	LDA	#0	;disable DMA
00FCBF  1  8D 2F 02     	STA	SDMCTL	;DMA control
00FCC2  1  F0 C3        	BEQ	KIR9	;exit
00FCC4  1               ;	SPACE	4,10
00FCC4  1               ;**	FDL - Process Display List Interrupt for Fine Scrol:
00FCC4  1               ;*
00FCC4  1               ;*	ENTRY	JMP	DFL
00FCC4  1               ;*
00FCC4  1               ;*	EXIT
00FCC4  1               ;*		Exits via RTI
00FCC4  1               ;*
00FCC4  1               ;*	NOTES
00FCC4  1               ;*		Problem: in the CRASS65 version, COLRSH was:
00FCC4  1               ;*		zero-page.
00FCC4  1               ;*		Problem: in the CRASS65 version, DRKMSK was:
00FCC4  1               ;*		zero-page.
00FCC4  1               ;*
00FCC4  1               ;*	MODS
00FCC4  1               ;*		H. Stewart	06/01/82
00FCC4  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00FCC4  1               ;*		   R. K. Nordin	11/01/83
00FCC4  1               
00FCC4  1               
00FCC4  1               FDL	=	*		;entry
00FCC4  1  48           	PHA			;save A
00FCC5  1  AD C6 02     	LDA	COLOR2		;playfield 2 color
00FCC8  1               ;	EOR	COLRSH		;modify with attract-mode c:
00FCC8  1  4D 4F 00     	.BYTE	$4D, low COLRSH, high COLRSH ;originally VFD
00FCCB  1               ;	AND	DRKMSK		;modify with attract-mode l:
00FCCB  1  2D 4E 00     	.BYTE	$2D, low DRKMSK, high COLRSH ;originally VFD
00FCCE  1  8D 0A D4     	STA	WSYNC		;wait for HBLANK synchroniz:
00FCD1  1  8D 17 D0     	STA	COLPF1		;playfield 1 color/luminanc:
00FCD4  1  68           	PLA			;restore A
00FCD5  1  40           	RTI			;return
00FCD6  1               ;	SUBTTL	'$FCD8 Patch'
00FCD6  1               ;	SPACE	4,10
00FCD6  1  00 00        	FIX	$FCD8
00FCD8  1               ;	SPACE	4,10
00FCD8  1               ;**	FCD8 - $FCD8 Patch
00FCD8  1               ;*
00FCD8  1               ;*	For compatibility with OS Revision B, sound key cli:
00FCD8  1               
00FCD8  1               
00FCD8  1  4C 83 F9     	JMP	SKC	;sound key click, return
00FCDB  1               ;	SUBTTL	'Cassette Handler'
00FCDB  1               ;	SPACE	4,10
00FCDB  1               ;**	CIN - Initialize Cassette
00FCDB  1               ;*
00FCDB  1               ;*	ENTRY	JSR	CIN
00FCDB  1               ;*
00FCDB  1               ;*	MODS
00FCDB  1               ;*		Original Author Unknown
00FCDB  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00FCDB  1               ;*		   R. K. Nordin	11/01/83
00FCDB  1               
00FCDB  1               
00FCDB  1               CIN	=	*		;entry
00FCDB  1  A9 CC        	LDA	#low B00600	;indicate 600 baud
00FCDD  1  8D EE 02     	STA	CBAUDL		;cassette baud rate
00FCE0  1  A9 05        	LDA	#high B00600
00FCE2  1  8D EF 02     	STA	CBAUDH
00FCE5  1               ;	JMP	CSP		;return
00FCE5  1               ;	SPACE	4,10
00FCE5  1               ;**	CSP - Perform Cassette SPECIAL
00FCE5  1               ;*
00FCE5  1               ;*	CSP does nothing.
00FCE5  1               ;*
00FCE5  1               ;*	ENTRY	JSR	CSP
00FCE5  1               ;*
00FCE5  1               ;*	MODS
00FCE5  1               ;*		Original Author Unknown
00FCE5  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00FCE5  1               ;*		   R. K. Nordin	11/01/83
00FCE5  1               
00FCE5  1               
00FCE5  1               CSP	=	*	;entry
00FCE5  1  60           	RTS		;return
00FCE6  1               ;	SPACE	4,10
00FCE6  1               ;**	COP - Perform Cassette OPEN
00FCE6  1               ;*
00FCE6  1               ;*	ENTRY	JSR	COP
00FCE6  1               ;*
00FCE6  1               ;*	MODS
00FCE6  1               ;*		Original Author Unknown
00FCE6  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00FCE6  1               ;*		   R. K. Nordin	11/01/83
00FCE6  1               
00FCE6  1               
00FCE6  1               COP	=	*	;entry
00FCE6  1               
00FCE6  1               ;	Set Cassette IRG type.
00FCE6  1               
00FCE6  1  A5 2B        	LDA	ICAX2Z	;second auxiliary information
00FCE8  1  85 3E        	STA	FTYPE	;cassette IRG type
00FCEA  1               
00FCEA  1               ;	Check OPEN mode.
00FCEA  1               
00FCEA  1  A5 2A        	LDA	ICAX1Z	;OPEN mode
00FCEC  1  29 0C        	AND	#$0C	;open for input and output bits
00FCEE  1  C9 04        	CMP	#$04	;open for input bit
00FCF0  1  F0 05        	BEQ	OCI	;if open for input, process, return
00FCF2  1               
00FCF2  1  C9 08        	CMP	#$08	;open for output bit
00FCF4  1  F0 3E        	BEQ	OCO	;if open for output, process, retur:
00FCF6  1               
00FCF6  1               ;	Exit.
00FCF6  1               
00FCF6  1  60           	RTS		;return
00FCF7  1               ;	SPACE	4,10
00FCF7  1               ;**	OCI - Open Cassette for Input
00FCF7  1               ;*
00FCF7  1               ;*	ENTRY	JSR	OCI
00FCF7  1               ;*
00FCF7  1               ;*	MODS
00FCF7  1               ;*		Original Author Unknown
00FCF7  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00FCF7  1               ;*		   R. K. Nordin	11/01/83
00FCF7  1               
00FCF7  1               
00FCF7  1               OCI	=	*	;entry
00FCF7  1               
00FCF7  1               ;	Process open for input.
00FCF7  1               
00FCF7  1  A9 00        	LDA	#0	;indicate reading
00FCF9  1  8D 89 02     	STA	WMODE	;WRITE mode
00FCFC  1  85 3F        	STA	FEOF	;indicate no FEOF yet
00FCFE  1  A9 01        	LDA	#TONE2	;tone for pressing PLAY
00FD00  1  20 FC FD     	JSR	AUB	;alert user with beep
00FD03  1  30 29        	BMI	PBC1	;if error
00FD05  1               
00FD05  1               ;	Initialize cassette READ.
00FD05  1               
00FD05  1               ;	JMP	ICR	;initialize cassette READ, return
00FD05  1               ;	SPACE	4,10
00FD05  1               ;**	ICR - Initialize Cassette READ
00FD05  1               ;*
00FD05  1               ;*	ENTRY	JSR	ICR
00FD05  1               ;*
00FD05  1               ;*	MODS
00FD05  1               ;*		Original Author Unknown
00FD05  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00FD05  1               ;*		   R. K. Nordin	11/01/83
00FD05  1               
00FD05  1               
00FD05  1               ICR	=	*		;entry
00FD05  1               
00FD05  1               ;	Initialize.
00FD05  1               
00FD05  1  A9 34        	LDA	#MOTRGO		;motor on
00FD07  1  8D 02 D3     	STA	PACTL		;port A control
00FD0A  1               
00FD0A  1               ;	Wait for leader read.
00FD0A  1               
00FD0A  1  A6 62        	LDX	PALNTS
00FD0C  1  BC 93 FE     	LDY	RLEADL,X	;low READ leader
00FD0F  1  BD 91 FE     	LDA	RLEADH,X	;high READ leader
00FD12  1  AA           	TAX
00FD13  1  A9 03        	LDA	#3
00FD15  1  8D 2A 02     	STA	CDTMF3
00FD18  1  20 5C E4     	JSR	SETVBV		;set up VBLANK timer
00FD1B  1               
00FD1B  1  AD 2A 02     ICR1	LDA	CDTMF3
00FD1E  1  D0 FB        	BNE	ICR1		;if not done waiting
00FD20  1               
00FD20  1               ;	Initialize.
00FD20  1               
00FD20  1  A9 80        	LDA	#128		;buffer size
00FD22  1  85 3D        	STA	BPTR		;initialize buffer pointer
00FD24  1  8D 8A 02     	STA	BLIM		;initialize buffer limit
00FD27  1  4C 77 FD     	JMP	OCO2		;exit
00FD2A  1               ;	SPACE	4,10
00FD2A  1               ;**	PBC - Process BREAK for Cassette Operation
00FD2A  1               ;*
00FD2A  1               ;*	ENTRY	JSR	PBC
00FD2A  1               ;*
00FD2A  1               ;*	MODS
00FD2A  1               ;*		Original Author Unknown
00FD2A  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00FD2A  1               ;*		   R. K. Nordin	11/01/83
00FD2A  1               
00FD2A  1               
00FD2A  1               PBC	=	*	;entry
00FD2A  1  A0 80        	LDY	#BRKABT	;BREAK abort error
00FD2C  1  C6 11        	DEC	BRKKEY	;reset BREAK key flag
00FD2E  1               
00FD2E  1  A9 00        PBC1	LDA	#0	;indicate reading
00FD30  1  8D 89 02     	STA	WMODE	;WRITE mode
00FD33  1  60           	RTS		;return
00FD34  1               ;	SPACE	4,10
00FD34  1               ;**	OCO - Open Cassette for Output
00FD34  1               ;*
00FD34  1               ;*	ENTRY	JSR	OCO
00FD34  1               ;*
00FD34  1               ;*	MODS
00FD34  1               ;*		Original Author Unknown
00FD34  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00FD34  1               ;*		   R. K. Nordin	11/01/83
00FD34  1               
00FD34  1               
00FD34  1               OCO	=	*	;entry
00FD34  1               
00FD34  1               ;	Initialize.
00FD34  1               
00FD34  1  A9 80        	LDA	#$80	;indicate writing
00FD36  1  8D 89 02     	STA	WMODE	;WRITE mode
00FD39  1  A9 02        	LDA	#TONE1
00FD3B  1  20 FC FD     	JSR	AUB	;alert user with beep
00FD3E  1  30 EE        	BMI	PBC1	;if error
00FD40  1               
00FD40  1               ;	Set baud rate to 600.
00FD40  1               
00FD40  1  A9 CC        	LDA	#low B00600	;600 baud
00FD42  1  8D 04 D2     	STA	$D204
00FD45  1  A9 05        	LDA	#high B00600
00FD47  1  8D 06 D2     	STA	$D206
00FD4A  1               
00FD4A  1               ;	Write marks.
00FD4A  1               
00FD4A  1  A9 60        	LDA	#$60
00FD4C  1  8D 00 03     	STA	DDEVIC
00FD4F  1  20 68 E4     	JSR	SENDEV
00FD52  1  A9 34        	LDA	#MOTRGO		;write 5 second blank tape
00FD54  1  8D 02 D3     	STA	PACTL
00FD57  1               
00FD57  1               ;	Wait for leader written.
00FD57  1               
00FD57  1  A6 62        	LDX	PALNTS
00FD59  1  BC 8F FE     	LDY	WLEADL,X
00FD5C  1  BD 8D FE     	LDA	WLEADH,X
00FD5F  1  AA           	TAX
00FD60  1  A9 03        	LDA	#3
00FD62  1  20 5C E4     	JSR	SETVBV		;set VBLANK parameters
00FD65  1  A9 FF        	LDA	#$FF
00FD67  1  8D 2A 02     	STA	CDTMF3
00FD6A  1               
00FD6A  1  A5 11        OCO1	LDA	BRKKEY	;BREAK key flag
00FD6C  1  F0 BC        	BEQ	PBC	;if BREAK during write leader, proc:
00FD6E  1               
00FD6E  1  AD 2A 02     	LDA	CDTMF3
00FD71  1  D0 F7        	BNE	OCO1	;if not done waiting
00FD73  1               
00FD73  1               ;	Initialize buffer pointer.
00FD73  1               
00FD73  1  A9 00        	LDA	#0
00FD75  1  85 3D        	STA	BPTR	;buffer pointer
00FD77  1               
00FD77  1               ;	Indicate success.
00FD77  1               
00FD77  1  A0 01        OCO2	LDY	#SUCCES	;indicate success
00FD79  1  60           	RTS		;return
00FD7A  1               ;	SPACE	4,10
00FD7A  1               ;**	CGB - Perform Cassette GET-BYTE
00FD7A  1               ;*
00FD7A  1               ;*	ENTRY	JSR	CGB
00FD7A  1               ;*
00FD7A  1               ;*	MODS
00FD7A  1               ;*		Original Author Unknown
00FD7A  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00FD7A  1               ;*		   R. K. Nordin	11/01/83
00FD7A  1               
00FD7A  1               
00FD7A  1               CGB	=	*		;entry
00FD7A  1               
00FD7A  1               ;	Check for EOF.
00FD7A  1               
00FD7A  1  A5 3F        	LDA	FEOF		;EOF flag
00FD7C  1  30 33        	BMI	RCB3		;if at EOF already
00FD7E  1               
00FD7E  1               ;	Check for end of buffer.
00FD7E  1               
00FD7E  1  A6 3D        	LDX	BPTR		;buffer pointer
00FD80  1  EC 8A 02     	CPX	BLIM		;buffer limit
00FD83  1  F0 08        	BEQ	RCB		;if end of buffer, read blo:
00FD85  1               
00FD85  1               ;	Get next byte.
00FD85  1               
00FD85  1  BD 00 04     	LDA	CASBUF+3,X	;byte
00FD88  1  E6 3D        	INC	BPTR		;increment pointer
00FD8A  1  A0 01        	LDY	#SUCCES		;indicate success
00FD8C  1               
00FD8C  1  60           CGB1	RTS			;return
00FD8D  1               ;	SPACE	4,10
00FD8D  1               ;**	RCB - Read Cassette Block
00FD8D  1               ;*
00FD8D  1               ;*	ENTRY	JSR	RCB
00FD8D  1               ;*
00FD8D  1               ;*	MODS
00FD8D  1               ;*		Original Author Unknown
00FD8D  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00FD8D  1               ;*		   R. K. Nordin	11/01/83
00FD8D  1               
00FD8D  1               
00FD8D  1               RCB	=	*	;entry
00FD8D  1               
00FD8D  1               ;	Perform READ.
00FD8D  1               
00FD8D  1  A9 52        	LDA	#'R'	;read
00FD8F  1  20 3F FE     	JSR	SCB	;perform SIO on cassette buffer
00FD92  1  98           	TYA
00FD93  1  30 F7        	BMI	CGB1	;if SIO error
00FD95  1               
00FD95  1  A9 00        	LDA	#0
00FD97  1  85 3D        	STA	BPTR	;reset pointer
00FD99  1  A2 80        	LDX	#$80	;default number of bytes
00FD9B  1               
00FD9B  1               ;	Check for header.
00FD9B  1               
00FD9B  1  AD FF 03     	LDA	CASBUF+2
00FD9E  1  C9 FE        	CMP	#EOT
00FDA0  1  F0 0D        	BEQ	RCB2	;if header, read again
00FDA2  1               
00FDA2  1               ;	Check for last record.
00FDA2  1               
00FDA2  1  C9 FA        	CMP	#DT1
00FDA4  1  D0 03        	BNE	RCB1		;if not last data record
00FDA6  1               
00FDA6  1  AE 7F 04     	LDX	CASBUF+130	;number of bytes
00FDA9  1               
00FDA9  1               ;	Set number of bytes.
00FDA9  1               
00FDA9  1  8E 8A 02     RCB1	STX	BLIM
00FDAC  1               
00FDAC  1               ;	Perform cassette GET-BYTE.
00FDAC  1               
00FDAC  1  4C 7A FD     	JMP	CGB		;perform cassette GET-BYTE,:
00FDAF  1               
00FDAF  1               ;	Set EOF flag.
00FDAF  1               
00FDAF  1  C6 3F        RCB2	DEC	FEOF		;set EOF flag
00FDB1  1               
00FDB1  1               ;	Exit.
00FDB1  1               
00FDB1  1  A0 88        RCB3	LDY	#EOFERR		;end of file indicator
00FDB3  1  60           	RTS			;return
00FDB4  1               ;	SPACE	4,10
00FDB4  1               ;**	CPB - Perform Cassette PUT-BYTE
00FDB4  1               ;*
00FDB4  1               ;*	ENTRY	JSR	CPB
00FDB4  1               ;*
00FDB4  1               ;*	MODS
00FDB4  1               ;*		Original Author Unknown
00FDB4  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00FDB4  1               ;*		   R. K. Nordin	11/01/83
00FDB4  1               
00FDB4  1               
00FDB4  1               CPB	=	*		;entry
00FDB4  1               
00FDB4  1               ;	Move data to buffer.
00FDB4  1               
00FDB4  1  A6 3D        	LDX	BPTR		;buffer pointer
00FDB6  1  9D 00 04     	STA	CASBUF+3,X	;data
00FDB9  1  E6 3D        	INC	BPTR		;increment buffer pointer
00FDBB  1  A0 01        	LDY	#SUCCES		;assume success
00FDBD  1               
00FDBD  1               ;	Check buffer full.
00FDBD  1               
00FDBD  1  E0 7F        	CPX	#127		;offset to last byte of buf:
00FDBF  1  F0 01        	BEQ	CPB1		;if buffer full
00FDC1  1               
00FDC1  1  60           	RTS			;return
00FDC2  1               
00FDC2  1               ;	Write cassette buffer.
00FDC2  1               
00FDC2  1  A9 FC        CPB1	LDA	#DTA	;indicate data record type
00FDC4  1  20 7C FE     	JSR	WCB	;write cassette buffer
00FDC7  1  A9 00        	LDA	#0
00FDC9  1  85 3D        	STA	BPTR	;reset buffer pointer
00FDCB  1  60           	RTS		;return
00FDCC  1               ;	SPACE	4,10
00FDCC  1               ;**	CST - Perform Cassette STATUS
00FDCC  1               ;*
00FDCC  1               ;*	ENTRY	JSR	CST
00FDCC  1               ;*
00FDCC  1               ;*	MODS
00FDCC  1               ;*		Original Author Unknown
00FDCC  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00FDCC  1               ;*		   R. K. Nordin	11/01/83
00FDCC  1               
00FDCC  1               
00FDCC  1               CST	=	*	;entry
00FDCC  1  A0 01        	LDY	#SUCCES	;indicate success
00FDCE  1  60           	RTS		;return
00FDCF  1               ;	SPACE	4,10
00FDCF  1               ;**	CCL - Perform Cassette CLOSE
00FDCF  1               ;*
00FDCF  1               ;*	ENTRY	JSR	CCL
00FDCF  1               ;*
00FDCF  1               ;*	MODS
00FDCF  1               ;*		Original Author Unknown
00FDCF  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00FDCF  1               ;*		   R. K. Nordin	11/01/83
00FDCF  1               
00FDCF  1               
00FDCF  1               CCL	=	*	;entry
00FDCF  1               
00FDCF  1               ;	Check mode.
00FDCF  1               
00FDCF  1  AD 89 02     	LDA	WMODE	;WRITE mode
00FDD2  1  30 08        	BMI	CCL2	;if writing
00FDD4  1               
00FDD4  1               ;	Process reading.
00FDD4  1               
00FDD4  1  A0 01        	LDY	#SUCCES	;indicate success
00FDD6  1               
00FDD6  1               ;	Exit.
00FDD6  1               
00FDD6  1  A9 3C        CCL1	LDA	#MOTRST
00FDD8  1  8D 02 D3     	STA	PACTL	;stop motor
00FDDB  1  60           	RTS		;return
00FDDC  1               
00FDDC  1               ;	Process writing.
00FDDC  1               
00FDDC  1  A6 3D        CCL2	LDX	BPTR		;buffer pointer
00FDDE  1  F0 0A        	BEQ	CCL3		;if no data bytes in buffer
00FDE0  1               
00FDE0  1  8E 7F 04     	STX	CASBUF+130	;number of bytes
00FDE3  1  A9 FA        	LDA	#DT1		;indicate data record type
00FDE5  1  20 7C FE     	JSR	WCB		;write cassette buffer
00FDE8  1  30 EC        	BMI	CCL1		;if error, exit
00FDEA  1               
00FDEA  1               ;	Zero buffer.
00FDEA  1               
00FDEA  1  A2 7F        CCL3	LDX	#127		;offset to last byte in buf:
00FDEC  1  A9 00        	LDA	#0
00FDEE  1               
00FDEE  1  9D 00 04     CCL4	STA	CASBUF+3,X	;zero byte
00FDF1  1  CA           	DEX
00FDF2  1  10 FA        	BPL	CCL4		;if not done
00FDF4  1               
00FDF4  1               ;	Write cassette buffer.
00FDF4  1               
00FDF4  1  A9 FE        	LDA	#EOT	;indicate EOT record type
00FDF6  1  20 7C FE     	JSR	WCB	;write cassette buffer
00FDF9  1               
00FDF9  1               ;	Exit.
00FDF9  1               
00FDF9  1  4C D6 FD     	JMP	CCL1	;exit
00FDFC  1               ;	SPACE	4,10
00FDFC  1               ;**	AUB - Alert User with Beep
00FDFC  1               ;*
00FDFC  1               ;*	ON ENTRY A= FREQ
00FDFC  1               ;*
00FDFC  1               ;*	ENTRY	JSR	AUB
00FDFC  1               ;*
00FDFC  1               ;*	MODS
00FDFC  1               ;*		Original Author Unknown
00FDFC  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00FDFC  1               ;*		   R. K. Nordin	11/01/83
00FDFC  1               
00FDFC  1               
00FDFC  1               AUB	=	*		;entry
00FDFC  1               
00FDFC  1               ;	Initialize.
00FDFC  1               
00FDFC  1  85 40        	STA	FREQ		;frequency
00FDFE  1               
00FDFE  1               ;	Compute termination time of beep duration.
00FDFE  1               
00FDFE  1  A5 14        AUB1	LDA	RTCLOK+2	;current time
00FE00  1  18           	CLC
00FE01  1  A6 62        	LDX	PALNTS
00FE03  1  7D 95 FE     	ADC	BEEPNX,X	;add constant for 1 second :
00FE06  1  AA           	TAX			;beep duration termination :
00FE07  1               
00FE07  1               ;	Turn on speaker.
00FE07  1               
00FE07  1  A9 FF        AUB2	LDA	#$FF
00FE09  1  8D 1F D0     	STA	CONSOL		;turn on speaker
00FE0C  1  A9 00        	LDA	#$00
00FE0E  1               
00FE0E  1               ;	Delay.
00FE0E  1               
00FE0E  1  A0 F0        	LDY	#$F0
00FE10  1               
00FE10  1  88           AUB3	DEY
00FE11  1  D0 FD        	BNE	AUB3		;if not done delaying
00FE13  1               
00FE13  1               ;	Turn off speaker.
00FE13  1               
00FE13  1  8D 1F D0     	STA	CONSOL		;turn off speaker
00FE16  1               
00FE16  1               ;	Delay.
00FE16  1               
00FE16  1  A0 F0        	LDY	#$F0
00FE18  1               
00FE18  1  88           AUB4	DEY
00FE19  1  D0 FD        	BNE	AUB4		;if not done delaying
00FE1B  1               
00FE1B  1               ;	Check for beep duration termination time.
00FE1B  1               
00FE1B  1  E4 14        	CPX	RTCLOK+2	;compare current time
00FE1D  1  D0 E8        	BNE	AUB2		;if termination time not re:
00FE1F  1               
00FE1F  1  C6 40        	DEC	FREQ		;decrement frequency
00FE21  1  F0 0E        	BEQ	AUB6		;if all done, wait for anot:
00FE23  1               
00FE23  1               ;	Compute termination time of beep separation.
00FE23  1               
00FE23  1  8A           	TXA
00FE24  1  18           	CLC
00FE25  1  A6 62        	LDX	PALNTS
00FE27  1  7D 97 FE     	ADC	BEEPFX,X	;add constant
00FE2A  1  AA           	TAX			;beep separation terminatio:
00FE2B  1               
00FE2B  1               ;	Wait for termination of beep separation.
00FE2B  1               
00FE2B  1  E4 14        AUB5	CPX	RTCLOK+2	;compare current time
00FE2D  1  D0 FC        	BNE	AUB5		;if termination time not re:
00FE2F  1               
00FE2F  1               ;	Beep again.
00FE2F  1               
00FE2F  1  F0 CD        	BEQ	AUB1		;beep again
00FE31  1               
00FE31  1               ;	Wait for key.
00FE31  1               
00FE31  1  20 36 FE     AUB6	JSR	WFK		;wait for key
00FE34  1  98           	TYA			;status
00FE35  1  60           	RTS			;return
00FE36  1               ;	SPACE	4,10
00FE36  1               ;**	WFK - Wait for Key
00FE36  1               ;*
00FE36  1               ;*	ENTRY	JSR	WFK
00FE36  1               ;*
00FE36  1               ;*	NOTES
00FE36  1               ;*		Problem: bytes wasted by not doing LDA #hig:
00FE36  1               ;*		and LDA #low[KGB-1].
00FE36  1               ;*		Problem: bytes wasted by this being a subro:
00FE36  1               ;*
00FE36  1               ;*	MODS
00FE36  1               ;*		Original Author Unknown
00FE36  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00FE36  1               ;*		   R. K. Nordin	11/01/83
00FE36  1               
00FE36  1               
00FE36  1               WFK	=	*		;entry
00FE36  1  AD 25 E4     	LDA	KEYBDV+5	;keyboard GET-BYTE routine :
00FE39  1  48           	PHA			;put address on stack
00FE3A  1  AD 24 E4     	LDA	KEYBDV+4
00FE3D  1  48           	PHA
00FE3E  1  60           	RTS			;invoke keyboard GET-BYTE r:
00FE3F  1               ;	SPACE	4,10
00FE3F  1               ;**	SCB - Perform SIO on Cassette Buffer
00FE3F  1               ;*
00FE3F  1               ;*	ENTRY	JSR	SCB
00FE3F  1               ;*
00FE3F  1               ;*	NOTES
00FE3F  1               ;*		Problem: byte wasted on JSR/RTS exit.
00FE3F  1               ;*
00FE3F  1               ;*	MODS
00FE3F  1               ;*		Original Author Unknown
00FE3F  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00FE3F  1               ;*		   R. K. Nordin	11/01/83
00FE3F  1               
00FE3F  1               
00FE3F  1               SCB	=	*		;entry
00FE3F  1  8D 02 03     	STA	DCOMND		;command
00FE42  1  A9 00        	LDA	#high 131
00FE44  1  8D 09 03     	STA	DBYTHI		;buffer length
00FE47  1  A9 83        	LDA	#low 131
00FE49  1  8D 08 03     	STA	DBYTLO
00FE4C  1  A9 03        	LDA	#high CASBUF
00FE4E  1  8D 05 03     	STA	DBUFHI		;buffer address
00FE51  1  A9 FD        	LDA	#low CASBUF
00FE53  1  8D 04 03     	STA	DBUFLO
00FE56  1  A9 60        	LDA	#$60		;cassette bus ID
00FE58  1  8D 00 03     	STA	DDEVIC
00FE5B  1  A9 00        	LDA	#0
00FE5D  1  8D 01 03     	STA	DUNIT
00FE60  1  A9 23        	LDA	#35		;timeout
00FE62  1  8D 06 03     	STA	DTIMLO
00FE65  1  AD 02 03     	LDA	DCOMND		;command
00FE68  1  A0 40        	LDY	#GETDAT		;assume SIO GET-DATA comman:
00FE6A  1  C9 52        	CMP	#READ
00FE6C  1  F0 02        	BEQ	SCB1		;if READ command
00FE6E  1               
00FE6E  1  A0 80        	LDY	#PUTDAT		;SIO PUT-DATA command
00FE70  1               
00FE70  1  8C 03 03     SCB1	STY	DSTATS		;SIO command
00FE73  1  A5 3E        	LDA	FTYPE		;IRG type
00FE75  1  8D 0B 03     	STA	DAUX2		;second auxiliary informati:
00FE78  1  20 59 E4     	JSR	SIOV		;vector to SIOV
00FE7B  1  60           	RTS			;return
00FE7C  1               ;	SPACE	4,10
00FE7C  1               ;**	WCB - Write Cassette Buffer
00FE7C  1               ;*
00FE7C  1               ;*	ENTRY	JSR	WCB
00FE7C  1               ;*
00FE7C  1               ;*	NOTES
00FE7C  1               ;*		Problem: byte wasted on JSR/RTS exit.
00FE7C  1               ;*
00FE7C  1               ;*	MODS
00FE7C  1               ;*		Original Author Unknown
00FE7C  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00FE7C  1               ;*		   R. K. Nordin	11/01/83
00FE7C  1               
00FE7C  1               
00FE7C  1               WCB	=	*		;entry
00FE7C  1  8D FF 03     	STA	CASBUF+2	;record type
00FE7F  1  A9 55        	LDA	#$55
00FE81  1  8D FD 03     	STA	CASBUF+0
00FE84  1  8D FE 03     	STA	CASBUF+1
00FE87  1  A9 57        	LDA	#'W'		;write
00FE89  1  20 3F FE     	JSR	SCB		;perform SIO on cassette bu:
00FE8C  1  60           	RTS			;return
00FE8D  1               ;	SPACE	4,10
00FE8D  1               ;**	NTSC/PAL Constant Tables
00FE8D  1               
00FE8D  1               
00FE8D  1  04 03        WLEADH	DB	high WLEADN	;high NTSC WRITE file leader
00FE8F  1               	DB	high WLEADP	;high PAL WRITE file leader
00FE8F  1               
00FE8F  1  80 C0        WLEADL	DB	low WLEADN	;low NTSC WRITE file leader
00FE91  1               	DB	low WLEADP	;low PAL WRITE file leader
00FE91  1               
00FE91  1  02 01        RLEADH	DB	high RLEADN	;high NTSC READ file leader
00FE93  1               	DB	high RLEADP	;high PAL READ file leader
00FE93  1               
00FE93  1  40 E0        RLEADL	DB	low RLEADN	;low NTSC READ file leader
00FE95  1               	DB	low RLEADP	;low PAL READ file leader
00FE95  1               
00FE95  1  1E 19        BEEPNX	DB	BEEPNN		;NTSC beep duration
00FE97  1               	DB	BEEPNP		;PAL beep duration
00FE97  1               
00FE97  1  0A 08        BEEPFX	DB	BEEPFN		;NTSC beep separation
00FE99  1               	DB	BEEPFP		;PAL beep separation
00FE99  1               ;	SUBTTL	'Printer Handler'
00FE99  1               ;	SPACE	4,10
00FE99  1               ;**	PIN - Initialize Printer
00FE99  1               ;*
00FE99  1               ;*	ENTRY	JSR	PIN
00FE99  1               ;*
00FE99  1               ;*	MODS
00FE99  1               ;*		Original Author Unknown
00FE99  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00FE99  1               ;*		   R. K. Nordin	11/01/83
00FE99  1               
00FE99  1               
00FE99  1               PIN	=	*	;entry
00FE99  1  A9 1E        	LDA	#30	;30 second timeout
00FE9B  1  8D 14 03     	STA	PTIMOT	;printer timeout
00FE9E  1  60           	RTS		;return
00FE9F  1               ;	SPACE	4,10
00FE9F  1               ;**	Printer Handler Address Data
00FE9F  1               ;*
00FE9F  1               ;*	NOTES
00FE9F  1               ;*		Problem: bytes wasted by tables and code.  :
00FE9F  1               ;*		Immediate instructions should be used.
00FE9F  1               
00FE9F  1               
00FE9F  1  EA 02        PSTB	DW	DVSTAT	;status buffer address
00FEA1  1               
00FEA1  1  C0 03        PPRB	DW	PRNBUF	;printer buffer address
00FEA3  1               ;	SPACE	4,10
00FEA3  1               ;**	PST - Perform Printer STATUS
00FEA3  1               ;*
00FEA3  1               ;*	ENTRY	JSR	PST
00FEA3  1               ;*
00FEA3  1               ;*	MODS
00FEA3  1               ;*		Original Author Unknown
00FEA3  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00FEA3  1               ;*		   R. K. Nordin	11/01/83
00FEA3  1               
00FEA3  1               
00FEA3  1               PST	=	*	;entry
00FEA3  1  A9 04        	LDA	#4	;4 bytes for status
00FEA5  1  8D DF 02     	STA	PBUFSZ	;buffer size
00FEA8  1  AE 9F FE     	LDX	PSTB	;address of status buffer
00FEAB  1  AC A0 FE     	LDY	PSTB+1
00FEAE  1  A9 53        	LDA	#STATC	;status command
00FEB0  1  8D 02 03     	STA	DCOMND	;command
00FEB3  1  8D 0A 03     	STA	DAUX1
00FEB6  1  20 14 FF     	JSR	SDP	;set up DCB for printer
00FEB9  1  20 59 E4     	JSR	SIOV	;vector to SIO
00FEBC  1  30 03        	BMI	PSP	;if error, return
00FEBE  1               
00FEBE  1               ;	Exit.
00FEBE  1               
00FEBE  1  20 44 FF     	JSR	STS	;set printer timeout from status
00FEC1  1               ;	JMP	PSP	; return
00FEC1  1               ;	SPACE	4,10
00FEC1  1               ;**	PSP - Perform Printer SPECIAL
00FEC1  1               ;*
00FEC1  1               ;*	PSP does nothing.
00FEC1  1               ;*
00FEC1  1               ;*	ENTRY	JSR	PSP
00FEC1  1               ;*
00FEC1  1               ;*	MODS
00FEC1  1               ;*		Original Author Unknown
00FEC1  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00FEC1  1               ;*		   R. K. Nordin	11/01/83
00FEC1  1               
00FEC1  1               
00FEC1  1               PSP	=	*	;entry
00FEC1  1  60           	RTS		;return
00FEC2  1               ;	SPACE	4,10
00FEC2  1               ;**	POP - Perform Printer OPEN
00FEC2  1               ;*
00FEC2  1               ;*	ENTRY	JSR	POP
00FEC2  1               ;*
00FEC2  1               ;*	MODS
00FEC2  1               ;*		Original Author Unknown
00FEC2  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00FEC2  1               ;*		   R. K. Nordin	11/01/83
00FEC2  1               
00FEC2  1               
00FEC2  1               POP	=	*	;entry
00FEC2  1  20 A3 FE     	JSR	PST	;perform printer STATUS
00FEC5  1  A9 00        	LDA	#0
00FEC7  1  8D DE 02     	STA	PBPNT	;clear pointer buffer pointer
00FECA  1  60           	RTS		;return
00FECB  1               ;	SPACE	4,10
00FECB  1               ;**	PPB - Perform Printer PUT-BYTE
00FECB  1               ;*
00FECB  1               ;*	ENTRY	JSR	PPB
00FECB  1               ;*
00FECB  1               ;*	MODS
00FECB  1               ;*		Original Author Unknown
00FECB  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00FECB  1               ;*		   R. K. Nordin	11/01/83
00FECB  1               
00FECB  1               
00FECB  1               PPB	=	*		;entry
00FECB  1               
00FECB  1               ;	Initialize.
00FECB  1               
00FECB  1  48           	PHA			;save data
00FECC  1  BD 41 03     	LDA	ICDNO,X		;device number
00FECF  1  85 21        	STA	ICDNOZ		;device number
00FED1  1  20 4B FF     	JSR	PPM		;process print mode
00FED4  1               
00FED4  1               ;	Put data in buffer.
00FED4  1               
00FED4  1  AE DE 02     	LDX	PBPNT		;printer buffer pointer
00FED7  1  68           	PLA			;saved data
00FED8  1  9D C0 03     	STA	PRNBUF,X	;put data in buffer
00FEDB  1  E8           	INX
00FEDC  1               
00FEDC  1               ;	Check for buffer full.
00FEDC  1               
00FEDC  1  EC DF 02     	CPX	PBUFSZ		;printer buffer size
00FEDF  1  F0 15        	BEQ	PPP		;if buffer full, perform PU:
00FEE1  1               
00FEE1  1               ;	Update printer buffer pointer.
00FEE1  1               
00FEE1  1  8E DE 02     	STX	PBPNT		;printer buffer pointer
00FEE4  1               
00FEE4  1               ;	Check for EOL.
00FEE4  1               
00FEE4  1  C9 9B        	CMP	#EOL
00FEE6  1  F0 03        	BEQ	PPB1		;if EOL, space fill
00FEE8  1               
00FEE8  1               ;	Exit.
00FEE8  1               
00FEE8  1  A0 01        	LDY	#SUCCES		;indicate success
00FEEA  1  60           	RTS			;return
00FEEB  1               
00FEEB  1               ;	Space fill buffer.
00FEEB  1               
00FEEB  1  A9 20        PPB1	LDA	#' '		;indicate space fill
00FEED  1               ;	JMP	FPB		;fill printer buffer, retur:
00FEED  1               ;	SPACE	4,10
00FEED  1               ;**	FPB - Fill Printer Buffer
00FEED  1               ;*
00FEED  1               ;*	ENTRY	JSR	FPB
00FEED  1               ;*
00FEED  1               ;*	MODS
00FEED  1               ;*		Original Author Unknown
00FEED  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00FEED  1               ;*		   R. K. Nordin	11/01/83
00FEED  1               
00FEED  1               
00FEED  1               FPB	=	*		;entry
00FEED  1               
00FEED  1               ;	Fill printer buffer.
00FEED  1               
00FEED  1  9D C0 03     FPB1	STA	PRNBUF,X	;byte of printer buffer
00FEF0  1  E8           	INX
00FEF1  1  EC DF 02     	CPX	PBUFSZ		;printer buffer size
00FEF4  1  D0 F7        	BNE	FPB1		;if not done
00FEF6  1               
00FEF6  1               ;	Perform printer PUT.
00FEF6  1               
00FEF6  1               ;	JMP	PPP		;perform printer PUT, retur:
00FEF6  1               ;	SPACE	4,10
00FEF6  1               ;**	PPP - Perform Printer PUT
00FEF6  1               ;*
00FEF6  1               ;*	ENTRY	JSR	PPP
00FEF6  1               ;*
00FEF6  1               ;*	MODS
00FEF6  1               ;*		Original Author Unknown
00FEF6  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00FEF6  1               ;*		   R. K. Nordin	11/01/83
00FEF6  1               
00FEF6  1               
00FEF6  1               PPP	=	*	;entry
00FEF6  1               
00FEF6  1               ;	Clear printer buffer pointer.
00FEF6  1               
00FEF6  1  A9 00        	LDA	#0
00FEF8  1  8D DE 02     	STA	PBPNT	;clear printer buffer pointer
00FEFB  1               
00FEFB  1               ;	Set up DCB.
00FEFB  1               
00FEFB  1  AE A1 FE     	LDX	PPRB	;address of printer buffer
00FEFE  1  AC A2 FE     	LDY	PPRB+1
00FF01  1  20 14 FF     	JSR	SDP	;set up DCB for printer
00FF04  1               
00FF04  1               ;	Perform PUT.
00FF04  1               
00FF04  1  4C 59 E4     	JMP	SIOV	;vector to SIO, return
00FF07  1               ;	SPACE	4,10
00FF07  1               ;**	PCL - Perform Printer CLOSE
00FF07  1               ;*
00FF07  1               ;*	ENTRY	JSR	PCL
00FF07  1               ;*
00FF07  1               ;*	MODS
00FF07  1               ;*		Original Author Unknown
00FF07  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00FF07  1               ;*		   R. K. Nordin	11/01/83
00FF07  1               
00FF07  1               
00FF07  1               PCL	=	*	;entry
00FF07  1               
00FF07  1               ;	Initialize.
00FF07  1               
00FF07  1  20 4B FF     	JSR	PPM	;process print mode
00FF0A  1               
00FF0A  1               ;	Check buffer pointer.
00FF0A  1               
00FF0A  1  A9 9B        	LDA	#EOL	;indicate EOL fill
00FF0C  1  AE DE 02     	LDX	PBPNT	;printer buffer pointer
00FF0F  1  D0 DC        	BNE	FPB	;if buffer pointer non-zero, fill b:
00FF11  1               
00FF11  1               ;	Exit.
00FF11  1               
00FF11  1  A0 01        	LDY	#SUCCES	;indicate success
00FF13  1  60           	RTS		;return
00FF14  1               ;	SPACE	4,10
00FF14  1               ;**	SDP - Set Up DCB for Printer
00FF14  1               ;*
00FF14  1               ;*	ENTRY	JSR	SDP
00FF14  1               ;*
00FF14  1               ;*	MODS
00FF14  1               ;*		Original Author Unknown
00FF14  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00FF14  1               ;*		   R. K. Nordin	11/01/83
00FF14  1               
00FF14  1               
00FF14  1               SDP	=	*	;entry
00FF14  1  8E 04 03     	STX	DBUFLO	;low buffer address
00FF17  1  8C 05 03     	STY	DBUFHI	;high buffer address
00FF1A  1  A9 40        	LDA	#PDEVN	;printer device bus ID
00FF1C  1  8D 00 03     	STA	DDEVIC	;device bus ID
00FF1F  1  A5 21        	LDA	ICDNOZ	;device number
00FF21  1  8D 01 03     	STA	DUNIT	;unit number
00FF24  1  A9 80        	LDA	#$80	;SIO WRITE command
00FF26  1  AE 02 03     	LDX	DCOMND	;I/O direction
00FF29  1  E0 53        	CPX	#STATC	;STATUS command
00FF2B  1  D0 02        	BNE	SDP1	;if STATUS command
00FF2D  1               
00FF2D  1  A9 40        	LDA	#$40	;SIO READ command
00FF2F  1               
00FF2F  1  8D 03 03     SDP1	STA	DSTATS	;SIO command
00FF32  1  AD DF 02     	LDA	PBUFSZ
00FF35  1  8D 08 03     	STA	DBYTLO	;low buffer size
00FF38  1  A9 00        	LDA	#0
00FF3A  1  8D 09 03     	STA	DBYTHI	;high buffer size
00FF3D  1  AD 14 03     	LDA	PTIMOT
00FF40  1  8D 06 03     	STA	DTIMLO	;device timeout
00FF43  1  60           	RTS		;return
00FF44  1               ;	SPACE	4,10
00FF44  1               ;**	STS - Set Printer Timeout from Status
00FF44  1               ;*
00FF44  1               ;*	ENTRY	JSR	STS
00FF44  1               ;*
00FF44  1               ;*	NOTES
00FF44  1               ;*		Problem: bytes wasted by this code's being :
00FF44  1               ;*
00FF44  1               ;*	MODS
00FF44  1               ;*		Original Author Unknown
00FF44  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00FF44  1               ;*		   R. K. Nordin	11/01/83
00FF44  1               
00FF44  1               
00FF44  1               STS	=	*		;entry
00FF44  1  AD EC 02     	LDA	DVSTAT+2	;timeout
00FF47  1  8D 14 03     	STA	PTIMOT		;set printer timeout
00FF4A  1  60           	RTS			;return
00FF4B  1               ;	SPACE	4,10
00FF4B  1               ;**	PPM - Process Print Mode
00FF4B  1               ;*
00FF4B  1               ;*	PPM sets up the DCB according to the print mode.
00FF4B  1               ;*
00FF4B  1               ;*	ENTRY	JSR	PPM
00FF4B  1               ;*
00FF4B  1               ;*	MODS
00FF4B  1               ;*		Original Author Unknown
00FF4B  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00FF4B  1               ;*		   R. K. Nordin	11/01/83
00FF4B  1               
00FF4B  1               
00FF4B  1               PPM	=	*	;entry
00FF4B  1               
00FF4B  1               ;	Initialize.
00FF4B  1               
00FF4B  1  A0 57        	LDY	#WRITE	;WRITE command
00FF4D  1  A5 2B        	LDA	ICAX2Z	;print mode
00FF4F  1               
00FF4F  1               ;	Determine buffer size.
00FF4F  1               
00FF4F  1  C9 4E        PPM1	CMP	#NORMAL	;NORMAL mode
00FF51  1  D0 04        	BNE	PPM2	;if not NORMAL mode
00FF53  1               
00FF53  1  A2 28        	LDX	#NBUFSZ	;NORMAL mode buffer size
00FF55  1  D0 0E        	BNE	PPM4	;set buffer size
00FF57  1               
00FF57  1  C9 44        PPM2	CMP	#DOUBLE	;DOUBLE mode
00FF59  1  D0 04        	BNE	PPM3	;if not DOUBLE mode
00FF5B  1               
00FF5B  1  A2 14        	LDX	#DBUFSZ	;DOUBLE mode buffer size
00FF5D  1  D0 06        	BNE	PPM4	;set buffer size
00FF5F  1               
00FF5F  1  C9 53        PPM3	CMP	#SIDWAY	;SIDEWAYS mode
00FF61  1  D0 0C        	BNE	PPM5	;if not SIDEWAYS mode, assume NORMA:
00FF63  1               
00FF63  1  A2 1D        	LDX	#SBUFSZ	;SIDEWAYS mode buffer size
00FF65  1               
00FF65  1               ;	Set buffer size.
00FF65  1               
00FF65  1  8E DF 02     PPM4	STX	PBUFSZ	;set printer buffer size
00FF68  1               
00FF68  1               ;	Set DCB command and mode.
00FF68  1               
00FF68  1  8C 02 03     	STY	DCOMND	;command
00FF6B  1  8D 0A 03     	STA	DAUX1	;print mode
00FF6E  1  60           	RTS		;return
00FF6F  1               
00FF6F  1               ;	Assume NORMAL mode.
00FF6F  1               
00FF6F  1  A9 4E        PPM5	LDA	#NORMAL	;NORMAL mode
00FF71  1  D0 DC        	BNE	PPM1	;set buffer size
00FF73  1               ;	SUBTTL	'Self-test, Part 4'
00FF73  1               ;	SPACE	4,10
00FF73  1               ;**	VFR - Verify First 8K ROM
00FF73  1               ;*
00FF73  1               ;*	ENTRY	JSR	VFR
00FF73  1               ;*
00FF73  1               ;*	EXIT
00FF73  1               ;*		C clear, if verified
00FF73  1               ;*		  set, if not verified
00FF73  1               ;*
00FF73  1               ;*	MODS
00FF73  1               ;*		Original Author Unknown
00FF73  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00FF73  1               ;*		   R. K. Nordin	11/01/83
00FF73  1               
00FF73  1               
00FF73  1               VFR	=	*	;entry
00FF73  1               
00FF73  1               ;	Initialize.
00FF73  1               
00FF73  1  A2 00        	LDX	#0	;offset to first region to checksum
00FF75  1  86 8B        	STX	STCHK	;initial sum is zero
00FF77  1  86 8C        	STX	STCHK+1
00FF79  1               
00FF79  1               ;	Checksum ROM.
00FF79  1               
00FF79  1  20 A9 FF     VFR1	JSR	CRR	;checksum region of ROM
00FF7C  1  E0 0C        	CPX	#12
00FF7E  1  D0 F9        	BNE	VFR1	;if not done
00FF80  1               
00FF80  1               ;	Compare result.
00FF80  1               
00FF80  1  AD 00 C0     	LDA	$C000	;low checksum in ROM
00FF83  1  AE 01 C0     	LDX	$C001	;high checksum in ROM
00FF86  1               ;	JMP	VCS	;verify checksum, return
00FF86  1               ;	SPACE	4,10
00FF86  1               ;**	VCS - Verify Checksum
00FF86  1               ;*
00FF86  1               ;*	ENTRY	JSR	VCS
00FF86  1               ;*
00FF86  1               ;*	MODS
00FF86  1               ;*		Original Author Unknown
00FF86  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00FF86  1               ;*		   R. K. Nordin	11/01/83
00FF86  1               
00FF86  1               
00FF86  1               VCS	=	*	;entry
00FF86  1  C5 8B        	CMP	STCHK	;low checksum
00FF88  1  D0 06        	BNE	VCS1	;if low checksum bad
00FF8A  1               
00FF8A  1  E4 8C        	CPX	STCHK+1	;high checksum
00FF8C  1  D0 02        	BNE	VCS1	;if high checksum bad
00FF8E  1               
00FF8E  1  18           	CLC		;indicate verified
00FF8F  1  60           	RTS		;return
00FF90  1               
00FF90  1  38           VCS1	SEC		;indicate not verified
00FF91  1  60           	RTS		;return
00FF92  1               ;	SPACE	4,10
00FF92  1               ;**	VSR - Verify Second 8K ROM
00FF92  1               ;*
00FF92  1               ;*	ENTRY	JSR	VSR
00FF92  1               ;*
00FF92  1               ;*	EXIT
00FF92  1               ;*		C clear, if verified
00FF92  1               ;*		  set, if not verified
00FF92  1               ;*
00FF92  1               ;*	MODS
00FF92  1               ;*		Original Author Unknown
00FF92  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00FF92  1               ;*		   R. K. Nordin	11/01/83
00FF92  1               
00FF92  1               
00FF92  1               VSR	=	*	;entry
00FF92  1  A2 00        	LDX	#0
00FF94  1  86 8B        	STX	STCHK	;initial sum is zero
00FF96  1  86 8C        	STX	STCHK+1
00FF98  1  A2 0C        	LDX	#12	;offset to first region to checksum
00FF9A  1  20 A9 FF     	JSR	CRR	;checksum region of ROM
00FF9D  1  20 A9 FF     	JSR	CRR	;checksum region of ROM
00FFA0  1  AD F8 FF     	LDA	$FFF8	;low checksum from ROM
00FFA3  1  AE F9 FF     	LDX	$FFF9	;high checksum from ROM
00FFA6  1  4C 86 FF     	JMP	VCS	;verify checksum, return
00FFA9  1               ;	SPACE	4,10
00FFA9  1               ;**	CRR - Checksum Region of ROM
00FFA9  1               ;*
00FFA9  1               ;*	ENTRY	JSR	CRR
00FFA9  1               ;*		X = offset
00FFA9  1               ;*
00FFA9  1               ;*	MODS
00FFA9  1               ;*		Original Author Unknown
00FFA9  1               ;*		1. Bring closer to Coding Standard (object unchanged).
00FFA9  1               ;*		   R. K. Nordin	11/01/83
00FFA9  1               
00FFA9  1               
00FFA9  1               CRR	=	*	;entry
00FFA9  1               
00FFA9  1               ;	Transfer range addresses.
00FFA9  1               
00FFA9  1  A0 00        	LDY	#0
00FFAB  1               
00FFAB  1  BD D7 FF     CRR1	LDA	TARV,X
00FFAE  1  99 9E 00     	STA	STADR1,Y
00FFB1  1  E8           	INX
00FFB2  1  C8           	INY
00FFB3  1  C0 04        	CPY	#4	;4 bytes for 2 addresses
00FFB5  1  D0 F4        	BNE	CRR1	;if not done
00FFB7  1               
00FFB7  1               ;	Checksum range.
00FFB7  1               
00FFB7  1  A0 00        	LDY	#0
00FFB9  1               
00FFB9  1  18           CRR2	CLC
00FFBA  1  B1 9E        	LDA	(STADR1),Y
00FFBC  1  65 8B        	ADC	STCHK
00FFBE  1  85 8B        	STA	STCHK
00FFC0  1  90 02        	BCC	CRR3	;if low value non-zero
00FFC2  1               
00FFC2  1  E6 8C        	INC	STCHK+1	;adjust high value
00FFC4  1               
00FFC4  1  E6 9E        CRR3	INC	STADR1	;advance address
00FFC6  1  D0 02        	BNE	CRR4	;if low address non-zero
00FFC8  1               
00FFC8  1  E6 9F        	INC	STADR1+1	;adjust high address
00FFCA  1               
00FFCA  1  A5 9E        CRR4	LDA	STADR1	;current address
00FFCC  1  C5 A0        	CMP	STADR2	;end of range
00FFCE  1  D0 E9        	BNE	CRR2	;if not done
00FFD0  1               
00FFD0  1  A5 9F        	LDA	STADR1+1
00FFD2  1  C5 A1        	CMP	STADR2+1
00FFD4  1  D0 E3        	BNE	CRR2	;if not done
00FFD6  1               
00FFD6  1  60           	RTS		;return
00FFD7  1               ;	SPACE	4,10
00FFD7  1               ;**	TARV - Table of Address Ranges to Verify
00FFD7  1               
00FFD7  1               
00FFD7  1  02 C0 00 D0  TARV	DW	$C002,$D000	;first 8K ROM, $C002 - $CFFF
00FFDB  1  00 50 00 58  
00FFDF  1  00 D8 00 E0  
00FFE3  1               	DW	$5000,$5800	;first 8K ROM, $D000 - $D7FF
00FFE3  1               	DW	$D800,$E000	;first 8K ROM, $D800 - $DFFF
00FFE3  1               
00FFE3  1  00 E0 F8 FF  	DW	$E000,$FFF8	;second 8K ROM, $E000 - $FFF7
00FFE7  1  FA FF 00 00  
00FFEB  1               	DW	$FFFA,$0000	;second 8K ROM, $FFFA - $FFFF
00FFEB  1               ;	SUBTTL	'Second 8K ROM Identification and Checksum'
00FFEB  1               ;	SPACE	4,10
00FFEB  1  00 00 00     	FIX	$FFEE
00FFEE  1               ;	SPACE	4,10
00FFEE  1               ;**	Second 8K ROM Identification and Checksum
00FFEE  1               
00FFEE  1               
00FFEE  1  10 05 83 02  	DB	IDDAY,IDMON,IDYEAR		;date (day, month, year)
00FFF2  1  42 42 00 00  
00FFF6  1  01 02 00 00  
00FFFA  1               	DB	IDCPU				;CPU series
00FFFA  1               	DB	IDPN1,IDPN2,IDPN3,IDPN4,IDPN5	;part number
00FFFA  1               	DB	IDREV				;revision number
00FFFA  1               	DW	$0000				;reserved for checksum
00FFFA  1               ;	SUBTTL	'6502 Machine Vectors'
00FFFA  1               ;	SPACE	4,10
00FFFA  1               	FIX	$FFFA
00FFFA  1               ;	SPACE	4,10
00FFFA  1               ;**	6502 Machine Vectors
00FFFA  1               
00FFFA  1               
00FFFA  1  18 C0 AA C2  	DW	NMI	;vector to process NMI
00FFFE  1  2C C0        
010000  1               	DW	RES	;vector to process RESET
010000  1               	DW	IRQ	;vector to process IRQ
010000  1               ;	SPACE	4,10
010000  1               	.END
